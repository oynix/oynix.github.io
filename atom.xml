<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oynix</title>
  
  <subtitle>人生需要一些摸鱼时刻，做什么都可以，不做什么也可以</subtitle>
  <link href="https://oynix.github.io/atom.xml" rel="self"/>
  
  <link href="https://oynix.github.io/"/>
  <updated>2022-05-09T14:52:59.686Z</updated>
  <id>https://oynix.github.io/</id>
  
  <author>
    <name>oynix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JetBrains证书服务器</title>
    <link href="https://oynix.github.io/2022/05/c53c55583592/"/>
    <id>https://oynix.github.io/2022/05/c53c55583592/</id>
    <published>2022-05-09T14:13:01.000Z</published>
    <updated>2022-05-09T14:52:59.686Z</updated>
    
    <content type="html"><![CDATA[<p>上回说到新版本的IDE中都开始用JetBrains账号登陆，限制了很多行为，今天又发现一个新的方式。</p><span id="more"></span><p>有一说一，JetBrains的IDE确实好用，连Android Studio也是在IntelliJ IDEA的基础上开发出来的，但它有一个绝对优势的改良，那就是免费，给了我们这些本不富裕的家庭很大的理解。</p><p>对于并不免费的JetBrains家族的IDE们，早前最普遍的破解方式，就是从网上找不愿透露姓名的热心网友提供的公开license，或者认证服务器，随便一搜就有一大片，至于可用性要自己一一试过才知道，这种方式与其说是破解，倒不如直接说是白嫖，该花的钱都花了，只是花钱的不是自己罢了。但是这种方式有个弊端，就是不稳定，下班关机前还能开开心心敲代码，等到第二天再来，发现失效了，要么就是验证失败了。这个时候，又要从头再来，接着从网上搜索，一个一个过滤，相当麻烦，别人都写完几个bug了，你连IDE还没打开。</p><p>后来，聪明机智的神秘东方网友，发现了一种曲线救国的方式，所有收费的IDE都是有一个30天的试用期的，试用期间的功能和正版license的功能是完全一样的，这下我不想着破解了，我就试用，等快到期了，我就把试用期重置，这样又能试用30天，用完这30天还有30天，在这30天后面等着的，是下一个30天。</p><p>就这样，上有政策下有对策，JetBrains高一尺，网友们高一尺五，相互制衡之下，也算是相安无事。直到几个月前，横空出世的JetBrains账号，打破了这原本平静的局面。</p><p>新版本的IDE，要想试用，就需要先登录一个叫做JetBrains账号的东西，如果没有，跳到官网便可注册。看到这，我大抵是懂了，开始要绑定了，不知道是不是和Unity学的，试用的30天和账号绑定起来了，这样就没法无限试用了。当然，这还只是我的猜测，没去验证，因为咱们这边表示这个账号的门槛太高，直接给咱们拦住了，所以就没试。</p><p>好在还有退路，那就是，不升级，专门盯着官网的老版本下载。</p><p>但是，转折来了，这也是今天要说的主题（铺垫了这么久，总算到了主题）。</p><p>发现了一个服务器的搜索引擎。什么意思呢，搜索引擎，像谷歌，像百度，可以根据输入的关键词搜索到网络上公开的一些资源，比如网页，比如图片。而服务器搜索引擎，则是根据输入的条件，搜索网络上开放的机器，一台网络上的机器要想提供服务，总是要暴露出一些端口出来的，比如网页服务暴露80端口，https服务要暴露443接口，只要暴露出来，就可以被扫描到，这就是服务器搜索引擎的大致原理。</p><p>服务器搜索引擎：<span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2guY2Vuc3lzLmlvLw==">https://search.censys.io/<i class="fa fa-external-link-alt"></i></span></p><p>过滤条件是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.http.response.headers.location: account.jetbrains.com/fls-auth</span><br></pre></td></tr></table></figure><p>这是固定的语法，大致的意思就是，访问器的回应消息头中的location，包含jetbrains。依据这个条件，判断这个机器是提供JetBrains认证服务的，那么把这个地址填到IDE的认证框里即可，如果不能用，就从搜索结果列表里换一个，这种比之前大海捞针的方式高效、快捷多了。</p><p>最后还是要说一句，家里条件好的同学，要去买买正版。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上回说到新版本的IDE中都开始用JetBrains账号登陆，限制了很多行为，今天又发现一个新的方式。&lt;/p&gt;</summary>
    
    
    
    <category term="JetBrains" scheme="https://oynix.github.io/categories/JetBrains/"/>
    
    
    <category term="JetBrains" scheme="https://oynix.github.io/tags/JetBrains/"/>
    
  </entry>
  
  <entry>
    <title>Android存储文件路径汇总</title>
    <link href="https://oynix.github.io/2022/05/eb42e35aec3a/"/>
    <id>https://oynix.github.io/2022/05/eb42e35aec3a/</id>
    <published>2022-05-06T14:10:56.000Z</published>
    <updated>2022-05-07T01:28:03.205Z</updated>
    
    <content type="html"><![CDATA[<p>总结下应用内可用的存储路径。</p><span id="more"></span><p>Context获取存储目录的方法比较多，比如File目录，Cache目录，大致上可以分为两类，一类是应用内私有，只有应用自身可以访问，其他应用不可以直接访问，对于用户也是不可见的，但可以通过FileProvider将文件分享出去；另一类是应用外私有，同样是应用自身可以访问，但是用户是可以看到的。它们的共同点是，不需要系统权限，同时，会随着应用卸载而被删除。若不想被删除，那么就需要存储到共有目录中，而访问共有目录，就需要申请系统权限了。</p><h3 id="1-应用内私有"><a href="#1-应用内私有" class="headerlink" title="1. 应用内私有"></a>1. 应用内私有</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Context.getCacheDir();</span><br><span class="line">Context.getDataDir();</span><br><span class="line">Context.getFilesDir();</span><br><span class="line">Context.getCodeCacheDir();</span><br><span class="line">Context.getDir(String name, <span class="keyword">int</span> mode);</span><br></pre></td></tr></table></figure><p>这几个目录，所有的机型大致都在这个目录下，其中package name就是应用的包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/data/package_name/</span><br></pre></td></tr></table></figure><p>其中，getDataDir指的就是该目录，其他的则会在该目录下创建文件夹，CacheDir对应cache目录，FilesDir对应files目录，CodeCache对应code_cache目录，而getDir则会创建新目录，名字就是第一个参数加上app前缀。</p><h3 id="2-应用外私有"><a href="#2-应用外私有" class="headerlink" title="2. 应用外私有"></a>2. 应用外私有</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Context.getExternalCacheDir();</span><br><span class="line">Context.getExternalCacheDirs();</span><br><span class="line">Context.getExternalFilesDir();</span><br><span class="line">Context.getExternalFilesDirs();</span><br></pre></td></tr></table></figure><p>这几个目录，基本在这，package name也是应用包名，因为位于storage下，所以，对于用户是可见的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sdcard/Android/package_name/</span><br></pre></td></tr></table></figure><p>或者，还有其他的目录映射，不同机型可能会有所差别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/storage/self/primary/Android/package_name/</span><br></pre></td></tr></table></figure><h3 id="3-公有目录"><a href="#3-公有目录" class="headerlink" title="3. 公有目录"></a>3. 公有目录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment.getExternalStorageDirectory();</span><br></pre></td></tr></table></figure><p>这个目录，对应的共有路径，访问这个目录，需要申请系统的读写外部存储的权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sdcard/</span><br><span class="line">/storage/self/primary/</span><br></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul><li>应用私有的目录，在应用卸载时会被系统删除</li><li>不同的ROM，路径可能会有差别，但是获取方式和使用原则是一样的</li><li>要想把应用私有目录下的文件分享出去，参考<a href="https://oynix.github.io/2022/04/a19e8bb0ccff/">FileProvider的使用</a></li><li>共有目录需要权限，私有的不需要，所以若不是必要，存储在应用私有的目录即可，减少权限的申请</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结下应用内可用的存储路径。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://oynix.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>SharedFlow和StateFlow</title>
    <link href="https://oynix.github.io/2022/05/5e396ce92540/"/>
    <id>https://oynix.github.io/2022/05/5e396ce92540/</id>
    <published>2022-05-04T04:25:47.000Z</published>
    <updated>2022-05-04T05:32:19.874Z</updated>
    
    <content type="html"><![CDATA[<p>说完Flow，再来看看它的两个子类，SharedFlow和StateFlow。</p><span id="more"></span><h3 id="1-冷流，热流"><a href="#1-冷流，热流" class="headerlink" title="1. 冷流，热流"></a>1. 冷流，热流</h3><p>在说之前，要先看看这两种流有什么不同。冷流，指的是只有在消费者消费时才会生产数据。而热流，即便没有活跃的消费者，它们也可以存活，也就是说，数据在流外产生，然后传递给数据流，这样便不依赖收集者。</p><h3 id="2-SharedFlow"><a href="#2-SharedFlow" class="headerlink" title="2. SharedFlow"></a>2. SharedFlow</h3><p>相比于冷流Flow，SharedFlow是热流，它以广播的形式向流的所有收集者发射数据，所以，所有的收集者都可以接收到发射的数据。它之所以叫做热流，是因为它的实例独立于收集者的存在而存在，这一点区别于flow函数创建的Flow，它是冷流，并且为每个收集者单独启动。</p><p>SharedFlow永远不会完成，通过调用流的collect不会正常完成，通过launchIn函数调用也不会正常完成。SharedFlow的活跃收集者称为订阅者。</p><p>订阅者是可以被取消的。通常随着协程运行所在的scope的取消而取消。一个SharedFlow的订阅者总是可以取消的，所以每次发射数据前都会对其作出检查。流的多数终端操作符在SharedFlow上都不会完成，比如toList，但是流的裁剪操作符可以完成，比如take、takeWhile。</p><p>SharedFlow会保存指定数量的最新的数据，存储在replay cache里，每一个新的订阅者，都会先从获取replay cache中的数据，然后才是新发射的数据。replay cache的大小可在创建时通过参数replayCache指定。也可通过resetReplayCache重置replay cache。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _events = MutableSharedFlow&lt;Event&gt;() <span class="comment">// private mutable shared flow</span></span><br><span class="line">    <span class="keyword">val</span> events = _events.asSharedFlow() <span class="comment">// publicly exposed as read-only shared flow</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produceEvent</span><span class="params">(event: <span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">        _events.emit(event) <span class="comment">// suspends until all subscribers receive it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是通过MutableSharedFlow创建了一个流，也可以通过shareIn操作符，将一个冷流转化成为SharedFlow。在发射数据时，方法会挂起，直到所有的订阅者接收到了数据并返回。</p><p>和Channel类似，SharedFlow也提供了缓冲区的配置参数，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">MutableSharedFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    replay: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    extraBufferCapacity: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    onBufferOverflow: <span class="type">BufferOverflow</span> = BufferOverflow.SUSPEND</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: MutableSharedFlow&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>replay表示存储的倒数最新事件的数量，buffer capacity则是缓冲区的容量大小，overflow为缓冲区数据满时，再发射数据时的行为策略，同样还是有三种：挂起等待、扔掉最新数据和扔掉最老的数据。</p><h3 id="3-StateFlow"><a href="#3-StateFlow" class="headerlink" title="3. StateFlow"></a>3. StateFlow</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StateFlow</span>&lt;<span class="type">out T</span>&gt; : <span class="type">SharedFlow</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> value: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从接口定义可以看出，StateFlow是SharedFlow的子类，所以SharedFlow的特性它都有，区别在于，它只保存最新的数据，只有一个数据值，这个时候也可以称它为状态，所以的它的名字是StateFlow</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">MutableStateFlow</span><span class="params">(value: <span class="type">T</span>)</span></span>: MutableStateFlow&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="4-SharedFlow和StateFlow的不同"><a href="#4-SharedFlow和StateFlow的不同" class="headerlink" title="4. SharedFlow和StateFlow的不同"></a>4. SharedFlow和StateFlow的不同</h3><ul><li>从创建方法可以看出，StateFlow有初始值，SharedFlow没有。这其实就是replay的大小不同，State固定为1，所以它需要有个初始值，而Shared不确定，所以不需要。</li></ul><h3 id="5-应用"><a href="#5-应用" class="headerlink" title="5. 应用"></a>5. 应用</h3><p>根据二者的特点，可以看出，SharedFlow适合应用于事件的场景，而StateFlow则是适合用于更新状态的场景。</p><h3 id="6-和LiveData对比"><a href="#6-和LiveData对比" class="headerlink" title="6. 和LiveData对比"></a>6. 和LiveData对比</h3><p>说完上面那些，感觉这些又和LiveData有些相似，其实它们之间还是有着一些不同。</p><p>LiveData是生命周期敏感的，因为它里面维护着Lifecycle，所以在进入到DESTROYED状态时，会取消当前的Observer，而Flow则是通过检查订阅者所在的协程是否还活跃来判断是否向其发射数据。</p><p>此外，LiveData是不防抖动的，也就是说，每次postValue都会通知给Observer，而StateFlow是防抖动的，因为它固定保留一个最新的状态值，在每次发射数据前，都会把要发射的数据和当前保存的值对比，如果相同则忽略这次发射，所以它是防抖动的。</p><p>最后说一句SharedFlow的shared，它的shared，共享，指的是它的数据对所有的收集者，也就是订阅者共享，同一个数据会广播给所有的订阅者，而冷流Flow，对于每一个收集者，都会执行生成数据的操作，所以它是独立的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;说完Flow，再来看看它的两个子类，SharedFlow和StateFlow。&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://oynix.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://oynix.github.io/tags/Kotlin/"/>
    
    <category term="SharedFlow" scheme="https://oynix.github.io/tags/SharedFlow/"/>
    
    <category term="StateFlow" scheme="https://oynix.github.io/tags/StateFlow/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin的Channel</title>
    <link href="https://oynix.github.io/2022/05/586878aa60a4/"/>
    <id>https://oynix.github.io/2022/05/586878aa60a4/</id>
    <published>2022-05-04T01:12:29.000Z</published>
    <updated>2022-05-04T02:24:16.243Z</updated>
    
    <content type="html"><![CDATA[<p>Channel，直译过来就是通道的意思，有从通道读取别人数据的通道，也有将数据写给别人的通道，当然，也有既可以读数据也可以写数据的通道。这是通俗的解释，专业一点来讲，通道就是生产者消费者的模型。</p><span id="more"></span><h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1. 使用"></a>1. 使用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个Channel类型的实例</span></span><br><span class="line">    <span class="keyword">val</span> channel = Channel&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者：负责向通道中写数据</span></span><br><span class="line">    <span class="keyword">val</span> producer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            channel.send(i++)</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者：负责从通道中读数据</span></span><br><span class="line">    <span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> element = channel.receive()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    producer.join()</span><br><span class="line">    consumer.join()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Channel方法就可以方便的初始化出来一个通道实例，因为channel的send和receive方法，都是挂起函数，所以要将它们放到协程中调用。为什么都是挂起函数呢？既然是生产者消费者模型，那么肯定就存在速度不同步的情况，生产者生产出一个数据，但是消费者还在忙碌中，写入后无法被接收，那么它就挂起等待；消费者也是同理，它想从通道读取一个数据来处理，但是生产者还没生产出来，那么它也挂起等待，所以这两个函数都是挂起函数。</p><h3 id="2-通道的缓存"><a href="#2-通道的缓存" class="headerlink" title="2. 通道的缓存"></a>2. 通道的缓存</h3><p>通道提供了缓存，来缓解生产者和消费者之间速度差问题。我们上面创建通道使用的Channel，它不是一个构造函数，而是一个伪造成构造方法的工厂方法，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E&gt;</span> <span class="title">Channel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    capacity: <span class="type">Int</span> = RENDEZVOUS,</span></span></span><br><span class="line"><span class="params"><span class="function">    onBufferOverflow: <span class="type">BufferOverflow</span> = BufferOverflow.SUSPEND,</span></span></span><br><span class="line"><span class="params"><span class="function">    onUndeliveredElement: ((<span class="type">E</span>) -&gt; <span class="type">Unit</span>)? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Channel&lt;E&gt; =</span><br><span class="line">    <span class="keyword">when</span> (capacity) &#123;</span><br><span class="line">        RENDEZVOUS -&gt; RendezvousChannel()</span><br><span class="line">        UNLIMITED -&gt; LinkedListChannle()</span><br><span class="line">        CONFLATED -&gt; ConflatedChannle()</span><br><span class="line">        <span class="keyword">else</span> -&gt; ArrayChannel(capacity)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>它有3个参数，分别是通道缓存的容量、超出缓存容量时的行为策略，以及超出元素的处理操作。</p><ul><li>capacity<br>RENDEZVOUS，这个词直译过来是约会的意思，虽然现代人的约会千奇百怪，但是在设计者的想法里，约会就是一对一的形式，所以这种情况下，通道是没有缓存的，生产者写不进数据就等着，消费者读不到数据也等着；<br>UNLIMITED这个就很好理解了，没有限制，所以它是一个LinkedList类型的通道，来者不拒，所有来不及消费的数据我都给你缓存下来；<br>CONFLATED这个词和inflate正好相反，还记得我们在加载布局文件时，用的是LayoutInflater的inflate方法，它是扩充、扩张的意思，所以conflate就是合并、缩小的意思，实际的效果就是，这种类型的通道只缓存最新的、最后一个元素。<br>ArrayChannel也很好理解，根据传入的capacity创建一个固定容量的数组型通道。</li><li>onBufferOverflow<br>即便是给通道设置了缓存，那么还是有超出缓存容量的可能，这个参数就是用来设置超出容量时的行为，它有3个可选值：SUSPEND，顾名思义，就是挂起等待的意思；DROP_OLDEST，丢弃最老的，也就是最新的会把最老的元素挤掉；DROP_LATEST，刚好相反，丢弃最新的。</li><li>onUndeliveredElement<br>一个可选参数，当数据元素发送后，但是没有传送到消费者，这个函数就会被调用</li></ul><h3 id="3-迭代通道"><a href="#3-迭代通道" class="headerlink" title="3. 迭代通道"></a>3. 迭代通道</h3><p>前面的例子中，消费者从通道中读取数据时，是在while循环里操作的，实际上，通道本身是支持迭代的，所以消费者还可以这样写，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> iterator = channel.iterator()</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> element = iterator.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有数据时，协程就会在hasNext方法挂起，直到有新的数据写入到通道内，这个写法自然还可以进一步简化成foreach，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> consumer = GlobalScope.launch &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> channel)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-通道的关闭"><a href="#4-通道的关闭" class="headerlink" title="4. 通道的关闭"></a>4. 通道的关闭</h3><p>Channel本身是个接口类型，它继承了读通道和写通道</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span>&lt;<span class="type">E</span>&gt; : <span class="type">SendChannel</span>&lt;<span class="type">E</span>&gt;, <span class="type">ReceiveChannel</span>&lt;<span class="type">E</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>它的父接口中，只有写通道，也就是SendChannel有关闭方法，而ReceiveChannel没有关闭方法。这是什么意思呢？这就好比会上领导发言，领导讲话结束之后，都会说上一句我说完了，这个时候你也听完了，如果领导刚说到一半，你急着下班回家，然后你说一句我听完了，那么领导这个时候是说，还是不说呢。所以，结束这个事要由发送者来调用。</p><p>SendChannel有一个isClosedForSend的属性，当调用close后，这个属性会立刻返回true，表示不会再向通道中写入数据。同样，ReceiveChannle有个isClosedForReceive的属性，因为有缓冲的存在，所以只有当缓冲区内的数据都被处理完时，这个属性才会返回true。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Channel，直译过来就是通道的意思，有从通道读取别人数据的通道，也有将数据写给别人的通道，当然，也有既可以读数据也可以写数据的通道。这是通俗的解释，专业一点来讲，通道就是生产者消费者的模型。&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://oynix.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://oynix.github.io/tags/Kotlin/"/>
    
    <category term="Channel" scheme="https://oynix.github.io/tags/Channel/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Flow</title>
    <link href="https://oynix.github.io/2022/05/54728a7f7b90/"/>
    <id>https://oynix.github.io/2022/05/54728a7f7b90/</id>
    <published>2022-05-03T10:33:33.000Z</published>
    <updated>2022-05-04T01:11:20.990Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin的Flow和RxJava有着很多相似之处，提供了很多操作符来操作数据流。简单写一些使用笔记</p><span id="more"></span><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><ul><li>冷流<br>创建后不发射数据，使用终端操作符后才触发发射数据。</li><li>生产消费交替执行<br>在数据流上，发射数据的称为生产者，处理数据的称为消费者，二者交替执行，生产-消费-生产-消费，在考虑背压情况下，生产次数可能会多于消费次数。</li></ul><p>同RxJava，所以Flow也是有着大量的操作符，掌握了这些操作符，基本也就会用了。</p><h3 id="1-流构建器"><a href="#1-流构建器" class="headerlink" title="1. 流构建器"></a>1. 流构建器</h3><ul><li>flow方法<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow &#123; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123; emit(i) &#125; &#125;.collect &#123; println(it) &#125;</span><br></pre></td></tr></table></figure></li><li>flowOf方法<br>内部调用的是flow方法<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).collect &#123; print(it) &#125;</span><br></pre></td></tr></table></figure></li><li>asFlow方法<br>内部调用的还是flow方法<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).asFlow().collect &#123; print(it) &#125;</span><br></pre></td></tr></table></figure>此外，还有几个其他的，提供的默认构建器都写在<code>Builders.kt</code>里。</li></ul><h3 id="2-切换线程操作符"><a href="#2-切换线程操作符" class="headerlink" title="2. 切换线程操作符"></a>2. 切换线程操作符</h3><p>是用操作符<code>flowOn</code>来切换上游操作发生的线程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).flowOn(Dispatchers.IO).collect &#123; print(it) &#125;</span><br></pre></td></tr></table></figure><p>而处理数据所在的线程取决于调用终端操作符的线程</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上游发射数据操作发生在IO线程</span></span><br><span class="line"><span class="keyword">val</span> flow = flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).flowOn(Dispatchers.IO)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理数据发生的主线程</span></span><br><span class="line">mainScope.launch &#123;</span><br><span class="line">    flow.collect &#123; print(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理数据发生在子线程</span></span><br><span class="line">ioScope.launch &#123;</span><br><span class="line">    flow.collect &#123; print(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-终端操作符"><a href="#3-终端操作符" class="headerlink" title="3. 终端操作符"></a>3. 终端操作符</h3><p>上面提到了终端操作符，所谓终端操作符，就是在这条数据流上末端调用的操作符，即触发收集数据的操作，除了上面提到的collect，还有几个：</p><ul><li>collect：收集所有</li><li>first/single：取首个/单个（只允许有一个，否则报错）</li><li>toList/toSet/toCollection：转化成集合</li><li>count：计数</li><li>reduce/fold：合并，同集合操作，fold有初始值reduce没有</li><li>launchIn/produceIn/broadcastIn：触发流启动</li></ul><h3 id="4-过渡操作符"><a href="#4-过渡操作符" class="headerlink" title="4. 过渡操作符"></a>4. 过渡操作符</h3><ul><li>filter<br>过滤操作，返回一个boolean值，true时将传入下游<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;.collect &#123; print(it) &#125;</span><br></pre></td></tr></table></figure></li><li>map<br>这里的转换操作是指，将上游流中的传下来的每个数据转换成其他形式<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map &#123; <span class="string">&quot;to String: <span class="variable">$it</span>&quot;</span> &#125;.collect &#123; print(it) &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-限长操作符"><a href="#5-限长操作符" class="headerlink" title="5. 限长操作符"></a>5. 限长操作符</h3><p>使用take来限制传到下游数据的数量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).take(<span class="number">2</span>).collenct &#123; print(it) &#125;</span><br></pre></td></tr></table></figure><h3 id="6-转换操作符"><a href="#6-转换操作符" class="headerlink" title="6. 转换操作符"></a>6. 转换操作符</h3><p>常用transform，可以实现map和filter，也可以实现更为复杂的转换，可以发射任意次数据</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).transform &#123;</span><br><span class="line">    <span class="keyword">if</span> (it &gt; <span class="number">1</span>) emit(it * it)</span><br><span class="line">    <span class="keyword">if</span> (it &gt; <span class="number">2</span>) emit(it * <span class="number">10</span>)</span><br><span class="line">    emit(it)</span><br><span class="line">&#125;.collect &#123; print(it) &#125;</span><br></pre></td></tr></table></figure><h3 id="7-捕获异常"><a href="#7-捕获异常" class="headerlink" title="7. 捕获异常"></a>7. 捕获异常</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).<span class="keyword">catch</span> &#123; print(it) &#125;.collect &#123; print(it) &#125;</span><br></pre></td></tr></table></figure><h3 id="8-背压"><a href="#8-背压" class="headerlink" title="8. 背压"></a>8. 背压</h3><p>背压是指上游生成数据的速度高于下游处理数据的速度，这个时候下游应该怎么办。一般有这么几种策略：把多出的扔掉、把多出的合并和把多出的缓存</p><ul><li>conflate<br>合并的意思是，只保留最新的，当消费者正在忙的时候，生产出来的数据直接放弃了。如，生产者每100ms生产一个数据，但是消费者处理一个数据需要500ms，那么，消费者只能处理到第1，5，10…个数据<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">        emit(i)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.conflate()</span><br><span class="line">.collect &#123;</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    pritnt(<span class="string">&quot;finish with <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>collectLatest<br>收集最新数据，对于每一个从上游传来的数据，消费者如果正在忙碌，那么就取消当前的任务，来处理最新来的数据。意思就是说，消费者对于每一个数据都会处理，但不一定能处理完。对于下面这个例子，前面的数据都只能打出begin，只有最后一条数据能打出begin和finish<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flor &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">        emit(i)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.collectLatest &#123;</span><br><span class="line">    print(<span class="string">&quot;begin with <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    print(<span class="string">&quot;finish with <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>buffer<br>缓冲，设置缓冲大小后，会将上游发来的数据存在缓冲池。缓冲池是在生产者和消费者之间创建的一个Channel，缓冲池大小就是Channel的大小，同时允许配置生产的数据超过缓冲池大小时的行为，挂起、扔掉最新和扔掉最旧<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flor &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">        emit(i)</span><br><span class="line">        delay(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.buffer(<span class="number">3</span>)</span><br><span class="line">.collectLatest &#123;</span><br><span class="line">    print(<span class="string">&quot;begin with <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">500</span>)</span><br><span class="line">    print(<span class="string">&quot;finish with <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-合并流"><a href="#9-合并流" class="headerlink" title="9. 合并流"></a>9. 合并流</h3><ul><li>zip<br>合并两个流成一个流，最终流的长度取决于最短流的长度<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> flow = flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).onEach &#123; delay(<span class="number">10</span>) &#125;</span><br><span class="line"><span class="keyword">val</span> flow2 = flowOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>).onEach &#123; delay(<span class="number">15</span>) &#125;</span><br><span class="line">flow.zip(flow2) &#123; i, s -&gt; i.toString() + s &#125;.collect &#123;</span><br><span class="line">    println(it) <span class="comment">// Will print &quot;1a 2b 3c&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>combine<br>它和zip的区别是，最终流的长度是较长流的长度，在合并时，使用另一个流中最新的数据<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> flow = flowOf(<span class="number">1</span>, <span class="number">2</span>).onEach &#123; delay(<span class="number">10</span>) &#125;</span><br><span class="line"><span class="keyword">val</span> flow2 = flowOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>).onEach &#123; delay(<span class="number">15</span>) &#125;</span><br><span class="line">flow.combine(flow2) &#123; i, s -&gt; i.toString() + s &#125;.collect &#123;</span><br><span class="line">    println(it) <span class="comment">// Will print &quot;1a 2a 2b 2c&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-其他操作符"><a href="#10-其他操作符" class="headerlink" title="10. 其他操作符"></a>10. 其他操作符</h3><ul><li>onEach<br>在收集每个数据前，可以插入一些操作<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).onEach &#123; print(it) &#125;.collect &#123; print(it) &#125;</span><br></pre></td></tr></table></figure></li><li>onStart<br>在收集前加入操作<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).onStart &#123; emit(<span class="number">0</span>) &#125;.collect &#123; print(it) &#125;</span><br></pre></td></tr></table></figure></li><li>onCompletion<br>同上，参数是Throwable，如果处理过程中有异常，便通过这个参数传出<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).onCompletion &#123; print(<span class="string">&quot;exception:<span class="subst">$&#123;it?.toString()&#125;</span>&quot;</span>) &#125;.collect &#123; print(it) &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Kotlin的Flow和RxJava有着很多相似之处，提供了很多操作符来操作数据流。简单写一些使用笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://oynix.github.io/categories/Kotlin/"/>
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://oynix.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit使用</title>
    <link href="https://oynix.github.io/2022/05/59844027c896/"/>
    <id>https://oynix.github.io/2022/05/59844027c896/</id>
    <published>2022-05-02T05:12:43.000Z</published>
    <updated>2022-05-02T11:38:11.715Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章简单说了OkHttp的使用，这篇来说Retrofit。同样，Retrofit也是Square公司出品。</p><span id="more"></span><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NxdWFyZS9yZXRyb2ZpdA==">Retrofit Github地址<i class="fa fa-external-link-alt"></i></span></p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>在OkHttp的封装下，我们发送网络请求方便了很多，省去了很多重复性的样板代码。而Retrofit的作用，是进一步减少样板代码量，比如发送POST请求时，每次都需要将参数转化成JSON格式，添加到Body中，发送到服务器。接收回应时，每次也是需要先将Response里的Body解析成类，然后从中读取需要的参数。Retrofit通过注解的形式，将这些重复性的工作也省去了。</p><p>Retrofit中使用了大量的注解，请求方式、请求参数等均使用注解来标明，记住这些注解，基本就掌握了用法。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>是用Retrofit大致分为4个步骤</p><ul><li>创建Retrofit实例<br>Retrofit支持配置一些选项，比如CallAdapter、Converter等</li><li>创建请求API的接口<br>这里只需要写接口，而不需要写具体实现，Retrofit使用动态代理的方式，来满足调用者</li><li>生成请求API的实例<br>通过第一步中生成的Retrofit实例，来生成上一步中接口的实例</li><li>通过请求API的实例发送请求<br>使用上一步中的实例，就可以发送网络请求了</li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>看了上面的步骤会觉得很抽象，下面举个简单的例子，就会很具体了。比如，通过GET获取用户信息，通过POST更新用户名称。</p><p>这是一个用来描述用户的类，只有两个字段，一个是id，一个用户名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述用户的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，创建一个Retrofit的实例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                        .baseUrl(<span class="string">&quot;https://useinfo.hostname.com/&quot;</span>)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以手动增加一些配置，这里添加了一个Gson的转换器，和一个RxJava的CallAdapter，后面介绍</span></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                        .baseUrl(<span class="string">&quot;https://useinfo.hostname.com/&quot;</span>)</span><br><span class="line">                        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">                        .build();</span><br></pre></td></tr></table></figure><p>第二步，创建请求API的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GET(&quot;user/&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;UserInfo&gt; <span class="title">getInfo</span><span class="params">(<span class="meta">@Path(&quot;userId&quot;)</span> <span class="keyword">int</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(&quot;user&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;String&gt; <span class="title">updateUser</span><span class="params">(<span class="meta">@Body</span> UserInfo user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，生成请求API的实例，因为上面的请求API还只是接口，并不能直接用，要先生成实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserApi api = retrofit.create(UserApi.class);</span><br></pre></td></tr></table></figure><p>最后一步，用实例发送请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line">UserInfo user = api.getInfo(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改用户名字</span></span><br><span class="line">user.name = <span class="string">&quot;new Name&quot;</span>;</span><br><span class="line">String message = api.updateUser(user);</span><br></pre></td></tr></table></figure><p>以上，便是一个简单的调用，可以看到的是，确实都是注解堆起来的，所以，下面看看都有哪些注解，每个注解的用法。</p><h3 id="4-注解"><a href="#4-注解" class="headerlink" title="4. 注解"></a>4. 注解</h3><p>注解可以分为3类：网络请求方法类、标记类和网络请求参数类。</p><ul><li>网络请求方法<br>可以说Retrofit是RESTful风格请求的封装，注解和请求方式一一对应<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span></span><br><span class="line"><span class="meta">@POST</span></span><br><span class="line"><span class="meta">@PUT</span></span><br><span class="line"><span class="meta">@DELETE</span></span><br><span class="line"><span class="meta">@PATCH</span></span><br><span class="line"><span class="meta">@HEAD</span></span><br><span class="line"><span class="meta">@OPTIONS</span></span><br><span class="line"><span class="meta">@HTTP</span>：自定义HTTP请求 <span class="meta">@HTTP(method = &quot;DELETE&quot;, path = &quot;remove/&quot;, hasBody = true)</span></span><br></pre></td></tr></table></figure>使用这些注解，便可以标明一个方法的网络请求方法，注解接收一个参数，表明请求的路径，就像上面例子中的那样。Retrofit将URL分成了两部分，第一部分是主机地址，在创建Retrofit时配置的baseUrl，另一部分就是每个请求的具体路径，最终的请求URL就是base后面接上请求方法里的路径，后面会单独说这里要注意的地方</li><li>标记类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FormUrlEncoded</span>：表明是Form表单，需要和<span class="meta">@Field</span>搭配使用，参数使用<span class="meta">@Field</span>修饰</span><br><span class="line"><span class="meta">@Multipart</span>：表明body是multi-part，需要和<span class="meta">@Part</span>搭配使用，参数使用<span class="meta">@Part</span>修饰</span><br><span class="line"><span class="meta">@Streaming</span>：表示数据以流的形式返回，适用于返回数据较大的场景，如果不标记，默认把数据全部载入内存，取数据是从内存取</span><br></pre></td></tr></table></figure>这几个注解是用来标记方法的。</li><li>网络请求参数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Header</span>：<span class="function">Call&lt;ResponseBody&gt; <span class="title">foo</span><span class="params">(<span class="meta">@Header(&quot;Accept-Language&quot;)</span> String lang)</span></span></span><br><span class="line"><span class="function">@Headers：与上面不同，这个注解标记方法</span></span><br><span class="line"><span class="function">@Url：使用这个注解将忽略baseUrl配置  Call&lt;ResponseBody&gt; <span class="title">list</span><span class="params">(<span class="meta">@Url</span> String url)</span></span>;</span><br><span class="line"><span class="meta">@Body</span>：是用Converter将参数写入到请求body中</span><br><span class="line"><span class="meta">@Path</span>：请求路径的中的参数    <span class="meta">@GET(&quot;/image/&#123;id&#125;&quot;)</span> <span class="function">Call&lt;ResponseBody&gt; <span class="title">example</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"><span class="meta">@Field</span>：form表单的参数 <span class="meta">@FormUrlEncoded</span>  <span class="meta">@POST(&quot;/&quot;)</span> <span class="function">Call&lt;ResponseBody&gt; <span class="title">example</span><span class="params">(<span class="meta">@Field(&quot;name&quot;)</span> String name, <span class="meta">@Field(&quot;occupation&quot;)</span> String occupation)</span></span>;</span><br><span class="line"><span class="meta">@FieldMap</span>：同上，多个参数，修饰<span class="function">Map Call&lt;ResponseBody&gt; <span class="title">things</span><span class="params">(<span class="meta">@FieldMap</span> Map&lt;String, String&gt; fields)</span></span>;</span><br><span class="line"><span class="meta">@Part</span>：这个我很少用，看看Retrofit自己的解释</span><br><span class="line">Denotes a single part of a multi-part request.</span><br><span class="line">The parameter type on which <span class="keyword">this</span> annotation exists will be processed in one of three ways:</span><br><span class="line">If the type is okhttp3.MultipartBody.Part the contents will be used directly. <span class="function">Omit the name from the <span class="title">annotation</span> <span class="params">(i.e., <span class="meta">@Part</span> MultipartBody.Part part)</span>.</span></span><br><span class="line"><span class="function">If the type is RequestBody the value will be used directly with its content type. Supply the part name in the <span class="title">annotation</span> <span class="params">(e.g., <span class="meta">@Part(&quot;foo&quot;)</span> RequestBody foo)</span>.</span></span><br><span class="line"><span class="function">Other object types will be converted to an appropriate representation by using a converter. Supply the part name in the <span class="title">annotation</span> <span class="params">(e.g., <span class="meta">@Part(&quot;foo&quot;)</span> Image photo)</span>.</span></span><br><span class="line"><span class="function">Values may be <span class="keyword">null</span> which will omit them from the request body.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   @Multipart</span></span><br><span class="line"><span class="function">   @<span class="title">POST</span><span class="params">(<span class="string">&quot;/&quot;</span>)</span></span></span><br><span class="line"><span class="function">   Call&lt;ResponseBody&gt; <span class="title">example</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="meta">@Part(&quot;description&quot;)</span> String description,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="meta">@Part(value = &quot;image&quot;, encoding = &quot;8-bit&quot;)</span> RequestBody image)</span></span>;</span><br><span class="line">   </span><br><span class="line">Part parameters may not be <span class="keyword">null</span>.</span><br><span class="line"><span class="meta">@PartMap</span>：同上，修饰Map</span><br><span class="line"><span class="meta">@Query</span>：添加GET请求URL中的参数 例如：user?id=<span class="number">23</span>&amp;name=John  <span class="meta">@GET(&quot;/friends&quot;)</span> <span class="function">Call&lt;ResponseBody&gt; <span class="title">friends</span><span class="params">(<span class="meta">@Query(&quot;page&quot;)</span> <span class="keyword">int</span> page)</span></span>;</span><br><span class="line"><span class="meta">@QueryMap</span>：同上，修饰Map</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-请求的最终URL"><a href="#5-请求的最终URL" class="headerlink" title="5. 请求的最终URL"></a>5. 请求的最终URL</h3><p>Retrofit会根据请求方法注解(@GET, @POST等)里面的路径参数动态生成最终的URL，对于Retrofit的baseUrl配置项，有两种形式，当以斜杠<code>/</code>结尾时是目录形式，当以非斜杠结尾时是文件形式，这两种形式是不同的，对于请求方法注解中写的路径，以斜杠<code>/</code>开头表示绝对路径和不以斜杠开头表示相对路径，这两种形式也是不同的。</p><p>所以在生成最终的请求URL时就会有多种情况：</p><ul><li>情况一，请求方法中写的是https/http开头的完整URL，这时Retrofit便会使用配置的baseUrl，而是直接使用请求方法注解里的值，当所有请求都写的完整请求URL，那么这时候可以不配置baseUrl</li><li>情况二，路径使用的绝对路径，也就是以斜杠<code>/</code>开头，那么这时不管baseUrl是哪种形式，这个路径会直接接到主机和端口后，形成最终的URL<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baseUrl = <span class="string">&quot;https://host:port/a/b&quot;</span></span><br><span class="line">path = <span class="string">&quot;/user&quot;</span></span><br><span class="line">URL = <span class="string">&quot;https://host:port/user&quot;</span></span><br></pre></td></tr></table></figure></li><li>情况三，路径是相对路径，baseUrl是目录形式，那么这时候会直接拼接，形成最终URL<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baseUrl = <span class="string">&quot;https://host:port/a/&quot;</span> <span class="comment">// 这里是斜杠结尾，是目录形式</span></span><br><span class="line">path = <span class="string">&quot;user&quot;</span></span><br><span class="line">URL = <span class="string">&quot;https://host:prot/a/user&quot;</span></span><br></pre></td></tr></table></figure></li><li>情况四，路径是相对路径，但baseUrl是文件形式，那么这时候路径会接到最后一个文件后，形成最终URL。可以这么理解，因为文件下不能有文件，目录下才能有文件，所以user不能接在a的后面。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baseUrl = <span class="string">&quot;https://host:port/a&quot;</span> <span class="comment">// 注意这里没有斜杠结尾，所以是文件形式</span></span><br><span class="line">path = <span class="string">&quot;user&quot;</span></span><br><span class="line">URL = <span class="string">&quot;https://host:port/user&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>按照RESTful的风格来说，一般常用的是，baseUrl是用目录形式，也就是以斜杠<code>/</code>结尾，路径使用相对路径。</p><h3 id="6-CallAdapter"><a href="#6-CallAdapter" class="headerlink" title="6. CallAdapter"></a>6. CallAdapter</h3><p>CallAdapter和Converter是Retrofit中最精妙的设计了，这就好比OkHttp中的责任链，所以，接下来分别看看这两个。</p><p>先看CallAdapter，那么它是在适配什么呢？顾名思义，请求适配器，在适配请求的返回值类型。先看下这两个请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Response&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>都是网络请求，但是返回类型不同，一个是Call，一个是Response，这两种形式Retrofit都是支持的，那么它是怎么做到的呢？没错，就是通过CallAdapter，每个返回类型，都有一个对应的CallAdapter，来将服务器返回的数据转换的成目标类型。目前支持的有Guava、Java8、RxJava，也可以自定义，在创建Retrofit实例时添加进去，即可。上面的例子中便是添加了一个RxJava的CallAdapter，可以直接将结果转换成Observers，可以方便的进行链式调用。</p><p>说完它的作用，那么就要看看Retrofit是如何实现的了。</p><p>我们写的是请求API接口，并没有具体的实现，调用Retrofit的create(Class)方法时，它实际上生成并返回了一个动态代理，我们调用API实例的方法时，真实调用的代理里的invoke方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">return</span> (T)</span><br><span class="line">      Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">          <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">              <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">              &#125;</span><br><span class="line">              args = args != <span class="keyword">null</span> ? args : emptyArgs;</span><br><span class="line">              <span class="keyword">return</span> platform.isDefaultMethod(method) ? platform.invokeDefaultMethod(method, service, proxy, args) : loadServiceMethod(method).invoke(args);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke方法很短，就这么几行，看过<code>platform.isDefaultMethod(method)</code>这个方法就知道，如果接口里的方法有默认实现，返回true，否则返回false，这是Java8才开始支持的，之前版本接口方法是不允许有方法体的。我们声明的API接口没有方法体，所有最终都会调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadServiceMethod(method).invoke(args)</span><br></pre></td></tr></table></figure><p>所以，只需要看这个方法是如何处理返回值，就知道Retrofit是怎么使用CallAdapter的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Retrofit将接口里的方法，抽象成了一个ServiceMethod类型，这里是做了一个缓存，为接口里的每个方法生成一个ServiceMethod实例，且只生成一个实例，节约资源提高性能。获取到ServiceMethod后，就会调用它的invoke方法，invoke是个抽象方法，它只有在HttpServiceMethod中有实现，而invoke中又调用了另一个抽象方法adopt，adapt里调用的是callAdapter的adapt方法。</p><p>总的来说就是，invoke方法调用的是callAdapter的adapt方法，而callAdapter是在构造函数的时候传进去的，意思就是说，在构造好ServiceMethod实例的时候，它所使用的CallAdapter就确定了。那么，看看在构造的时候如何选取的CallAdapter，看上面的代码就知道，ServiceMethod是通过静态方法parseAnnotations创建的，这个方法里又调用了HttpServiceMethod的parseAnnotations方法，也就是说，最终创建的ServiceMethod的是HttpServiceMethod的parseAnnotations方法。</p><p>来看HttpServiceMethod的parseAnnotations，这个方法中的CallAdapter，是通过这个方法创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">CallAdapter&lt;ResponseT, ReturnT&gt; <span class="title">createCallAdapter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Retrofit retrofit, Method method, Type returnType, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (CallAdapter&lt;ResponseT, ReturnT&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(method, e, <span class="string">&quot;Unable to create call adapter for %s&quot;</span>, returnType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是调用了retrofit的callAdapter方法，retrofit中最终创建CallAdapter的方法是这个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(</span><br><span class="line">    <span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">  <span class="keyword">int</span> start = callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到了吧，这里Retrofit就是在遍历自己的CallAdapterFactory，然后调用get方法，将返回值类型returnType和annotations传入，如果返回不为空，则返回。CallAdapterFactory的这个get方法的作用是，如果对应的CallAdapter能把数据转化成returnType类型，那么就生成出一个CallAdapter出来，如果不能则返回null，如果Retrofit中所带的CallAdapter没有一个符合条件的，那么就会来到最后一行，抛出一个Exception。</p><p>如果我们在创建Retrofit时，不手动添加CallAdapter，它也能用，是因为Retrofit里有个缺省的CallAdapter，叫DefaultCallAdapterFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  DefaultCallAdapterFactory(<span class="meta">@Nullable</span> Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Call return type must be parameterized as Call&lt;Foo&gt; or Call&lt;? extends Foo&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class) ? <span class="keyword">null</span> : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> responseType; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123; <span class="keyword">return</span> executor == <span class="keyword">null</span> ? call : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法里第一行是这么写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br></pre></td></tr></table></figure><p>意思就是，如果returnType不是Call，那么就返回null，换句话说，这个CallAdapter只能处理<code>Call&lt;T&gt;</code>类型的方法，也就是我们常写的那种，responseType是Call的范型T，方法最后直接new了一个CallAdapter返回了，在adapt方法中，因为Call就是最基本的形式，需要的也是Call类型，所以不需要额外的处理，就直接返回了，ExecutorCallbackCall是切换线程的，就不多说了。</p><p>总结一下就是，Retrofit里保存了自带的和我们手动添加的所有CallAdapterFactory，我们调用API实例的方法时，实际上是在调用动态代理的invoke方法，这方法里为每个API接口方法生成了一个ServiceMethod，在生成ServiceMethod时会从Retrofit的CallAdapterFactory中查找，看是否有CallAdapter可以将Call转换成目标类型，有则使用，无则抛异常。这样，在我们调用API实例的方法时，就可以得到结果了。</p><p>如果需要自定义CallAdapter，则需要实现CallAdapterFactory和CallAdapter。</p><h3 id="7-Converter"><a href="#7-Converter" class="headerlink" title="7. Converter"></a>7. Converter</h3><p>说完CallAdapter，再来看看Converter，说实话，我都有点敲累了，本着一鼓作气的精神，还是坚持敲完吧。</p><p>有了上面的经验，这个就容易一些了。同样，Retrofit中也是保存了所有的ConverterFactory，所有需要Converter的地方，都是从这里提供的。ConvertFactory是提供Converter的工厂，它里面主要有3个方法，也就是可以提供三个维度的Converter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Creates &#123;<span class="doctag">@link</span> Converter&#125; instances based on a type and target usage. */</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Converter&#125; for converting an HTTP response body to &#123;<span class="doctag">@code</span> type&#125;, or null if</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> type&#125; cannot be handled by this factory. This is used to create converters for</span></span><br><span class="line"><span class="comment">     * response types such as &#123;<span class="doctag">@code</span> SimpleResponse&#125; from a &#123;<span class="doctag">@code</span> Call&lt;SimpleResponse&gt;&#125;</span></span><br><span class="line"><span class="comment">     * declaration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(</span><br><span class="line">        Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Converter&#125; for converting &#123;<span class="doctag">@code</span> type&#125; to an HTTP request body, or null if</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> type&#125; cannot be handled by this factory. This is used to create converters for types</span></span><br><span class="line"><span class="comment">     * specified by &#123;<span class="doctag">@link</span> Body <span class="doctag">@Body</span>&#125;, &#123;<span class="doctag">@link</span> Part <span class="doctag">@Part</span>&#125;, and &#123;<span class="doctag">@link</span> PartMap <span class="doctag">@PartMap</span>&#125; values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(</span><br><span class="line">        Type type,</span><br><span class="line">        Annotation[] parameterAnnotations,</span><br><span class="line">        Annotation[] methodAnnotations,</span><br><span class="line">        Retrofit retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@link</span> Converter&#125; for converting &#123;<span class="doctag">@code</span> type&#125; to a &#123;<span class="doctag">@link</span> String&#125;, or null if</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> type&#125; cannot be handled by this factory. This is used to create converters for types</span></span><br><span class="line"><span class="comment">     * specified by &#123;<span class="doctag">@link</span> Field <span class="doctag">@Field</span>&#125;, &#123;<span class="doctag">@link</span> FieldMap <span class="doctag">@FieldMap</span>&#125; values, &#123;<span class="doctag">@link</span> Header <span class="doctag">@Header</span>&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> HeaderMap <span class="doctag">@HeaderMap</span>&#125;, &#123;<span class="doctag">@link</span> Path <span class="doctag">@Path</span>&#125;, &#123;<span class="doctag">@link</span> Query <span class="doctag">@Query</span>&#125;, and &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * QueryMap <span class="doctag">@QueryMap</span>&#125; values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;?, String&gt; stringConverter(</span><br><span class="line">        Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个维度分别是requestBodyConverter、responseBodyConverter和stringConverter。</p><p>下面我们来看看发起请求过程中的一些细节。</p><p>我们在声明请求时用注解标记了很多信息，比如请求Method，请求Path，这些最终都需要转换成网络请求认识的形式才可以，转化注解这件事，是在RequestFactory中做的，而RequestFactory是在ServiceMethod创建时一起创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceMethod.parseAnnotations(this, method);</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequestFactory通过静态方法创建了实例，在创建时，对所有注解进行了解析，在这个解析过程中，便是使用了Retrofit的ConverterFactory的stringConvterer和requestBodyConverter，解析参数时用stringConverter，解析RequestBody时用requestBodyConverter。</p><p>Converter的获取方式和CallAdapter类似，同样是传入一个类型，如果能转化，则返回一个Converter，不能就返回null，解析Body时，多是将起转化成JSON格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;T, RequestBody&gt; <span class="title">nextRequestBodyConverter</span><span class="params">(<span class="meta">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    Converter.Factory factory = converterFactories.get(i);</span><br><span class="line">    Converter&lt;?, RequestBody&gt; converter = factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="keyword">return</span> (Converter&lt;T, RequestBody&gt;) converter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成ServiceMethod后，便会调用其invoke方法，这个方法会将请求包装成一个叫做OkHttpCall的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServiceMethod.java</span></span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>将刚刚生成的requestFactory作为参数传了进去，同时还传入了responseConveter，用来解析服务器返回的数据，同样，responseConverter也是由Retrofit提供，如果有能处理type的Converter，则返回，无则返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(<span class="meta">@Nullable</span> Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">    Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看GsonConverterFactory的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GsonConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> Gson());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title">create</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gson == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;gson == null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonConverterFactory(gson);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">GsonConverterFactory</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.gson = gson;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonResponseBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">    TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GsonRequestBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它只重写了两个维度，requestBody和responseBody的Converter，GsonResponseBodyConverter的作用是把JSON串转化成对象，而GsonRequestBodyConverter的作用是把对象转化成JSON串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GsonRequestBodyConverter.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RequestBody <span class="title">convert</span><span class="params">(T value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line">    Writer writer = <span class="keyword">new</span> OutputStreamWriter(buffer.outputStream(), UTF_8);</span><br><span class="line">    JsonWriter jsonWriter = gson.newJsonWriter(writer);</span><br><span class="line">    adapter.write(jsonWriter, value);</span><br><span class="line">    jsonWriter.close();</span><br><span class="line">    <span class="keyword">return</span> RequestBody.create(MEDIA_TYPE, buffer.readByteString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GsonResponseBodyConverter.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    JsonReader jsonReader = gson.newJsonReader(value.charStream());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T result = adapter.read(jsonReader);</span><br><span class="line">      <span class="keyword">if</span> (jsonReader.peek() != JsonToken.END_DOCUMENT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JsonIOException(<span class="string">&quot;JSON document was not fully consumed.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      value.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>同样，若自定义Converter，实现Converter.Factory和Converter，即可。</p><h3 id="8-写在最后"><a href="#8-写在最后" class="headerlink" title="8. 写在最后"></a>8. 写在最后</h3><p>直观来看，依赖框架帮助我们省去了不少重复性的工作。但是，省去不等于是不做。从宏观角度来看，发送一个网络请求的需要做的事情有构建请求，连接服务器，发送请求，接收回应。这些必须的步骤，每次请求都是必不可缺的，这里的省去只是简化了我们的工作，但这些事并没有省去，只是这些依赖库在背后用复杂的逻辑默默的帮我们在做。从这个角度看，依赖库确实可以提升开发效率，但也不能过分依赖，框架背后的不少内容，还是需要我们熟知的，就像是网络请求，如果只知道通过这些框架发送请求、处理回应，那么在遇到一些涉及基础知识的问题时，可以就会有些不知所措。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上篇文章简单说了OkHttp的使用，这篇来说Retrofit。同样，Retrofit也是Square公司出品。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://oynix.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
    <category term="Retrofit" scheme="https://oynix.github.io/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp使用</title>
    <link href="https://oynix.github.io/2022/05/bd9c9a5395ee/"/>
    <id>https://oynix.github.io/2022/05/bd9c9a5395ee/</id>
    <published>2022-05-01T06:24:58.000Z</published>
    <updated>2022-05-01T09:48:33.866Z</updated>
    
    <content type="html"><![CDATA[<p>说到网络请求框架，OkHttp应该是当下较为流行的了，原因就在于它简单易用，且高效。同样，也是Square公司的作品。</p><span id="more"></span><h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NxdWFyZS9va2h0dHA=">库地址<i class="fa fa-external-link-alt"></i></span><br>添加依赖时，在app的build.gradle加一个库即可</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.squareup.okhttp3:okhttp:4.9.3&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>使用OkHttp发送网络请求，一般分为5个步骤</p><ul><li>生成OkHttpClient<br>Client可以配置一些和连接相关的参数，比如连接timeout、读timeout、写timeout、连接池的配置、添加拦截器，等等</li><li>生成Request<br>Request可以设定和请求相关的参数，如请求的URL、请求方式、请求头、请求的body</li><li>生成Call<br>一个Call，即为一个网络请求，这一步需要上面的Client和Request</li><li>发送Call<br>将请求发出，这里有两种方式，一种是同步发送，会阻塞线程，等待数据返回；另一种是异步发送，在回调里处理返回的数据</li><li>等待Call返回Response<br>Response即为服务器返回的数据，包含Header，和Body<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request requst = <span class="keyword">new</span> Request.Builder().url(<span class="string">&quot;&quot;</span>).get().build();</span><br><span class="line">Call call = client.newCall(request);</span><br><span class="line">Response response = call.execute(); <span class="comment">// 同步</span></span><br><span class="line">call.enqueue(callback); <span class="comment">// 异步</span></span><br><span class="line"></span><br><span class="line">String message = response.body().string();</span><br></pre></td></tr></table></figure>其中，Client也可以定制化，和Request类似，也是使用构建者模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                          .connectTimeout(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                          .readTimeout(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                          .writeTime(<span class="number">60</span>, TimeUnit.SECONDS)</span><br><span class="line">                          .connectionPool(<span class="keyword">new</span> ConnectionPool(<span class="number">30</span>, <span class="number">30</span>, TimeUnit.MINUTES))</span><br><span class="line">                          .build();</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-责任链"><a href="#3-责任链" class="headerlink" title="3. 责任链"></a>3. 责任链</h3><p>责任链是OkHttp中最巧妙的设计了。链上的每个元素，抽象成了一个拦截器Interceptor，每个拦截器都可以处理Request和Response。这种设计的好处就是，将处理者和请求者解耦，缺点就是，每次发起请求需要对链上的拦截者遍历，当拦截者过多时会影响性能。</p><p>什么意思呢，简单说就是，每次发起网络请求，Request会经过责任链上的每一个拦截器，最终到达服务器，同样，服务器返回的Response也会经过链上的每一个拦截器，最终回到请求者。比如，你想给每个请求都加上一个包含鉴权的Header，那么只需要向责任链中插入一个拦截器，这样就可以触碰到所有的Request和Response，不需要操作Response，而只需要向Resquest的Header中增加一对Key-Value即可，这种模式下，不需要关心谁发起的请求，也不需要关心谁将会处理请求，只需要插入一个拦截器Interceptor即可。</p><p>这里面有两个角色，一个是链，一个是拦截器。</p><p>先说拦截器。拦截器本身是拿不到任何东西的，它只有插入到责任链上之后，才能操作Request和Response，所以，它的Request是链提供给它的，同时，它还要返回一个Response，才能保证责任链能完整的流通，不然其中某个拦截器，在拿到Request后，不返回Response，那么，请求到这里就断掉了。一个链上可以有多个拦截器，Interceptor是个接口，其中只有一个interceptor方法，自定义的拦截器需要实现这个方法，Chain提供了多个方法，来提供和请求相关的参数，比如连接timeout、读写timeout，当然，还包括Request</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"><span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 通过request方法获得Request</span></span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        <span class="comment">// do something with request</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过proceed方法得到Resposne</span></span><br><span class="line">        Response response = chain.proceed(request);</span><br><span class="line">        <span class="comment">// do something with resposne</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终将response返回给链</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将拦截器插入到链中</span></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                          .addInterceptor(<span class="keyword">new</span> HeaderInterceptor())</span><br><span class="line">                          .build();</span><br></pre></td></tr></table></figure><p>看完拦截器，再来看看另外一个角色，链。Chain也是一个接口，它只有一个实现类，RealInterceptorChain，看看request方法是如何获取到Request，proceed方法又是如何获取到Response的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>request方法很简单，就是直接返回的成员变量request，而这个变量是在构造方法里面传入的，就没什么可多说的了。那就再看看proceed方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, <span class="meta">@Nullable</span> Exchange exchange)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">  calls++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.exchange.connection().supportsUrl(request.url())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;network interceptor &quot;</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">&quot; must retain the same host and port&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.exchange != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;network interceptor &quot;</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">        + <span class="string">&quot; must call proceed() exactly once&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">      index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">  Interceptor interceptor = interceptors.get(index);</span><br><span class="line">  Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class="line">  <span class="keyword">if</span> (exchange != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;network interceptor &quot;</span> + interceptor</span><br><span class="line">        + <span class="string">&quot; must call proceed() exactly once&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Confirm that the intercepted response isn&#x27;t null.</span></span><br><span class="line">  <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;interceptor &quot;</span> + interceptor + <span class="string">&quot; returned null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">&quot;interceptor &quot;</span> + interceptor + <span class="string">&quot; returned a response with no body&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面做了一些检查和判断，关键的就是中间的创建next变量。next的类型还是RealInterceptorChain，构造方法中第一个参数就是所有的拦截器，还有个index参数，表明这个next用的是第几个拦截器，换句话说就是，每个拦截器都对应一个RealInterceptorChain类型的变量。初始化next，又获取到了拦截器，通过interceptor.intercept(next)来获取response，来返回给上面的chain.proceed(request)。</p><p>可能有点乱，来捋一捋。一个拦截器想要获取Request很简单，Chain的构造方法里便有。一拦截器想要获取Response时，Chain就会获取到链中的下一个拦截器，通过调用它的intercept方法来获取Response，进入到下一个拦截器的intercept方法中时，它的Response又要通过Chain获取下下一个拦截器，跟它要Response。形象点来说就是，A想要操作Response，它就会带着Request和B要Response，B又会带着Request和C要Response，C又会和D要，就这么一直在链上传递下去。那么大家都这么踢皮球一样踢来踢去，真正的Response从何而来呢？从要有个兜底的吧？没错，真有一个兜底的，它就是链上的最后一个拦截器，CallServerInterceptor。</p><p>所以，还要再看看发送请求前，都给链上添加了那些拦截器。</p><p>上面说过，发送网路请求时，最终会生成一个Call，然后将其发出，而Call是一个接口，它只有一个实现类，叫做RealCall，不管是调用的Call的同步方法execute还是异步方法enqueue，最终都会来到RealCall里的getResponseWithInterceptorChain方法，完整内容如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response response = chain.proceed(originalRequest);</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">        closeQuietly(response);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，发送请求前，除了添加我们给Client添加的拦截器，OkHttp还添加了一些自己的拦截器，用来对Request和Response做一些处理。最后一个拦截器，便是CallServerInterceptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the last interceptor in the chain. It makes a network call to the server.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          <span class="comment">// 构建Request</span></span><br><span class="line">        <span class="comment">// 发送Request</span></span><br><span class="line">        <span class="comment">// 生成Response</span></span><br><span class="line">        <span class="comment">// 返回response</span></span><br><span class="line">        <span class="keyword">return</span> repsonse;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的类说明里，写的是链中的最后一个拦截器。所以她没办法再踢皮球，和别人要Response。它的intercept方法里，将上游传来的request发送出去，然后等服务器返回，将数据封装成Response，再度返回给链上游。</p><p>总结来看就是，每个拦截器中，想要操作Response，需要将自己处理过的Request传给链下游，下游接着往下传递，直到到达链末端的CallServerInterceptor，它向服务器发送请求，接收服务器的响应，然后再将Response回传给链上游，直到到达请求发送者，这个请求算作结束。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;说到网络请求框架，OkHttp应该是当下较为流行的了，原因就在于它简单易用，且高效。同样，也是Square公司的作品。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://oynix.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
    <category term="OkHttp" scheme="https://oynix.github.io/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin之属性代理</title>
    <link href="https://oynix.github.io/2022/05/540209f94fc3/"/>
    <id>https://oynix.github.io/2022/05/540209f94fc3/</id>
    <published>2022-04-30T16:07:08.000Z</published>
    <updated>2022-04-30T17:11:00.838Z</updated>
    
    <content type="html"><![CDATA[<p>属性代理是Kotlin独有的功能。</p><span id="more"></span><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>属性代理是借助Kotlin中代理设计模式，把这个模式应用于一个属性时，它可以将属性访问器的逻辑代理给一个对象。即，将setter和getter的实现，都交给一个对象来实现，这个对象需要实现getValue和setValue方法，既可以是普通方法，也可以是扩展方法。使用属性时，依然照常使用，只是访问器会调用扶助对象的setValue和getValue。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> NameDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;&#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KPproperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面便是属性代理的定义形式。另外，Kotlin还提供了几个常见的属性代理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Delegates.notNull()</span><br><span class="line">Delegates.observable()</span><br><span class="line">Delegates.vetoable()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-几个结构"><a href="#2-几个结构" class="headerlink" title="2. 几个结构"></a>2. 几个结构</h3><p>在介绍Kotlin提供的代理之前，先要说2个它的接口，很好理解</p><ul><li>ReadOnlyProperty，只读属性，只有getValue方法<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> ReadOnlyProperty<span class="type">&lt;in T, out V&gt;</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ReadWriteProperty，可读写属性，既有getValue方法，也有setValue方法<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteProperty</span>&lt;<span class="type">in T, V</span>&gt; : <span class="type">ReadOnlyProperty</span>&lt;<span class="type">T, V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">T</span>, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">V</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-Delegates-notNull"><a href="#3-Delegates-notNull" class="headerlink" title="3. Delegates.notNull()"></a>3. Delegates.notNull()</h3><p>notNull是一个方法，返回的就是一个带有getValue和setValue方法的对象，其中主要代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NotNullVar</span>&lt;<span class="type">T : Any</span>&gt;</span>() : ReadWriteProperty&lt;Any?, T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value: T? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> value ?: <span class="keyword">throw</span> IllegalStateException(<span class="string">&quot;Property <span class="subst">$&#123;property.name&#125;</span> should be initialized before get.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，NotNullVal实现了可读写属性的接口，setValue没有变，只是赋值给成员变量，而getValue加了空判断。在非空问题上，Kotlin还提供了一个lateinit关键字，但是这个关键字只能用来修饰引用类型的变量，而notNull适用于基础数据类型和引用类型。</p><h3 id="4-Delegates-observable"><a href="#4-Delegates-observable" class="headerlink" title="4. Delegates.observable()"></a>4. Delegates.observable()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableProperty</span>&lt;<span class="type">V</span>&gt;</span>(initialValue: V) : ReadWriteProperty&lt;Any?, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value = initialValue</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeChange</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;, oldValue: <span class="type">V</span>, newValue: <span class="type">V</span>)</span></span>: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterChange</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;, oldValue: <span class="type">V</span>, newValue: <span class="type">V</span>)</span></span>: <span class="built_in">Unit</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: V &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">V</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">        <span class="keyword">if</span> (!beforeChange(property, oldValue, value)) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">        afterChange(property, oldValue, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">observable</span><span class="params">(initialValue: <span class="type">T</span>, <span class="keyword">crossinline</span> onChange: (<span class="type">property</span>: <span class="type">KProperty</span>&lt;*&gt;, <span class="type">oldValue</span>: <span class="type">T</span>, <span class="type">newValue</span>: <span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>:</span><br><span class="line">        ReadWriteProperty&lt;Any?, T&gt; =</span><br><span class="line">    <span class="keyword">object</span> : ObservableProperty&lt;T&gt;(initialValue) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterChange</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;, oldValue: <span class="type">T</span>, newValue: <span class="type">T</span>)</span></span> = onChange(property, oldValue, newValue)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ObservableProperty，也是实现了可读写的接口，相比于可读写属性，多了两个方法，一个是beforeChange，一个是afterChange，若beforeChange返回值为false，那么此次set无效，返回true时方可生效，而afterChange则是在set成功后调用，beforeChange默认返回时true。</p><p>可以看到，observable提供了一个类型为ObservableProperty的对象，并重写了afterChange方法，交给了传入的onChange处理。也就是说，每次set完成后，都会调用传入onChange发出通知。</p><h3 id="5-Delegates-vetoable"><a href="#5-Delegates-vetoable" class="headerlink" title="5. Delegates.vetoable()"></a>5. Delegates.vetoable()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">vetoable</span><span class="params">(initialValue: <span class="type">T</span>, <span class="keyword">crossinline</span> onChange: (<span class="type">property</span>: <span class="type">KProperty</span>&lt;*&gt;, <span class="type">oldValue</span>: <span class="type">T</span>, <span class="type">newValue</span>: <span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>:</span><br><span class="line">          ReadWriteProperty&lt;Any?, T&gt; =</span><br><span class="line">      <span class="keyword">object</span> : ObservableProperty&lt;T&gt;(initialValue) &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeChange</span><span class="params">(property: <span class="type">KProperty</span>&lt;*&gt;, oldValue: <span class="type">T</span>, newValue: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> = onChange(property, oldValue, newValue)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>看过上看的说明，这个就很容易理解了，重写了beforeChange，用传入的函数的返回值来决定本次set是否生效。</p><h3 id="6-原理"><a href="#6-原理" class="headerlink" title="6. 原理"></a>6. 原理</h3><p>咋一看上去这种写法很高级，让咱们来编译成Java代码，看看这层层面纱之下，藏着的到底是什么。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String <span class="keyword">by</span> Delegates.notNull()</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> <span class="keyword">by</span> Delegates.notNull()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成java之后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">   <span class="comment">// $FF: synthetic field</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> KProperty[] $$delegatedProperties = <span class="keyword">new</span> KProperty[]&#123;(KProperty)Reflection.mutableProperty1(<span class="keyword">new</span> MutablePropertyReference1Impl(Reflection.getOrCreateKotlinClass(Teacher.class), <span class="string">&quot;name&quot;</span>, <span class="string">&quot;getName()Ljava/lang/String;&quot;</span>)), (KProperty)Reflection.mutableProperty1(<span class="keyword">new</span> MutablePropertyReference1Impl(Reflection.getOrCreateKotlinClass(Teacher.class), <span class="string">&quot;age&quot;</span>, <span class="string">&quot;getAge()I&quot;</span>))&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteProperty name$delegate;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteProperty age$delegate;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (String)<span class="keyword">this</span>.name$delegate.getValue(<span class="keyword">this</span>, $$delegatedProperties[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="meta">@NotNull</span> String var1)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(var1, <span class="string">&quot;&lt;set-?&gt;&quot;</span>);</span><br><span class="line">      <span class="keyword">this</span>.name$delegate.setValue(<span class="keyword">this</span>, $$delegatedProperties[<span class="number">0</span>], var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ((Number)<span class="keyword">this</span>.age$delegate.getValue(<span class="keyword">this</span>, $$delegatedProperties[<span class="number">1</span>])).intValue();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age$delegate.setValue(<span class="keyword">this</span>, $$delegatedProperties[<span class="number">1</span>], var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name$delegate = Delegates.INSTANCE.notNull();</span><br><span class="line">      <span class="keyword">this</span>.age$delegate = Delegates.INSTANCE.notNull();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析</p><ul><li>不管是代理的setValue还是getValue，其中都有一个KProperty类型的参数，所以每个属性都需要一个对应的KProperty对象</li><li>除了KProperty，每个属性，都需要一个代理对象，这里是ReadWriteProperty</li><li>每个属性，都有一个setter，和一个getter</li><li>setter中，调用代理对象的setValue方法</li><li>getter中，调用代理对象的getValue方法</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我的感觉，如果能直接以最终编译后Java代码来看属性代理，它反倒是增加了不少代码，如果需要什么额外的操作，完全可以直接写在属性的setter或者getter里。语法糖的好处就是，可以写一个notNull的类型，然后在所有不为空的地方使用，可以不用在每一个地方都加上判断代码，提升了效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;属性代理是Kotlin独有的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://oynix.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://oynix.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>LeakCanary分析</title>
    <link href="https://oynix.github.io/2022/04/3a7955f632aa/"/>
    <id>https://oynix.github.io/2022/04/3a7955f632aa/</id>
    <published>2022-04-30T15:14:18.000Z</published>
    <updated>2022-04-30T16:00:38.434Z</updated>
    
    <content type="html"><![CDATA[<p>LeakCanary主要用在Android中分析内存泄漏。何为内存泄漏？简单说便是，当一个对象所占用堆存储空间该被系统GC回收时，却由于种种原因没有被回收，那么这些内存就称为泄漏的内存。举个例子，退出一个Activity时，这时这个Activity该被回收，但是因为Activity内声明的Thread还在跑，Thread持有Activity的引用，导致Activity无法被回收，这时就造成了内存泄漏。</p><span id="more"></span><p>LeakCanary是Square公司出品，这是家做移动支付的公司，但对于开发者来说，这就是家开源库公司，因为不少当下较为流行的三方库，都是出自Square，比如OkHttp，Retrofit，Picasso，这几个较为常用。</p><h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1. 使用"></a>1. 使用</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NxdWFyZS9sZWFrY2FuYXJ5">Github库地址<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zcXVhcmUuZ2l0aHViLmlvL2xlYWtjYW5hcnkv">文档地址<i class="fa fa-external-link-alt"></i></span><br>接入十分简单，在build.gradle中，加入下面的依赖，即可<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">// debugImplementation because LeakCanary should only run in debug builds.</span></span><br><span class="line">  debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.9.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-工作步骤"><a href="#2-工作步骤" class="headerlink" title="2. 工作步骤"></a>2. 工作步骤</h3><p>当LeakCanary被安装后，它会自动检测，并报告应用中的内存泄漏，分为4个步骤：</p><ol><li>检测存活的对象</li><li>输出堆信息</li><li>分析堆信息</li><li>将泄漏分类</li></ol><h3 id="2-1-检测存活对象"><a href="#2-1-检测存活对象" class="headerlink" title="2.1 检测存活对象"></a>2.1 检测存活对象</h3><p>LeakCanary注册了Android生命周期的检测，会自动检测执行过onDestroy方法的Activity和Fragment，这些都应该被GC回收。ObjectWatcher会持有这些对象的弱引用，LeakCanary会检测下面这些对象</p><ul><li>被销毁的Activity实例</li><li>被销毁的Fragment实例</li><li>被销毁的Fragment View实例</li><li>被清理的ViewModel实例<br>如果被ObjectWatcher持有的对象，在5秒后依然没有被清理，那么就会执行GC，之后，若被持有object依然存在没有被回收，那么就有可能泄漏了。</li></ul><h3 id="2-2-输出堆信息"><a href="#2-2-输出堆信息" class="headerlink" title="2.2 输出堆信息"></a>2.2 输出堆信息</h3><p>当存活的对象到达阈值的时候，LeakCanary就会将Java堆信息输出到一个.hprof文件中，这个操作可能会卡住应用一小段时间，会有Toast给出提示。</p><h3 id="2-3-分析堆信息"><a href="#2-3-分析堆信息" class="headerlink" title="2.3 分析堆信息"></a>2.3 分析堆信息</h3><blockquote><p>Shark: Smart Heap Analytisis Reports for Kotlin，是一个分析堆信息的工具<br>LeakCanary使用Shark来分析hprof文件，并定位存活对象在堆信息中的位置。对于每一个存活的对象，LeakCanary都会找到阻止这个对象被系统GC回收的引用路径。当分析完成时，会有一个包含汇总信息的通知提示，点开便可查看详细信息。</p></blockquote><h3 id="2-4-泄漏分类"><a href="#2-4-泄漏分类" class="headerlink" title="2.4 泄漏分类"></a>2.4 泄漏分类</h3><p>LeakCanary将她从应用中发现的泄漏分为两类，一类是应用自身的泄漏，一类是依赖库的泄漏。依赖库泄漏是三方库中已知的bug导致，我们无法控制。这个泄漏对我们应用产生了影响，但不幸的是，我们无法修复。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>LeakCanary关键部分，就是如何检测泄漏对象：通过注册回调监听Activity和Fragment的生命周期，在其destroy之后，创建WeakReference，然后就是等待5秒，理想状态下这个时间内会被GC回收，如果5秒还存活，那么就手动调用GC，依然存活的就考虑是泄漏了，最后就是分析堆、查引用路径。下面这个文章对里面的代码做了分析，但是版本不是最新，和最新的可能会有一些出入，但大体逻辑是一样的。</p><p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNjk5NjIw">全解系列：内存泄漏定位工具LeakCanary<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeakCanary主要用在Android中分析内存泄漏。何为内存泄漏？简单说便是，当一个对象所占用堆存储空间该被系统GC回收时，却由于种种原因没有被回收，那么这些内存就称为泄漏的内存。举个例子，退出一个Activity时，这时这个Activity该被回收，但是因为Activity内声明的Thread还在跑，Thread持有Activity的引用，导致Activity无法被回收，这时就造成了内存泄漏。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
    <category term="LeakCanary" scheme="https://oynix.github.io/tags/LeakCanary/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令--tee</title>
    <link href="https://oynix.github.io/2022/04/90cf3f57d0c0/"/>
    <id>https://oynix.github.io/2022/04/90cf3f57d0c0/</id>
    <published>2022-04-30T08:43:32.000Z</published>
    <updated>2022-04-30T09:07:25.205Z</updated>
    
    <content type="html"><![CDATA[<p>tee，这个单词没有什么实际性的含义，就是T型管道的意思，在<code>--</code>的基础上，变成<code>T</code>型，这样就多了一个输出。所以，这个命令的作用就是，在不改变输出原有行为的基础上，将其额外的导向文件中。</p><span id="more"></span><h3 id="1-举例"><a href="#1-举例" class="headerlink" title="1. 举例"></a>1. 举例</h3><p>比如想要ping一个地址，下面这样操作只是在标准输出显示了出来，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping baidu.com</span></span><br><span class="line">PING baidu.com (220.181.38.148): 56 data bytes</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=0 ttl=53 time=37.463 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=1 ttl=53 time=36.565 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=2 ttl=53 time=35.840 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=3 ttl=53 time=36.733 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=4 ttl=53 time=36.475 ms</span><br></pre></td></tr></table></figure><p>这个时候，加上tee命令，原有的输出没有发生改变，但同时将输出也写到了文件output.txt中，这就是tee命令的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping baidu.com | tee output.txt</span></span><br><span class="line">PING baidu.com (220.181.38.148): 56 data bytes</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=0 ttl=53 time=42.524 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=1 ttl=53 time=39.871 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=2 ttl=53 time=41.977 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=3 ttl=53 time=38.483 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=4 ttl=53 time=43.906 ms</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat output.txt</span></span><br><span class="line">PING baidu.com (220.181.38.148): 56 data bytes</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=0 ttl=53 time=42.524 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=1 ttl=53 time=39.871 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=2 ttl=53 time=41.977 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=3 ttl=53 time=38.483 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=4 ttl=53 time=43.906 ms</span><br></pre></td></tr></table></figure><h3 id="2-参数"><a href="#2-参数" class="headerlink" title="2. 参数"></a>2. 参数</h3><p>tee命令默认是覆盖的形式写入到文件，当执行两次时，第二次的输出就会覆盖第一次的输出，是用a，append参数，可以以追加的形式写入到文件。此外，还有i，ignore参数，用来忽略中断命令，同时，tee支持多个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping baidu.com | tee -a output1.txt output2.txt output3.txt</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;tee，这个单词没有什么实际性的含义，就是T型管道的意思，在&lt;code&gt;--&lt;/code&gt;的基础上，变成&lt;code&gt;T&lt;/code&gt;型，这样就多了一个输出。所以，这个命令的作用就是，在不改变输出原有行为的基础上，将其额外的导向文件中。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://oynix.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://oynix.github.io/tags/Linux/"/>
    
    <category term="tee" scheme="https://oynix.github.io/tags/tee/"/>
    
  </entry>
  
  <entry>
    <title>Android WebView使用</title>
    <link href="https://oynix.github.io/2022/04/dd3a16ba32a7/"/>
    <id>https://oynix.github.io/2022/04/dd3a16ba32a7/</id>
    <published>2022-04-28T03:45:06.000Z</published>
    <updated>2022-04-29T03:57:20.362Z</updated>
    
    <content type="html"><![CDATA[<p>当需要打开一个URL时，常规操作是用系统浏览器打开，很方便、便捷，不足之处就是只能显示，无法交互。使用SDK提供的WebView可以解决这一点，自然也需要多做一些额外的工作。</p><span id="more"></span><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>简单说，WebView就是一个具备基础功能浏览器，不想市面上的浏览器那样，加入了各种定制化功能。其内部基于webkit引擎，低版本和高版本采用了不同的webkit版本内核，4.4后使用了Chrome内核。而webkit又是什么呢？它是一个开源的web浏览器引擎，即浏览器内核。当我们请求一个URL后，服务器返回来的是一个个文件，如html，css，等，浏览器的工作，就是把这些文件渲染成易读的形式展现给我们，不同的形式、不同的颜色、不同的交互，等。关于简介，就说这么多。</p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><ul><li>创建<br>作为一个控件，和其他控件一样，可以在布局文件中声明，后在使用时代码中获取。也可以在代码中直接创建，然后添加到布局中</li><li>基本方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步页面状态到webview，使其可以正常响应，同时在不需要的时候暂停一些动作节省系统资源，如DOM解析，JS执行等</span></span><br><span class="line">webView.onResume();</span><br><span class="line">webView.onPause();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂停webview的layout，parsing，jstimer</span></span><br><span class="line"><span class="comment">// 这是针对全局的，而不单单是当前的webview</span></span><br><span class="line">webView.pauseTimers();</span><br><span class="line">webView.resumeTimers();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免webview在销毁时还在加载导致泄漏，如音乐或视频，所以先将其移出，再执行销毁</span></span><br><span class="line">rootLayout.removeView(webView);</span><br><span class="line">webView.destroy();</span><br></pre></td></tr></table></figure></li><li>前进后退<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webView.canGoBakc();</span><br><span class="line">webView.goBack();</span><br><span class="line">webView.canGoForward();</span><br><span class="line">webView.goForward();</span><br><span class="line"><span class="comment">// 负数后退，正数则前进</span></span><br><span class="line">webView.goBackOrForwardd(<span class="keyword">int</span> steps);</span><br></pre></td></tr></table></figure>按下返回键时，Activity会先消费掉此事件，而退出页面，若想按下返回执行webView的后退操作，则需要传递事件给WebView<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">webView.goBack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>清除<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内核缓存是全局的，所以该操作针对的是全局应用</span></span><br><span class="line">webView.clearCache(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问记录</span></span><br><span class="line">webView.clearHistory();</span><br><span class="line"></span><br><span class="line">webView.clearFormData();</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-常用类之WebSettings"><a href="#3-常用类之WebSettings" class="headerlink" title="3. 常用类之WebSettings"></a>3. 常用类之WebSettings</h3><p>用来配置一些和webkit内核相关的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">WebSettings settings = webView.getSettings();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JS</span></span><br><span class="line">settings.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 插件</span></span><br><span class="line">settings.setPluginsEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 自适应屏幕，二者合用</span></span><br><span class="line">settings.setUseViewPort(<span class="keyword">true</span>); <span class="comment">// 将图片调整到适合webview大小</span></span><br><span class="line">settings.setLoadWithOverviewMode(<span class="keyword">true</span>); <span class="comment">// 缩放至屏幕大小</span></span><br><span class="line"><span class="comment">// 缩放</span></span><br><span class="line">settings.setSupportZoom(<span class="keyword">true</span>); <span class="comment">// 打开缩放</span></span><br><span class="line">settings.setBuiltInZoomControls(<span class="keyword">true</span>); <span class="comment">// 内置缩放控件</span></span><br><span class="line">settings.setDisplayZoomControls(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">settings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); <span class="comment">// 缓存模式</span></span><br><span class="line">settings.setAllowFileAccess(<span class="keyword">true</span>); <span class="comment">// 访问文件</span></span><br><span class="line">settings.setJavaScriptCanOpenWindowsAutomatically(<span class="keyword">true</span>);</span><br><span class="line">settings.setLoadsImagesAutomatically(<span class="keyword">true</span>);</span><br><span class="line">settings.setDefaultTextEncodingName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存模式</span></span><br><span class="line">LOAD_CACHE_ONLY： 只使用缓存</span><br><span class="line">LOAD_DEFAULT：根据cache-control决定是否使用缓存</span><br><span class="line">LOAD_NO_CACHE：不用缓存</span><br><span class="line">LOAD_CACHE_ELSE_NETWORK: 只要本地有，不论过期与否，或者设置了no-cache，都使用缓存中数据</span><br></pre></td></tr></table></figure><h3 id="4-常用类之WebViewClient"><a href="#4-常用类之WebViewClient" class="headerlink" title="4. 常用类之WebViewClient"></a>4. 常用类之WebViewClient</h3><p>主要用来设定WebView的通知、请求事件，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onLoadResource</span><br><span class="line">onPageStart</span><br><span class="line">onPageFinish</span><br><span class="line">onReceiveError</span><br><span class="line">onReceivedHttpAuthRequest</span><br><span class="line">onReceivedSslError WebView默认是不处理https请求的，页面显示空白，需手动处理</span><br></pre></td></tr></table></figure><h3 id="5-常用类之WebChromeClient"><a href="#5-常用类之WebChromeClient" class="headerlink" title="5. 常用类之WebChromeClient"></a>5. 常用类之WebChromeClient</h3><p>主要用来辅助WebView处理对话框、网站图标、标题，加载进度等，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">onCloseWindow</span></span><br><span class="line"><span class="function">onCreateWindow</span></span><br><span class="line"><span class="function"><span class="title">onJsAlert</span><span class="params">(WebView上alert无效，需要在此处理)</span></span></span><br><span class="line"><span class="function">onJsPrompt</span></span><br><span class="line"><span class="function">onJsConfirm</span></span><br><span class="line"><span class="function">onProgressChanged</span></span><br><span class="line"><span class="function">onReceivedIcon</span></span><br><span class="line"><span class="function">onReceivedTitle</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;当需要打开一个URL时，常规操作是用系统浏览器打开，很方便、便捷，不足之处就是只能显示，无法交互。使用SDK提供的WebView可以解决这一点，自然也需要多做一些额外的工作。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://oynix.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
    <category term="WebView" scheme="https://oynix.github.io/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceView的使用</title>
    <link href="https://oynix.github.io/2022/04/324133c11cf5/"/>
    <id>https://oynix.github.io/2022/04/324133c11cf5/</id>
    <published>2022-04-27T13:33:45.000Z</published>
    <updated>2022-04-27T14:35:35.791Z</updated>
    
    <content type="html"><![CDATA[<p>我们在View中绘制的内容，是由系统绘制的，每隔16ms，系统发出一次VSYNC信号，重新绘制屏幕，这个操作在主线程，所以如果我们在两次绘制之间做的操作耗时超过16ms，页面就会出现卡顿。而SurfaceView则是由我们主动绘制，在子线程，不会卡主线程，同时，SurfaceView实现了双缓存机制。</p><span id="more"></span><p>摘抄一段关于双缓存的介绍</p><blockquote><p>双缓冲技术是游戏开发中的一个重要的技术。当一个动画争先显示时，程序又在改变它，前面还没有显示完，程序又请求重新绘制，这样屏幕就会不停地闪烁。而双缓冲技术是把要处理的图片在内存中处理好之后，再将其显示在屏幕上。双缓冲主要是为了解决 反复局部刷屏带来的闪烁。把要画的东西先画到一个内存区域里，然后整体的一次性画出来。</p></blockquote><h3 id="1-SurfaceHolder"><a href="#1-SurfaceHolder" class="headerlink" title="1. SurfaceHolder"></a>1. SurfaceHolder</h3><p>SurfaceHolder是一个接口，里面定义了使用SurfaceView的相关方法接口。比如，添加Surface状态改变时的回掉、获取画布，等。SurfaceView中维护了一个该类型的变量，我们的操作都是通过这个叫做holder的变量。</p><h3 id="2-SurfaceHolder-Callback"><a href="#2-SurfaceHolder-Callback" class="headerlink" title="2. SurfaceHolder.Callback"></a>2. SurfaceHolder.Callback</h3><p>因为SurfaceView是我们主动绘制的，所以我们就需要知道其状态，以确保在绘制的时候它是存在且可用的，通过添加此Callback来接收Surface状态发生改变时的回调。Surface有两种状态，即，已创建和已销毁。</p><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerSurfaceView</span> : <span class="type">SurfaceView</span>, <span class="type">SurfaceHolder.Callback</span>, <span class="type">Runnable &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context) : <span class="keyword">super</span>(ctx)</span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx, attrs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        holder.addCallback(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> running = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> thread: Thread? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> nextDraw = <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> engine: GameEngine = GameEngine(context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">surfaceCreated</span><span class="params">(holder: <span class="type">SurfaceHolder</span>)</span></span> &#123;</span><br><span class="line">        engine.begin()</span><br><span class="line">        running = <span class="literal">true</span></span><br><span class="line">        thread = Thread(<span class="keyword">this</span>)</span><br><span class="line">        thread?.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">surfaceChanged</span><span class="params">(holder: <span class="type">SurfaceHolder</span>, format: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">surfaceDestroyed</span><span class="params">(holder: <span class="type">SurfaceHolder</span>)</span></span> &#123;</span><br><span class="line">        running = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (thread == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">        synchronized(holder) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> t = thread!!</span><br><span class="line">                    t.join(<span class="number">3000</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;==&quot;</span>, e.toString())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        thread = <span class="literal">null</span></span><br><span class="line">        engine.end()</span><br><span class="line">        holder.surface.release()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; nextDraw) &#123;</span><br><span class="line">                Thread.yield()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!running) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">            synchronized(holder) &#123;</span><br><span class="line">                <span class="keyword">val</span> canvas = holder.lockCanvas()</span><br><span class="line">                <span class="keyword">if</span> (canvas != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        engine.draw(canvas)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                        Log.e(<span class="string">&quot;==&quot;</span>, e.toString())</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            holder.unlockCanvasAndPost(canvas)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                            Log.e(<span class="string">&quot;==&quot;</span>, e.toString())</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nextDraw = start + CraftEngine.FRAME_INTERVAL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="meta-string">&quot;ClickableViewAccessibility&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gestureDetector.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gestureDetector = GestureDetector(context, <span class="keyword">object</span> :</span><br><span class="line">        GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> downEvent: MotionEvent</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDown</span><span class="params">(e: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            downEvent = e</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            e1: <span class="type">MotionEvent</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            e2: <span class="type">MotionEvent</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">            distanceX: <span class="type">Float</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            distanceY: <span class="type">Float</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            engine.onTouchMove(distanceX, distanceY)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我用它写了一个飞机大战的游戏，创建一个类继承SurfaceView，为了监听它的状态，直接用它实现了Callback，然后在类初始化里，通过holder添加了监听，在回调方法里就可以处理相关的逻辑。</p><p>简单说就是，在创建后，启动一个子线程绘制，绘制的画布通过holder锁定获取，绘制完成后需要解锁，在销毁后，将绘制线程停止，节省资源。</p><p>这个类里面主要负责处理Surface状态改变，并处理绘制线程，至于具体的游戏逻辑，我都放到了GameEngine里，这里面处理飞机的生成、移动、攻击、碰撞，等。</p><p>实时绘制自然视觉效果最好，但由于肉眼的生理限制，当两帧之间的间隔不超过16ms，肉眼就感觉不到卡顿，这样看来1ms就绘制一次，或者5ms就绘制一次就没有必要了，浪费资源，所以，还需要控制一下绘制间隔，控制在16ms即可。</p><p>这里有个小坑，开始我的设计是，每次绘制直接交给engine处理，包括帧距控制，SurfaceView里的while循环里只调用了一个engine的draw方法，但是，这种写法，在我的测试机上切换页面之后，Surface的销毁回调就会出问题，要么是不回调，要么就是等一会才会回调。四处查了一些资料，折腾了好久，但也没找到有效的解决方法，最后偶然一试，发现把帧距控制放到SurfaceView里，也就是在while循环里做点事，也就是像上面那些写，甚至只是在里面打行log，问题就莫名其妙的不在了。我想这里面一定还有着什么我所不知道的小秘密，暂时也不管它了，又不是不能用。</p><p>需要注意的是，holder每次拿到的画布，都是上一次绘制完的画布，需要手动处理脏区域。拿我做的飞机来说，如果每次只管把飞机绘制到最新位置，那么屏幕上就会出现一串飞机拉线，等同于，每次绘制时拿到的纸，就是上次交出去的纸，所以需要先把上个位置的飞机擦掉，然后再在最新的位置上画上飞机。当然，最简单的办法就是每次都绘制一遍背景图，用背景图盖住上次的内容。另外，为了进一步提高性能，可以不用每次都绘制整张画布，而是选择只绘制需要绘制的区域，lockCanvas有个重载方法，传入一个需要绘制的区域，就可以获取到对应的画布。</p><p>此外，我还加了一个GestureDetector，玩游戏难免需要有用户操作输入，通过GestureDetector可以最简单的获取到用的操作。</p><p>线程等待这里用的是Thread的yield方法，而不是sleep方法，这二者的区别是，sleep方法会一直占用线程，让卡在这里等着，而yield，顾名思义，大喊一声，你们谁要用就拿去用，我现在还不用，然后释放掉CPU时间片，将自己变成就绪状态。而CPU在被释放掉之后，会再次从当前所有处于就绪状态的线程中，选一个执行，所以这个时候，有可能还会选中刚刚yield的线程。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在View中绘制的内容，是由系统绘制的，每隔16ms，系统发出一次VSYNC信号，重新绘制屏幕，这个操作在主线程，所以如果我们在两次绘制之间做的操作耗时超过16ms，页面就会出现卡顿。而SurfaceView则是由我们主动绘制，在子线程，不会卡主线程，同时，SurfaceView实现了双缓存机制。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://oynix.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
    <category term="SurfaceView" scheme="https://oynix.github.io/tags/SurfaceView/"/>
    
  </entry>
  
  <entry>
    <title>shell字符串操作</title>
    <link href="https://oynix.github.io/2022/04/753a8bfe877f/"/>
    <id>https://oynix.github.io/2022/04/753a8bfe877f/</id>
    <published>2022-04-25T14:11:54.000Z</published>
    <updated>2022-04-25T14:51:52.394Z</updated>
    
    <content type="html"><![CDATA[<p>除了sed、awk等命令，shell也内置了一些字符串的操作，可以满足大部分需求，且速度会更快些，省去了调用命令的时间。</p><span id="more"></span><h3 id="1-字符串读值"><a href="#1-字符串读值" class="headerlink" title="1. 字符串读值"></a>1. 字符串读值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- $&#123;var&#125;: 取值</span><br><span class="line">- $&#123;var-DEFAULT&#125;: 如果var没有被声明，那么就以DEFAULT作为其值</span><br><span class="line">- $&#123;var:-DEFAULT&#125;: 没被声明或为空，则以DEFAULT作为其值</span><br><span class="line">- $&#123;var=DEFAULT&#125;: 如果var没有被声明，那么就以DEFAULT作为其值</span><br><span class="line">- $&#123;var:=DEFAULT&#125;: 没被声明或为空，则以DEFAULT作为其值</span><br><span class="line">- $&#123;var+OTHER&#125;: 如果var声明了，那么其值就是$OTHER，否则就为null字符串</span><br><span class="line">- $&#123;var:+OTHER&#125;: 同上</span><br><span class="line">- $&#123;var?ERR_MSG&#125;: 如果var没有被声明，则打印ERR_MSG</span><br><span class="line">- $&#123;var:?ERR_MSG&#125;: 同上</span><br><span class="line">- $&#123;!varprefix*&#125;: 匹配之前所有以prefix开头的变量名称</span><br><span class="line">- $&#123;!varprefix@&#125;: 同上</span><br></pre></td></tr></table></figure><h3 id="2-字符串操作"><a href="#2-字符串操作" class="headerlink" title="2. 字符串操作"></a>2. 字符串操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- $&#123;#string&#125;: 长度</span><br><span class="line">- $&#123;string:position&#125;: 从position角标开始提取自字符串，角标从0开始</span><br><span class="line">- $&#123;string:position:length&#125;: 同上，同时限定长度</span><br><span class="line">- $&#123;string:0-position:length&#125;: 同上，从右边开始数，从1开始，最右字符是1</span><br><span class="line">- $&#123;string#*substring&#125;: 截取，保留substring右边字符，不包含substring，遇到第一个substring就截取</span><br><span class="line">- $&#123;string##*substring&#125;: 同上，遇到最后一个substring再截取，常用于URL，星号可通配任意个字符</span><br><span class="line">- $&#123;string%substring*&#125;: 从右侧开始截取，保留substring左侧字符，不包含substring，遇到第一个就截取</span><br><span class="line">- $&#123;string%%substring*&#125;: 同上，遇到最后一个再截取</span><br><span class="line">- $&#123;string/substring/replacement&#125;: 用replacement替换第一个substring</span><br><span class="line">- $&#123;string//substring/replacement&#125;: 同上，替换所有</span><br><span class="line">- $&#123;string/#substring/replacement&#125;: 如果string的前缀匹配substring，则用replacement替换substring</span><br><span class="line">- $&#123;string/%substing/replacement&#125;: 同上，换成后缀</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;除了sed、awk等命令，shell也内置了一些字符串的操作，可以满足大部分需求，且速度会更快些，省去了调用命令的时间。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://oynix.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://oynix.github.io/tags/Linux/"/>
    
    <category term="shell" scheme="https://oynix.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>vim常用命令</title>
    <link href="https://oynix.github.io/2022/04/46f76ab08387/"/>
    <id>https://oynix.github.io/2022/04/46f76ab08387/</id>
    <published>2022-04-23T14:45:47.000Z</published>
    <updated>2022-05-05T09:37:55.316Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux上查看、编辑文件时，vim就必不可少了。有句话不是说，高手，尤其是真正的高手，都是不需要鼠标的，所有操作都通过键盘完成。vim强大之处在于，它支持的功能和操作很多很多，但其实很多命令都是互补的，所以就不必记住每个命令，列一下常用的必要命令。</p><span id="more"></span><p>命令按类型分为几大类，移动、插入、查找替换、复制粘贴、删除和撤销重做、命令</p><h3 id="1-移动"><a href="#1-移动" class="headerlink" title="1. 移动"></a>1. 移动</h3><ul><li>hjkl：j是下，k是上，hl是左和右，和玩游戏时移动规则一样</li><li>w和e：向后移动一个单词，w停在首，e停在尾，这和它俩在键盘上的位置一样</li><li>b和ge：和上面相反，是往前挪</li><li>0 ^ $: 0到开头，^到非空白字符，$行尾字符</li><li>gg和G：文件头和文件尾</li><li>zz: 将当前行移动到屏幕中央 zt，top zb，bottom</li></ul><h3 id="2-插入"><a href="#2-插入" class="headerlink" title="2. 插入"></a>2. 插入</h3><ul><li>a: append 当前字符后</li><li>i: insert 当前字符位置</li><li>I和A：行首和行尾插入</li><li>o和O：下一行，上一行</li></ul><h3 id="3-查找替换"><a href="#3-查找替换" class="headerlink" title="3. 查找替换"></a>3. 查找替换</h3><ul><li>/text：查找，n下一个，N上一个</li><li>?text：反向查找，用上面那个就可以了</li><li>r和R：替换一个字符，和多个字符</li><li>:s/old/new/g 不加g替换第一个匹配，加g替换当前行所有匹配</li><li>:%s/old/new/g 不加g替换所有行第一个匹配，加g替换所有行所有匹配</li><li>:10,20s/old/new/ 把%换成了指定的行</li></ul><h3 id="4-复制粘贴"><a href="#4-复制粘贴" class="headerlink" title="4. 复制粘贴"></a>4. 复制粘贴</h3><ul><li>v和V：选中字符和选中行</li><li>y：复制选中内容 yy复制当前行</li><li>p：在当前位置粘贴</li></ul><h3 id="5-删除-撤销-重做"><a href="#5-删除-撤销-重做" class="headerlink" title="5. 删除 撤销 重做"></a>5. 删除 撤销 重做</h3><ul><li>d：删除，也是剪切，它需要指定删除范围，dd=当前行 dh=左侧字符 dl=自己 dk=自己行和上行 dj=自己行和下行 dd=自己行 dgg=自己行到首行 dG=自己行到尾行 d^=前面的 d$=自己和后面的 D=d$ :1,10d=1到10行 :11,$d=11到最后行</li><li>u和U，撤销上个操作和撤销整行的修改</li><li>ctrl+r：重做，也就是恢复，撤销撤销</li></ul><h3 id="6-命令"><a href="#6-命令" class="headerlink" title="6. 命令"></a>6. 命令</h3><ul><li>:set number 行号</li><li>:set nonunber 关行号</li><li>:w 保存</li><li>:q 退出</li><li>:!command shell命令</li><li>:q! 强行退出 不保存</li><li>ctrl + u d：滚动页面 up down</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Linux上查看、编辑文件时，vim就必不可少了。有句话不是说，高手，尤其是真正的高手，都是不需要鼠标的，所有操作都通过键盘完成。vim强大之处在于，它支持的功能和操作很多很多，但其实很多命令都是互补的，所以就不必记住每个命令，列一下常用的必要命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://oynix.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://oynix.github.io/tags/Linux/"/>
    
    <category term="Vim" scheme="https://oynix.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Android之从桌面启动应用全过程</title>
    <link href="https://oynix.github.io/2022/04/fc395161d946/"/>
    <id>https://oynix.github.io/2022/04/fc395161d946/</id>
    <published>2022-04-22T13:02:44.000Z</published>
    <updated>2022-04-23T14:38:04.504Z</updated>
    
    <content type="html"><![CDATA[<p>这篇来学习一下从按下桌面应用图标、到应用完成启动，运行至前台，这个过程中系统都做了哪些事。</p><span id="more"></span><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>为了搞明白，网上的文章没少看，书也翻了不少，这些内容的相同点是，写的都很多，过程可谓相当之繁琐。不同点是，各说各的，没有哪两个人说的是一样的，这个人说这里是这样的，那个人又说这里是这样的，众说纷纭，搞得我这种站在中间本想来学知识，倒成了看热闹的，真想介绍他们互相认识，然后再看着他们讨论。也有可能是版本的原因吧，年代久远带着丝丝尘土味道的文章必然看的是老版本，而越热乎冒着热气的文章定是接近新的系统版本。我已经不想再花更多的时间来验证每篇文章，看看到底哪里对哪里不对，干脆就自己来，自己动手，丰衣足食。</p><p>重要的不是版本，而是学习方法，系统版本在不断的升级换代，死记代码实为下下策，只有掌握了学习源码的方法，才是以不变应万变的良策。</p><p>以下的方式很简单，别光看，东西很多，记不住的，跟着一起做，习得方法方为本源呐。</p><h3 id="2-版本"><a href="#2-版本" class="headerlink" title="2. 版本"></a>2. 版本</h3><p>我用的SDK 30，在AndroidStudio/Preferences/Android SDK里，下载一下源码，或者用sdkmanager也可以，然后就可以看到源码了，具体路径在这</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Android/sdk/sources/android-30</span><br></pre></td></tr></table></figure><h3 id="3-如何搜索源码"><a href="#3-如何搜索源码" class="headerlink" title="3. 如何搜索源码"></a>3. 如何搜索源码</h3><p>在AndroidStudio中，双击Shift，多数文件，都可以在这里面通过文件名搜到。能搜到是能搜到，但也只是能搜到而已，里面的引用关系却不都是可以关联，到处都是被<code>@Hide</code>、<code>@NotsupportedAppUsage</code>等注解修饰的，所以任意打开个文件，满篇的红色报错所烘托出的喜庆氛围，时时刻刻让你有种在过年的错觉。所以，对于那些找不到的方法，找不到的类型，就只能手动去搜索，看看它到底是啥，看看这方法里面到底干了点啥。</p><ul><li>搜索文件，一种是在Android Studio里按文件名搜索，另一种是在shell里搜索，是用find命令，其中FileName可以用<code>*</code>占位<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到源码路径下</span></span><br><span class="line">cd ~/Library/Android/sdk/sources/android-30</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> find，查找当前目录下，以及所有子目录下，所有文件名符合条件的文件</span></span><br><span class="line">find . -name &quot;FileName&quot;</span><br></pre></td></tr></table></figure></li><li>搜索方法，如果知道在哪个文件，那就直接用Android Studio里的搜索功能，在哪嗖的一下就搜出来了。但是，有时方法属于某个内部类的，所以文件的名字就不是类的名字，这样就搜不到文件，这个时候就直接用grep命令，在大杀器面前，没有什么可以藏起来。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Library/Android/sdk/sources/android-30</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> r:recursive 查找当前目录，及其所有子目录下的所有文件中，包含关键字的行，支持占位符，支持正则，搜索神器</span></span><br><span class="line">grep -r &quot;keyWord&quot; .</span><br></pre></td></tr></table></figure></li></ul><p>以上这些，是帮助学习过程能顺利向前推进的方式，有了动力，下面就说方向。</p><h3 id="4-Launcher"><a href="#4-Launcher" class="headerlink" title="4. Launcher"></a>4. Launcher</h3><p>首先明确的是，桌面Launcher也是应用，是一个有些特殊的应用，它在系统启动过程中启动的，Android系统启动流程之前简单写过，<a href="https://oynix.github.io/2022/01/f6c3174008b0/">点进去可以再看一遍</a>。桌面上看到的应用图标，点击之后的打开，长按之后的小浮窗，图标分组管理，拖拽调整位置，卸载时的动画，等等，这些都是Launcher的功能，各大厂商就是修改了Launcher里面的代码后，实现了自己独特风格的桌面。抛开其他的不谈，这里只看点击Launcher上的应用图标后，到应用完全打开，这其中的全过程。</p><p>我们上面刚刚下载的，是SDK的源码，这些SDK是供我们在开发APP过程调用的，而Launcher本身就是个APP，是系统自带的APP，它不属于SDK的源码，所以不管用哪种方式，在刚下载的源码中都是搜不到的蛛丝马迹的。这个时候怎么办？对，如果不想去找framework的源码，那就靠推测。</p><p>既然Launcher是个APP，那最终就是要继承自Activity的，点击图标就是启动Activity，那就直接看Activity里的startActivity就可以了。</p><h3 id="5-Activity-startActivity"><a href="#5-Activity-startActivity" class="headerlink" title="5. Activity#startActivity"></a>5. Activity#startActivity</h3><p>搜索打开Activity.java，定位startActivity方法，发现它有几个重载的方法（重载和重写的区别在于，重写是换核不换壳，重载是换参数换返回值），但是不管哪个最终都走到了startActivityForResult方法里，其内又调用了Instrumentation的execStartActivity，Instrumentaion是一个管理Activity和Application生命周期的变量，在Activity搜索这个变量的赋值，发现是在attach方法里初始化，下一步跟进它的execStartActivity方法。</p><h3 id="6-Instrumentation-execStartActivity"><a href="#6-Instrumentation-execStartActivity" class="headerlink" title="6. Instrumentation#execStartActivity"></a>6. Instrumentation#execStartActivity</h3><p>搜索Instrumentation，定位execStartActivity方法，发现里面内容很少，最终调用的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityTaskManager.getService().startActivity</span><br></pre></td></tr></table></figure><p>跳到ActivityTaskManager里，找到getService方法，发现返回的是个IActivityTaskManager类型的实例，不管用哪种方式搜都是搜不到对应类文件的，这时就要搜关键词了，会发现有个类继承自IActivityTaskManager.Stub，看这熟悉的味道，AIDL不就来了吗，既然来了，那就插播一条Binder。</p><h3 id="7-Binder"><a href="#7-Binder" class="headerlink" title="7. Binder"></a>7. Binder</h3><p>这里只简单的说用法，以便于能继续把代码看下去，等会单独写一篇较为详细的说。</p><p>Android系统中，同一个进程间，资源共享，不同进程间，资源不共享，无法直接通信。Binder是Android系统中进程之间通信的方式。进程间通信，无非就是调用方法，一个进程提供方法，另一个进程调用这些方法。当然，直接调用是不可能的，中间要通过Binder。所以，提供方进程要以Binder规定的形式定义方法，调用方进程也用Binder规定的方式调用，这样就可以通信了，至于跨进程的的事交给Binder来做。</p><p>拿上面的例子来说，IActivityTaskManager中，就是提供方进程所提供的所有方法，同时，提供方要实现这些方法，通过继承IActivityTaskManager.Stub的方式，Stub中默认写了一些Binder需要用到的方法。而调用方，直接调用IActivityManager中定义的方法，即可。继续跟进代码。</p><h3 id="8-ActivityTaskManagerService-startActivity"><a href="#8-ActivityTaskManagerService-startActivity" class="headerlink" title="8. ActivityTaskManagerService#startActivity"></a>8. ActivityTaskManagerService#startActivity</h3><p>上面调用了IActivityTaskManager的startActivity方法，实际提供功能的是实现类ActivityTaskManagerService，搜索这个类并定位startActivity方法，这个时候，就不在Launcher的进程了，而是来到了ActivityTaskManagerService所在的进程，这个是系统进程，是在系统初始化期间启动起来的。</p><p>接下来，即将上演的就是一场足球大赛了，你会看到这个Launcher发来的启动Activity请求，在这个进程间被大家踢来踢去，你传给我，我又传给他，他又回传给我，紧张激烈，眼花缭乱，精彩至极。</p><p>startActivity方法几经转发，最终调用的是其内部的startActivityAsUser方法，这方法里面关键的代码是这句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityTaskManagerService#startActivityAsUser</span></span><br><span class="line">getActivityStartController().obtainStarter(intent, <span class="string">&quot;startActivityAsUser&quot;</span>).set.set.set.set.execute()</span><br></pre></td></tr></table></figure><p>getActivityStartController()获取的是一个ActivityStarerController，obtainStarter获取到的是一个ActivityStarter实例。Controller里对ActivityStarter实例进行了复用管理，这和Handler中用的Message.obtain很像，所以可以推断出，ActivityStart也是个频繁使用的对象，所以才需要增加复用的管理，以优化内存。下面看看ActivityStarter选手如何带球过人。</p><h3 id="9-ActivityStarter"><a href="#9-ActivityStarter" class="headerlink" title="9. ActivityStarter"></a>9. ActivityStarter</h3><p>可以看到的是，在获取到ActivityStarter的实例后，进行了一些列的字段赋值操作，这里类比Message即可，最终调用了execute方法，所以它的流程是，获取对象后初始化各个字段，最后执行，搜索ActivityStarter，定位execute方法。</p><p>可以看到的是，execute方法内先是对之前的参数做了一些校验，随后便调用了executeRequest方法，execute一脚将球踢出，我们的目光随着球来到了executeRequest方法。</p><p>这个方法主要在做启动前的检查，里面有着不少的注释，解释了每一步在在检查什么，比如状态，比如权限。做完自己想做的事后，并没有实际启动Activity，而是再一次将球传出，转眼球便来到了startActivityUnchecked的脚下，startActivityUnchecked看着脚下的脚，迅速反应。</p><p>startActivityUnchecked可能不在状态，早晨吃冰了有点拉肚子，几个垫步，就将球传给了startActivityInner，看着远去的球，邪魅一笑：嘿嘿，又是划水的一天呢。</p><p>startActivityInner中依然是检查，继续着前人没有完成的工作，同时也对task stack的focusable做了一些检查，最后调用了RootWindowContainer的resumeFocusedStacksTopActivities方法，然后自己就下班了。</p><p>伪球赛直播好累，好好说话。</p><h3 id="10-RootWindowContainer"><a href="#10-RootWindowContainer" class="headerlink" title="10. RootWindowContainer"></a>10. RootWindowContainer</h3><p>想要启动一个Activity，势必要将其显示到屏幕上，RootWindowContainer就是管理屏幕窗口的，这里涉及到了另一个大类，WindowManagerService，WMS，这里只需要知道它将Activity显示了出来，</p><p>搜索RootWindowContainer，定位resumeFocusedStacksTopActivities，可以看到，在这里它调用了它其中维护了这个窗口对应的ActivityStack的方法，resumeTopActivityUncheckedLocked</p><h3 id="11-ActivityStack"><a href="#11-ActivityStack" class="headerlink" title="11. ActivityStack"></a>11. ActivityStack</h3><p>搜到进入到ActivityStack，发现这个文件好长，有3000多行，定位到resumeTopActivityUncheckedLocked，方法内有一大段说明注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// When resuming the top activity, it may be necessary to pause the top activity (for</span></span><br><span class="line"><span class="comment">// example, returning to the lock screen. We suppress the normal pause logic in</span></span><br><span class="line"><span class="comment">// &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span></span><br><span class="line"><span class="comment">// end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span></span><br><span class="line"><span class="comment">// to ensure any necessary pause logic occurs. In the case where the Activity will be</span></span><br><span class="line"><span class="comment">// shown regardless of the lock screen, the call to</span></span><br><span class="line"><span class="comment">// &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span></span><br></pre></td></tr></table></figure><p>意思大概是，启动一个Activity时，可能需要暂停上一个Activity。所以这个方法里做了两件事，一件是启动Activity，另一件是暂停Activity。启动Activity调用的是resumeTopActivityInnerLocked，暂停Activity调用的是checkReadyForSleep。</p><p>这里需要暂停的就是Launcher，在启动完其他Activity后，Launcher就不处于前台了，自然是要被暂停。checkReadyForSleep里调用的是ActivityStackSupervisor的checkReadyForSleepLocked方法，这个方法里又调用了RootWindowContainer的putStacksToSleep，启动Activity和暂停Activity都免不了和Window打交道，毕竟启动和暂停给用户的直观感受就是能看到，和看不到了，其他的细节就不多说了。</p><p>回过头来看resumeTopActivityInnerLocked，走了这么远，感觉希望就在眼前了。这个方法内先是为Activity创建了一个新的进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ActivityRecord next = ....;</span><br><span class="line"><span class="keyword">if</span> (next.attachedToProcess()) &#123;</span><br><span class="line">    next.app.updateProcessInfo(<span class="keyword">false</span> <span class="comment">/* updateServiceConnectionActivities */</span>,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* activityChange */</span>, <span class="keyword">false</span> <span class="comment">/* updateOomAdj */</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* addPendingTopUid */</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!next.isProcessRunning()) &#123;</span><br><span class="line">    <span class="comment">// Since the start-process is asynchronous, if we already know the process of next</span></span><br><span class="line">    <span class="comment">// activity isn&#x27;t running, we can start the process earlier to save the time to wait</span></span><br><span class="line">    <span class="comment">// for the current activity to be paused.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isTop = <span class="keyword">this</span> == taskDisplayArea.getFocusedStack();</span><br><span class="line">    mAtmService.startProcessAsync(next, <span class="keyword">false</span> <span class="comment">/* knownToBeDead */</span>, isTop,</span><br><span class="line">            isTop ? <span class="string">&quot;pre-top-activity&quot;</span> : <span class="string">&quot;pre-activity&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next的类型是ActivityRecord，TaskRecord对应一个Activity栈，启动Activity时向栈内压入，销毁Activity时从栈顶弹出，栈里面存储的结构是ActivityRecord，每个ActivityRecord对应一个Activity。这里的next，指的是要启动的Activity，attachedToProcess检查的是是否存在一个进程，这里是没有，所以进入到else，else里做的事情就是为这个ActivityRecord创建一个进程。mAtmService.startProcessAsync便是创建进程的操作。</p><p>mAtmService的类型是ActivityTaskManagerService，也就是上面提到过的唯一继承了IActivityTaskManager.Stub的类</p><h3 id="12-为Activity启动一个进程"><a href="#12-为Activity启动一个进程" class="headerlink" title="12. 为Activity启动一个进程"></a>12. 为Activity启动一个进程</h3><p>上面的mAtmService.startProcessAsync将会进入开启进程的任务。搜索ActivityTaskManagerService，定位到startProcessAsync方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Post message to start process to avoid possible deadlock of calling into AMS with the</span></span><br><span class="line"><span class="comment">// ATMS lock held.</span></span><br><span class="line"> <span class="keyword">final</span> Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,</span><br><span class="line">                    mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,</span><br><span class="line">                    isTop, hostingType, activity.intent.getComponent());</span><br><span class="line">mH.sendMessage(m);</span><br></pre></td></tr></table></figure><p>方法里面有一句注释，说的是为了避免死锁，所以使用消息的方式创建，mH的类型就是Handler，PooledLambda我还没看，但是可以确定的是，发送消息之后，第一参数lambda就会执行，也就是会调用ActivityManagerInternal的startProcess方法，ActivityManagerInternal是个抽象类，全局搜索”extends ActivityManagerInternal”后，可以看到LocalService是它的唯一实现类。</p><p>LocalService是AMS的内部类，打开AMS，定位到startProcess方法，里面没有过多操作，直接调用了外部类AMS的startProcessLocked方法，startProcessLocked中直接调用了ProcessList的startProcessLocked方法。</p><p>ProcessList里面的startProcessLocked一定有着俄罗斯套娃的血统，一路走过4个重载方法，才看到了底，然后又调用了startProcess方法，在这个方法里面，总算是调用Process的start的方法，Process中Zygote通过fork自己，创建出一个新的进程，在进程中执行了android.app.ActivityThread的main方法。</p><p>至此，新的进程启动完成。</p><h3 id="13-ActivityThread与AMS绑定"><a href="#13-ActivityThread与AMS绑定" class="headerlink" title="13. ActivityThread与AMS绑定"></a>13. ActivityThread与AMS绑定</h3><p>这时，我们已经不在系统服务的进程中了，而是来到了刚刚系统进程为Activity新创建的进程。</p><p>ActivityThread在新的进程中被加载后，会调用它的main函数，我们来看看它在main函数中做了什么事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很清晰，只做了两件事，一个是创建一个ActivityThread实例并attach，另一个是开始消息循环Looper，毕竟Android是个消息驱动的机制，所以进程启动先开启Looper也是必须的。然后再来看看attach中做了什么事情</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ApplicationThread mAppThread = <span class="keyword">new</span> ApplicationThread();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取IActivityManager实例，然后调用它的attachApplication方法。熟悉吗，上面是不是提到过？Launcher启动Activity时，最终调用的是不是就是这个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActivityTaskManager.getService().startActivity</span><br></pre></td></tr></table></figure><p>这里也是一样，Launcher是在和ActivityTaskManager跨进程通信，而这里是在和ActivityManagerService通信。这么一调用，才来到这个进程没多久，转眼就要回到系统服务进程中。</p><p>ActivityManagerService是IActivityManager的唯一实现类，所以上面的调用就会走到AMS的attachApplication中，这个方法里没有做太多事，直接调用了attachApplicationLocked方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thread.bindApplication(processName, appInfo, providerList,</span><br><span class="line">                       instr2.mClass,</span><br><span class="line">                       profilerInfo, instr2.mArguments,</span><br><span class="line">                       instr2.mWatcher,</span><br><span class="line">                       instr2.mUiAutomationConnection, testMode,</span><br><span class="line">                       mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                       isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                       <span class="keyword">new</span> Configuration(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                       app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                       mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                       buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">                       app.mDisabledCompatChanges);</span><br></pre></td></tr></table></figure><p>attachApplicationLocked先是调用了传进啦的thread的bindApplication方法，thread的类型是ApplicationThread，是Activity进程调用attach方法时的第一个参数，Activity进程是刚刚创建启动，其中还没有相关的数据，通过这个方法将系统服务进程的参数发送到Activity进程。之后，attachApplicationLocked继续发扬踢皮球的好传统，将球传给了ActivityTaskManagerInternal的attachApplication，这是个抽象方法，具体实现类在ActivityTaskManagerService中的attachApplication方法，定位到这个方法后，可以看到里面再次传球，调用了RootWindowContainer的attachApplication，然后又调用了startActivityForAttachedApplicationIfNeeded方法，这个方法又调用了ActivityStackSupervisor的realStartActivityLocker方法，到这里，终于看到了曙光，这个方法里的关键代码是这些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// line838</span></span><br><span class="line"> <span class="comment">// Create activity launch transaction.</span></span><br><span class="line"><span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(proc.getThread(), r.appToken);</span><br><span class="line"></span><br><span class="line">clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">        System.identityHashCode(r), r.info,</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">        <span class="comment">// and override configs.</span></span><br><span class="line">        mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">        r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),</span><br><span class="line">        r.getSavedState(), r.getPersistentSavedState(), results, newIntents,</span><br><span class="line">        dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),</span><br><span class="line">        r.assistToken, r.createFixedRotationAdjustmentsIfNeeded()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set desired final state.</span></span><br><span class="line"><span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line"><span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">    lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">&#125;</span><br><span class="line">clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule transaction.</span></span><br><span class="line">mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br></pre></td></tr></table></figure><p>Transaction，事务，是Binder通信中的一个概念，里面是用自定义的协议，每次发送协议进行数据传递，都称为一个事务。</p><p>先是获取到了一个clientTransaction实例，然后向其中添加了一个LaunchActivityItem，然后又设置了ResumeActivityItem，最终传给了scheduleTransaction。最终会调用IApplicationThread的scheduleTransaction方法，也就是说，系统服务进程会调用Activity进程的中ApplicationTHread的scheduleTransaction方法，这个事务中的LaunchActivityItem，最终会调用ActivityThread的handleLaunchActivity，而ResumeActivityItem会调用ActivityThread的handleResumeActivity方法。Activity的onResume方法执行完，就意味着这个页面已经展示在了屏幕上。</p><p>现在想一下，为什么要这么做呢？我们通过ActivityTaskManager.getService可以调用ActivityTaskManagerService中的方法，通过ActivityManager.getService可以调用ActivityManagerService中的方法，这是我们的Activity进程调用系统进程服务的方法，那么系统服进程中的服务若是需要调用Activity进程中的方法，那么它该需要通过什么方式来获取具有可调用方法的实例呢？答案是没有，系统服务进城是开机时创建的，它可以提供接口供后来者调用来获取实例来和它通信，但是我们的Activity进程是在用户的使用过程中创建和小灰的，所以，要想让系统服务进程调用我们Activity进程的方法，那么就需要在Activity进程启动的时候，主动将包含方法的实例告诉系统服务进程，也就是上面所说的绑定操作。而这里所谓的包含方法的实例，则叫做代理。Activity进程通过系统服务进程的代理，调用系统服务进程的方法；系统服务进程则是通过Activity进程的代理，来调用Activity进程的方法。</p><p>也就是说，IApplicationThread是Activity进程在系统服务进程的代理，系统服务进程都会通过IApplicationThread来调用Activity进程的方法。</p><p>至此，启动流程完成。</p><h3 id="14-Transaction"><a href="#14-Transaction" class="headerlink" title="14. Transaction"></a>14. Transaction</h3><p>上面的方法里用到了Transaction，LaunchActivityItem是怎么调用ActivityThread的handleLaunhActivity方法的呢？ResumeActivityItem又是怎么调用ActivityThread的handleResumeActivity的呢？下面来说一说这个。</p><p>首先，我们知道的是，系统服务进程中的Transaction是通过这样发送出去的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br></pre></td></tr></table></figure><p>mService的类型是ActivityTaskManagerService，定位到它的getLifecycleManager方法，发现返回类型是ClientLifecycleManager，也就是说，最终transaction是传给了ClientLifecycleManager的scheduleTransaction方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientLifecycleManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        <span class="comment">// If client is not an instance of Binder - it&#x27;s a remote call and at this point it is</span></span><br><span class="line">        <span class="comment">// safe to recycle the object. All objects used for local calls will be recycled after</span></span><br><span class="line">        <span class="comment">// the transaction is executed on client in ActivityThread.</span></span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里面，直接调用了ClientTransaction的schedule方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientTransaction.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法又调用了mClient的scheduleTransaction方法，mClient的类型是IApplicationThread，意思就是说，这个时候就把ClientTransaction发送给了ActivityThread的内部类ApplicationThread处理了。启动流程说完了，耐心一下子就上来，来，一行一行往下说，看看ApplicationThread中是怎么处理Transaction的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又很简单，又什么都没干，交给了外部类ActivityThread，而scheduleTransaction方法不是ActivityThread自己的，是它继承自父类ClientTransactionHandler的，它并没有重写，所以，还要到父类ClientTransactionHandler中看看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientTransactionHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span></span>;</span><br></pre></td></tr></table></figure><p>看到这，就明白了吧，父类处理ClienTransaction的方式就是，调用sendMessage方法，ActivityThread作为子类，实现了sendMessage方法，所以它能接收到这个message，它处理message的方式是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">            <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">            mTransactionExecutor.execute(transaction);</span><br><span class="line">            <span class="keyword">if</span> (isSystem()) &#123;</span><br><span class="line">                <span class="comment">// Client transactions inside system process are recycled on the client side</span></span><br><span class="line">                <span class="comment">// instead of ClientLifecycleManager to avoid being cleared before this</span></span><br><span class="line">                <span class="comment">// message is handled.</span></span><br><span class="line">                transaction.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次传球，交给了mTransactionExecutor处理，它是ActivityThread中的一个变量，类型是TransactionExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionExecutor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> size = callbacks.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionExecutor执行execute时，先调用callback，再调用lifecyclestate，完事。而它们的execute和postEcexute方法，都是写在自身里面的，LaunchActivityItem写的就是handleLaunchActivity，ResumeActivityItem写的就是handleResumeActivity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResumeActivityItem.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.handleResumeActivity(token, <span class="keyword">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward, <span class="string">&quot;RESUME_ACTIVITY&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LaunchActivityItem.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client, mAssistToken, mFixedRotationAdjustments);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-总结"><a href="#15-总结" class="headerlink" title="15. 总结"></a>15. 总结</h3><p>这个过程，其实用几句话就能说完，Launcher进程通过Binder向系统服务进程发送启动请求，系统服务进程做一些准备后，创建一个新进程，新进程通过Binder和系统服务进程绑定，然后系统服务进程通过Binder调用这个新进程的生命周期方法。</p><p>看着简单的流程中，其实充满了各种各种的情况，所以要做很多检查，验证，因此，一个启动Activity的请求，就可以让系统像个足球场般热闹起来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇来学习一下从按下桌面应用图标、到应用完成启动，运行至前台，这个过程中系统都做了哪些事。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://oynix.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>解决Android ViewBinding爆红</title>
    <link href="https://oynix.github.io/2022/04/2814e9f4347b/"/>
    <id>https://oynix.github.io/2022/04/2814e9f4347b/</id>
    <published>2022-04-21T09:06:01.000Z</published>
    <updated>2022-04-22T09:54:31.048Z</updated>
    
    <content type="html"><![CDATA[<p>ViewBinding生成的类经常在一些不经意的操作之后爆红，说找不到，虽然不影响运行，但是看起来很不爽，即便你能看到生成类就在那躺着，但是AS就是说找不到。既然它自己找不到，那就给它指个路。</p><span id="more"></span><p>在app下的build.gradle添加配置，将生成的文件手动添加进去即可</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            java.srcDirs = [<span class="string">&#x27;src/main/java&#x27;</span>, <span class="string">&#x27;build/generated/data_binding_base_class_source_out/debug/out&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以包含完整的资源</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">android &#123; </span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            assets.srcDirs = [<span class="string">&#x27;src/main/assets&#x27;</span>, <span class="string">&#x27;src/main/assets/&#x27;</span>]</span><br><span class="line">            jniLibs.srcDirs = [<span class="string">&#x27;libs&#x27;</span>]</span><br><span class="line">            res.srcDirs = [<span class="string">&#x27;src/main/res&#x27;</span>]</span><br><span class="line">            java &#123;</span><br><span class="line">                srcDirs = [<span class="string">&#x27;src/main/java&#x27;</span>]</span><br><span class="line">                exclude <span class="string">&#x27;src/ignoreDir&#x27;</span>  <span class="comment">// 不想包含文件的路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            java.srcDirs = [<span class="string">&#x27;src/main/java&#x27;</span>, <span class="string">&#x27;build/generated/data_binding_base_class_source_out/debug/out&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            java.srcDirs = [<span class="string">&#x27;src/main/java&#x27;</span>, <span class="string">&#x27;build/generated/data_binding_base_class_source_out/release/out&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样会带来另外一个问题，原本点生成的ViewBinding生成类，是跳转到对应的xml布局文件中，当添加了资源目录后，跳转到的就是生成的类文件了。原因是，加入到sourceSets后，生成类文件就被IDE当成普通的类文件处理。我觉得，相比于爆红，这个倒是可以接受的，不通过生成类跳转便是了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ViewBinding生成的类经常在一些不经意的操作之后爆红，说找不到，虽然不影响运行，但是看起来很不爽，即便你能看到生成类就在那躺着，但是AS就是说找不到。既然它自己找不到，那就给它指个路。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://oynix.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin的inline，noinline，crossline</title>
    <link href="https://oynix.github.io/2022/04/2cb2cb5ddfa5/"/>
    <id>https://oynix.github.io/2022/04/2cb2cb5ddfa5/</id>
    <published>2022-04-20T17:13:31.000Z</published>
    <updated>2022-04-21T01:21:13.629Z</updated>
    
    <content type="html"><![CDATA[<p>好好说说这line三兄弟。</p><span id="more"></span><h3 id="1-Kotlin高阶函数"><a href="#1-Kotlin高阶函数" class="headerlink" title="1. Kotlin高阶函数"></a>1. Kotlin高阶函数</h3><p>要想说明白，从头捋了一下，还得从Kotlin的高阶函数说起。首先，什么是高阶函数呢？其实所谓的高，是相对而言的，就普遍性而言，函数的参数和返回值，要么没有，要么是个数值，要么是个引用类型的对象，这是低阶函数。当一个函数的参数或者返回值类型，也是一个函数类型时，这种就叫高阶函数，函数型的类型，是Kotlin中特有而Java没有的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是参数类型是函数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun1</span><span class="params">(item: () -&gt; <span class="type">Unit</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是返回值类型是函数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fun2</span><span class="params">()</span></span>: () -&gt; <span class="built_in">Unit</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数类型的变量，</span></span><br><span class="line"><span class="comment">// 因为函数名字用不到，所以被Kotlin强制要求不能写，f1、f2、f3是变量名字</span></span><br><span class="line"><span class="keyword">val</span> f1 = <span class="function"><span class="title">fun</span> <span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">val</span> f2: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">val</span> f3 = &#123;&#125;</span><br></pre></td></tr></table></figure><p>简单吧，高阶函数就是这样的</p><h3 id="2-Kotlin中的"><a href="#2-Kotlin中的" class="headerlink" title="2. Kotlin中的::"></a>2. Kotlin中的::</h3><p>使用两个冒号加上函数的名字，这个函数就可以被当作参数传递，这其中是为什么呢？</p><p>首先需要明确的是，函数就是函数，不是对象，然而只有对象才能被当作参数传递，所有传递函数的地方，在编译之后Kotlin都将其封装成了一个对象，通过括号调用函数类型的参数，实际上就是在调用这个函数对象的invoke方法，开发中可以直接传递函数，这本质上是个语法糖。</p><p>语法糖，一时爽。我们都知道，创建对象是有消耗的，每调用一次传递函数类型的函数，就要为这个参数创建一个对象，如果在循环中调用，那可能就是个隐藏的内存炸弹。所以，为了解决这个可能的隐患，有请inline登场。</p><h3 id="3-inline"><a href="#3-inline" class="headerlink" title="3. inline"></a>3. inline</h3><p>inline多用于修饰带有函数类型参数的函数，如果你用它来修饰一个普通函数，也可以，但是IDE会给你弹提醒，告诉你，没必要。调用被inline修饰的函数，不会增加一层调用栈，inline，顾名思义，在一条线上。所以，在编译期间，会把inline的函数直接复制到调用的位置，连同函数类型的参数也一并展开，这样就巧妙的去掉了函数参数，从而也不会增加创建函数对象的消耗了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">(fp: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">fp(<span class="string">&quot;message from f&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f &#123; msg -&gt;</span><br><span class="line">println(msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的main函数，会把f的代码复制过，大概长这个样子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;welcome&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;message from f&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-noinline"><a href="#4-noinline" class="headerlink" title="4. noinline"></a>4. noinline</h3><p>看名字就知道，和inline相反，但是inline是修饰方法，noinline是修饰函数参数的，我们已经知道了，inline修饰的方法，在编译时会复制代码，并把函数参数展开。有时候，函数会有多个函数类型的参数，我们并不希望将所有参数都展开，这个时候用noinline修饰不想被展开的函数类型的参数，即可。</p><h3 id="5-crossline"><a href="#5-crossline" class="headerlink" title="5. crossline"></a>5. crossline</h3><p>这里主要涉及return的问题，看个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">hi</span><span class="params">(callback: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">callback()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hi &#123;</span><br><span class="line">println(<span class="string">&quot;callback&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">printlin(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用hi函数时，函数参数体中的return直观上看返回的是hi，然后会执行println(“main end”)，但是，hi可是inline修饰的函数，还是先看看最终形态</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;callback&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一看，return又是返回的main函数，所以由于嵌套的函数体，return成了一个繁琐的问题，因此，Kotlin有有几个规定</p><ul><li>函数参数的参数体内，不允许调用return，只有inline修饰的函数的函数参数体可以调用return，此时return返回的是外层函数</li><li>inline修饰的函数中，不允许再嵌套调用函数参数<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">hi</span><span class="params">(callback: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">println(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">scope.launch &#123;</span><br><span class="line">callback() <span class="comment">// 此处报错</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果真的需要在inline函数中嵌套调用函数参数，那么就用crossline修饰这个参数，但是，被修饰参数的函数体中，便不能再调用return</li><li>上面只是说不可以单独调用return，但是都可以调用return@label来手动指定返回锚点</li></ul><p>总结下来就是，inline函数中没有被crossline修饰的函数参数体中，可以调用return，返回的是外层函数。同时，只有被crossline修饰的函数参数，才可以嵌套调用。</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul><li>inline：修饰函数，被修饰的函数编译后将代码复制到调用处，并将函数类型的参数展开</li><li>noinline：修饰函数类型的参数，被修饰后将不再展开</li><li>crossline：修饰函数类型的参数，被修饰后可以在inline函数中嵌套调用</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;好好说说这line三兄弟。&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://oynix.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://oynix.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Java和Kotlin的范型</title>
    <link href="https://oynix.github.io/2022/04/4040bd6a597f/"/>
    <id>https://oynix.github.io/2022/04/4040bd6a597f/</id>
    <published>2022-04-19T15:29:16.000Z</published>
    <updated>2022-04-30T13:35:13.987Z</updated>
    
    <content type="html"><![CDATA[<p>我发现，想要解释清楚一个名词，如果只是拿着定义反复说，远不如举个合适的例子来的更快更直接。而且，举的例子越形象，理解的就越快，选的对比物越独特，记忆就越持久，这样即便是过了很久，只要是到了用的时候，便会立刻回忆起这个独特的例子，从而相关知识再次被成功加载到脑子里。</p><span id="more"></span><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>范型这个东西，接触也不是一天两天了，但好像就从来没有领悟透彻，需要的时候查一查，加上高度人性化的IDE，总是能满足迎面而来的种种需求，等到事后便又云里雾里，所谓知其然，更要知其所以然，这篇就来好好说说，系统性的来捋一捋。</p><p>想了一下，还是用生活中常见的东西来举例吧：手机。新世纪初曾出现过一种系统名字为塞班的手机，Symbian，后来被诺基亚收购，全球出货量相当之高，至今记录尚未被打破，在当时有个塞班手机是个很开心的事了，在上面能装QQ，通过流量和朋友聊天，相比于发短信能省下不少钱，那个时候30M的流量可以用上一个月，每天都计算着流量玩手机。时代在发展，社会在进步，再后来，更智能的Android系统和iOS系统出现了，逐步替代了塞班机器，出了塞班机能做到的事情，它还有着更先进的功能。</p><p>接下来，就用手机(Phone, Symbian, Android)、手机生产商(Producer)和手机用户(Consumer)，来说说范型是什么。</p><p>在功能上，我们可以把它们之间看成是继承的关系，Phone代表的就是能打电话的设备，Symbian代表的在能打电话的基础上，还能进行一些简单的联网操作，比如发个QQ消息，打开个网页，而Android则是在Symbian的功能之上，又增加了更多的功能，比如语音通话、视频通话、看直播，等等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|--Phone （打电话）</span><br><span class="line">   |--Symbian （打电话，发消息）</span><br><span class="line">      |--Android （打电话，发消息，视频通话）</span><br></pre></td></tr></table></figure><h3 id="1-引出"><a href="#1-引出" class="headerlink" title="1. 引出"></a>1. 引出</h3><p>先从熟悉的Java说起。</p><p>我们都知道，当声明完一个类型的变量后，可以用这个类型自身来初始化，也可以用它的子类来初始化，这些都是可以编译运行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Symbian phone = <span class="keyword">new</span> Symbian();</span><br><span class="line">Symbian phone = <span class="keyword">new</span> Android();</span><br></pre></td></tr></table></figure><p>这个其实很好理解，你想，我声明一个Symbian是为了干嘛，不是打电话就是发消息，那么，不管给我一个Symbian还是给我一个Android，等我拿到手后，都可以满足我的需求，所以这是允许的，这也就是Java三大特性之一，多态。</p><p>说完这个，再来看看下面这种使用集合时的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Symbian&gt; sym = <span class="keyword">new</span> ArrayList&lt;Symbian&gt;();</span><br><span class="line">List&lt;Android&gt; and = sym;</span><br></pre></td></tr></table></figure><p>声明一个Android类型的集合，然后用一个类型是Symbian的集合来赋值，你会发现，这么写会报错，也就是不被允许的。这是因为，Symbian虽然是Android的子类，<code>List&lt;Symbian&gt;</code>却不是<code>List&lt;Android&gt;</code>的子类，这里，就涉及到了类型擦除。</p><p>简单说说什么是类型擦除。Java虽然支持范型，但是JVM里却没有范型这个东西的，Java写的代码最终都要放到JVM里去跑，所以，其中的范型都要去掉，替换成一个确定的类型，这个操作，就叫类型擦除，这个事是在编译阶段由编译器来做的。所以，<code>List&lt;Symbian&gt;</code>不是<code>List&lt;Android&gt;</code>的子类，但是，<code>List&lt;Symbian&gt;</code>是<code>Collection&lt;Symbian&gt;</code>的子类。</p><p>针对这个问题，Java提供了两个通配符，? extends和? super。</p><h3 id="2-extends"><a href="#2-extends" class="headerlink" title="2. ? extends"></a>2. ? extends</h3><p>? extends是Java提供的范型通配符，通过extends限制了位置类型的?，用法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Symbian&gt; phone = <span class="keyword">new</span> ArrayList&lt;Symbian&gt;();</span><br><span class="line">List&lt;? extends Symbian&gt; phone = <span class="keyword">new</span> ArrayList&lt;Android&gt;();</span><br></pre></td></tr></table></figure><p>对于声明的变量phone，?代表着类型不确定，但是通过extends可以知道，它是Symbian的子类，所以在初始化的时候，可用Symbian或者它的子类，甚至它的子类的子类，都是可以的。</p><p>通过phone的get方法获取元素时，返回的类型只能是Symbian，因为对于变量phone来说，它只知道自己存储的是Symbian或其子类，具体类型并不知道，所以为了安全，它只能返回Symbian类型。假如它返回了一个Android类型，调用者拿返回值来视频通话，但是实际存储若是Symbian类型，则没有视频通过这个功能，为避免这种情况，Java将返回类型限定为Symbian。</p><p>现在想一下通过add方法向phone添加元素的情况，当存储的真实类型是Android时，这个时候是不能向其中添加Symbian类型元素的，因为Symbian是Android的子类，父类型接收子类型的实例这是可以的，因为父类型有的功能子类型都有，所以调用父类型任何方法都不会出错，但是子类型接收父类型的实例是不可以的，生命一个Android类型，用Symbian初始化，等到调用视频通过时，Symbian就傻眼了，它不会呀。为了避免这个可能出现意外的情况，所以Java直接禁止了向其中添加元素，既然解决不了问题，那就解决提出问题的人。</p><p>所以，? extends T通配符可以用自身及其子类，子类的子类初始化，从其中get获取元素时，均为T类型，且不可向其add元素。</p><h3 id="3-super"><a href="#3-super" class="headerlink" title="3. ? super"></a>3. ? super</h3><p>看过上面的extends，这个? super T就很好理解了，?同样代表着类型不确定，但是是T的父类型，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Symbian&gt; phone = <span class="keyword">new</span> ArrayList&lt;Symbian&gt;();</span><br><span class="line">List&lt;? <span class="keyword">super</span> Symbian&gt; phone = <span class="keyword">new</span> ArrayList&lt;Phone&gt;();</span><br></pre></td></tr></table></figure><p>通过super通配符限定变量phone的范型，它可以使用Android，或是Symbian初始化。要知道，Java中Object是所有类的父类型，所以在此使用Object初始化，也是可以的。</p><p>通过get从中获取元素时，因为phone不知道具体类型，所以为了万无一失，它只能返回Object类型，只有Object类型才能应对所有类型的情况。通过add添加时，虽然phone不确定自己存储的是哪种类型，但是，接收Symbian及其子类型类型就一定不会出错，因为不管是Symbian的父类型还是间接父类型，只要它有的功能，Symbian就一定也有，同理，Symbian的子类型也有。</p><p>总结下来就是，? super限定符的集合，可以add添加，但是获取的都是Object类型</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>Java这些对于范型极其限定符的种种限制，其实，都是为了编译后在JVM中运行不出现问题，如果能从这一点考虑，这些就很好理解了。如果把Java中的继承关系，看成上下承接关系的话，父类在上，子类在下，子类在继承了父类型之后，又扩展了自己独特的功能，就像上面的例子中Phone、Symbian和Android的关系，这样来看，它们就像一个没有底边的三角形，坐在尖尖上的就是Object的，功能最少，越向下的子类型，功能越丰富，也就越庞大，这个关系模型需要记住，有了这个还算形象的模型，后面的一点定义会很好理解。</p><p>? extends T限定符限定了类型是T或其子类，官方说法是，限定了类型上限，结合三角形模型来看，就像是在T这一层画一条线，被这个限定符限定的，只能是这条线以下的类型，这条线即为类型上限，T为功能最小的类型，也叫协变，covariance。</p><p>? super T限定符限定了类型是T或其父类，官方说法是，限定了类型下限，结合三角形模型来看，类型T同样是一条线，可接收的类型均在线的上方，这条线是类型下限，T是功能最多的类型，这个叫逆变，contravariance，向下才能做大做强，它非要逆流而上，所以叫它逆变</p><p>当没有修饰符，只有一个T时，这个时候限定了类型只能是这种，没有其他可能，所以这个叫不变，invariance</p><h3 id="5-类型擦除"><a href="#5-类型擦除" class="headerlink" title="5. 类型擦除"></a>5. 类型擦除</h3><p>上面提到了类型擦除，那么如何擦除，以及擦除后是什么样子的呢？简单说，就是用实际的类型替换掉不确定的范型。举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Phone</span>&gt; </span>&#123;</span><br><span class="line">   T phone;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">getPhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> phone; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(T p)</span> </span>&#123; phone = p; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设这个带范型的类，擦除之后大概就是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   Phone phone;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123; reurn phone; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(Phone p)</span> </span>&#123; phone = p; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>擦除之后，没有繁星的类，在JVM中才可运行。这是类中范型的例子，方法参数的情况也是一样的道理。</p><p>不变的范型，替换成Object。</p><p>协变的范型，替换成上限类型。</p><p>逆变的范型，替换成Object。</p><h3 id="6-lt-gt"><a href="#6-lt-gt" class="headerlink" title="6. &lt;?&gt; "></a>6. &lt;?&gt; <T></h3><p>如果仔细看上面的话，会发现一个小细节，在开始声明变量phone时，用的是? extends，到上面类型擦除的例子里，用的变成了T extends。这两个的区别就在此，</p><ul><li><code>&lt;?&gt;</code>：范型的声明</li><li><code>&lt;T&gt;</code>：范型的定义<br>相同点，就是二者都可以限定类型的上限，或者下限。</li></ul><h3 id="7-in，out"><a href="#7-in，out" class="headerlink" title="7. in，out"></a>7. in，out</h3><p>说完Java，再看看Kotlin。</p><p>Kotlin中没有extends和super，与之替换的是out和in</p><ul><li>out：限定类型上限，与? extends等同，在三教模型中，上面是个死胡同，想要out就要向下后，所以限定了上限</li><li>in：等同? super，限定类型下限，也可以结合三角模型来记，in就是往三角里面走</li></ul><h3 id="8-Java的？和Kotlin的"><a href="#8-Java的？和Kotlin的" class="headerlink" title="8. Java的？和Kotlin的*"></a>8. Java的？和Kotlin的*</h3><p>在Java中单独使用<code>?</code>当作范型类型时，它表示的所有类型，等同于：? extends Object。</p><p>Kotlin中有个与之对等的<code>*</code>，等同于out Any。</p><h3 id="9-where"><a href="#9-where" class="headerlink" title="9. where"></a>9. where</h3><p>当有多个类型限定范型时，Java和Kotlin的写法稍有不同，Java是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruits</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruits</span> &amp; <span class="title">Food</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>Kotlin中，单个限制时使用冒号，多个时使用where</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="type">T : Fruits</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="type">T</span>&gt; <span class="title">where</span> <span class="title">T</span> : <span class="type">Fruits</span>, <span class="type">T : Food</span></span></span><br></pre></td></tr></table></figure><h3 id="10-refied"><a href="#10-refied" class="headerlink" title="10. refied"></a>10. refied</h3><p>上面说过范型擦除，所以在运行时候需要知道范型确切类型信息的操作都没法用了，因为不是上限类型就是下限类型，或者是Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class Test&lt;T&gt; &#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (item <span class="keyword">instanceof</span> T) &#123;</span><br><span class="line">         <span class="comment">// 这里是获取不到的，编译也过不去</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin也是一样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(item: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item <span class="keyword">is</span> T) &#123;</span><br><span class="line">         <span class="comment">// 同Java一样</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中的解决方式是，将T换成Class<code>&lt;T&gt;</code>，然后通过Class.isInstance方法<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Test&lt;T&gt; &#123;</span><br><span class="line">   Class&lt;T&gt; ct;</span><br><span class="line">   Test(Class&lt;T&gt; c) &#123;</span><br><span class="line">      ct = t;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (ct.isInstance(item)) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在Kotlin中，也可以使用这中方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> c: Class&lt;T&gt;) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(item: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (c.isInstance(item)) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，Kotlin还提供了一个关键字reified，使得一种更为简答的方式可用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T <span class="keyword">reified</span>&gt;</span> <span class="title">print</span><span class="params">(item: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item <span class="keyword">is</span> T) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-应用-PECS"><a href="#11-应用-PECS" class="headerlink" title="11. 应用 PECS"></a>11. 应用 PECS</h3><p>上面提到过，extends限定了类型上限的List，不能添加，只能向外提供，我们给它起个名字，就叫做生产者，Producer。同样，super限定了类型下限的List，get出来的都是Object，并没有什么实际意义，而可通过add向内添加元素，我们也给它起个名字，叫做消费者，Consumer，结合二者，便是常说的PECS，在Kotlin中，应该就是POCI了吧，但是好像还没听过有谁这么叫，在Java面前，可能Kotlin还是年轻些。</p><p>生产者和消费者模式，就是范型限定的常见应用，举个例子，说明一下。还是用手机的例子。</p><p>生产者接口，可以提供商品</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Producer</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者接口，可以使用商品</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="type">in T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>手机生产者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneProducer</span> : <span class="type">Producer</span>&lt;<span class="type">Phone</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SymbianProducer</span> : <span class="type">Producer</span>&lt;<span class="type">Symbian</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidProducer</span> : <span class="type">Producer</span>&lt;<span class="type">Android</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>实例化出来生产者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p1: Producer&lt;Phone&gt; = PhoneProducer()</span><br><span class="line"><span class="keyword">val</span> p2: Producer&lt;Phone&gt; = SymbianProducer()</span><br><span class="line"><span class="keyword">val</span> p3: Producer&lt;Phone&gt; = AndroidProducer()</span><br></pre></td></tr></table></figure><p>分析一下，我们声明了一个类型是<code>Producer&lt;Phone&gt;</code>的变量p，Producer使用了out范型修饰符，也就是说，p的类型上限就是Phone，那么自然可以传递Phone或其子类行给p，如果反过来则不行，通俗的理解就是，我一个准备生产只带有打电话功能的手机，你给我一个Phone工厂可以生产，Symbian工厂也能生产，Android工厂更能生产了，相反，我想要一个生产Android的工厂，你给一个生产Symbian的，肯定就是不行了，这里的重点是能否生产出。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p1: Producer&lt;Android&gt; = PhoneProducer() <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">val</span> p2: Producer&lt;Android&gt; = SymbianProducer() <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">val</span> p3: Producer&lt;Android&gt; = AndroidProducer()</span><br></pre></td></tr></table></figure><p>这便是体现了限定上限范型的协变性。</p><p>生产者看完，再来看看消费者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneConsumer</span> : <span class="type">Consumer</span>&lt;<span class="type">Phone</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SymbianConsumer</span> : <span class="type">Consumer</span>&lt;<span class="type">Symbian</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndroidConsumer</span> : <span class="type">Consumer</span>&lt;<span class="type">Android</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>实例化出消费者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c1: Consumer&lt;Android&gt; = PhoneConsumer()</span><br><span class="line"><span class="keyword">val</span> c2: Consumer&lt;Android&gt; = SymbianConsumer()</span><br><span class="line"><span class="keyword">val</span> c2: Consumer&lt;Android&gt; = AndroidConsumer()</span><br></pre></td></tr></table></figure><p>再分析一个消费者，限定符in限定了类型下限是Android，所以可以传递父类型给c，这里通俗的理解就是，我一个能把Android玩明白的消费者，你让我去玩一个只能打电话的Phone，我肯定没有问题，同理，反过来也是不行的，我只能会用只能打电话的老年机Phone，你给我一个Android，我不会用的呀，这里的重点是能否消费掉，这里体现的是范型的逆变性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c1: Consumer&lt;Phone&gt; = PhoneConsumer()</span><br><span class="line"><span class="keyword">val</span> c2: Consumer&lt;Phone&gt; = SymbianConsumer() <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">val</span> c3: Consumer&lt;Phone&gt; = AndroidConsumer() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>此外，除了生产者和消费者，还有个聚合体，叫生产消费者，ProducerConsumer，根据传入的类型T，生产时成为类型上限，消费时成为类型下限，最终，就只能是类型T，所以生产消费这体现的是不变性。</p><h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h3><p>发现每个小节的开头语，多数都是上面提到过、上面说过，下面的内容在不断的延伸上面的内容，就像台阶一样，只有把下面的看明白，才能看懂上面的。完整的看一遍下来，发现范型里也没什么深奥难懂的点，只是自己知识的盲点给它增加了几分神秘色彩，稍稍花上点时间，就可以揭开这神秘的面纱。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我发现，想要解释清楚一个名词，如果只是拿着定义反复说，远不如举个合适的例子来的更快更直接。而且，举的例子越形象，理解的就越快，选的对比物越独特，记忆就越持久，这样即便是过了很久，只要是到了用的时候，便会立刻回忆起这个独特的例子，从而相关知识再次被成功加载到脑子里。&lt;/p&gt;</summary>
    
    
    
    <category term="Kotlin" scheme="https://oynix.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://oynix.github.io/tags/Kotlin/"/>
    
    <category term="Java" scheme="https://oynix.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin的KClass，Java的Class</title>
    <link href="https://oynix.github.io/2022/04/e73b1ac0e745/"/>
    <id>https://oynix.github.io/2022/04/e73b1ac0e745/</id>
    <published>2022-04-18T04:46:33.000Z</published>
    <updated>2022-04-19T01:26:13.652Z</updated>
    
    <content type="html"><![CDATA[<p>Java中有Class，而Kotlin则有它的KClass，说说二者的区别和联系。</p><span id="more"></span><h3 id="1-Java-Class"><a href="#1-Java-Class" class="headerlink" title="1. Java Class"></a>1. Java Class</h3><p>Java中的Class是一个final修饰的类，只有一个私有的构造方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private constructor. Only the Java Virtual Machine creates Class objects.</span></span><br><span class="line"><span class="comment">     * This constructor is not used and prevents the default constructor being</span></span><br><span class="line"><span class="comment">     * generated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方法说明可以知道，这个构造方法是给JVM调用的，JVM在加载类的时候会创建对应的Class实例，存放在方法区，一个类只会有一个Class实例，所以下面这个例子中，c1和c2是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class c1 = p.getClass();</span><br><span class="line">Class c2 = Person.class;</span><br></pre></td></tr></table></figure><p>Class类中的方法和成员变量相当之多，但基本都关于Class本身的数据相关，比如获取成员函数、获取成员变量，等等。</p><h3 id="2-Kotlin-KClass"><a href="#2-Kotlin-KClass" class="headerlink" title="2. Kotlin KClass"></a>2. Kotlin KClass</h3><p>与Java Class不同的是，KClass是一个接口，根据接口说明，<code>::class</code>可以获取到KClass的实例，这个接口中同样也是声明了一些和类有关的变量，比如类的名字，类的成员等等</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a class and provides introspection capabilities.</span></span><br><span class="line"><span class="comment"> * Instances of this class are obtainable by the `::class` syntax.</span></span><br><span class="line"><span class="comment"> * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/reflection.html#class-references)</span></span><br><span class="line"><span class="comment"> * for more information.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> T the type of the class.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>KClass有一个实现类，名字是ClassReference，根据名字可以看出，这个类就是参考的Class，通过将Class实例作为构造参数传入，相关字段均通过class实例获取</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassReference</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> jClass: Class&lt;*&gt;) : KClass</span><br></pre></td></tr></table></figure><p>通过Kotlin可扩展的语言自身特性，为KClass扩展了几个属性，这些属性在JvmClassMapping.kt中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> &lt;T&gt; KClass&lt;T&gt;.java: Class&lt;T&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> &lt;T : Any&gt; Class&lt;T&gt;.kotlin: KClass&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">val</span> &lt;T : Any&gt; T.javaClass: Class&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> &lt;T : Any&gt; KClass&lt;T&gt;.javaPrimitiveType: Class&lt;T&gt;?</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> &lt;T : Any&gt; KClass&lt;T&gt;.javaObjectType: Class&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated(<span class="meta-string">&quot;Use &#x27;java&#x27; property to get Java class corresponding to this Kotlin class or cast this instance to Any if you really want to get the runtime Java class of this implementation of KClass.&quot;</span>, ReplaceWith(<span class="meta-string">&quot;(this as Any).javaClass&quot;</span>)</span>, level = DeprecationLevel.ERROR)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="keyword">val</span> &lt;T : Any&gt; KClass&lt;T&gt;.javaClass: Class&lt;KClass&lt;T&gt;&gt;</span><br></pre></td></tr></table></figure><p>前两个属性还挺有趣，Class.kotlin获取KClass，KClass.javaClass获取Class，真是你中有我，我中有你，.完java再.kotlin，能这么一直循环玩下去。后两个属性的区别是，如果本身不是原始类型，那么javaPrimitiveType会返回null。</p><p>最后一个javaClass，已经弃用了，上面写了，让使用java属性，那就不管它就好了</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>Java的Class我们是很熟识的了，容易造成混乱的，就是它和KClass的关联，二者可以互相获取</p><ul><li>获取KClass，按照文档里写的，直接取class属性，在实例和在类上调用，获得的结果是一样的<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 直接获取</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">val</span> kc1 = Person::<span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="keyword">val</span> kc2 = Person()::<span class="class"><span class="keyword">class</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从Class获取</span></span><br><span class="line"><span class="keyword">val</span> kClass = Person().javaClass.kotlin</span><br></pre></td></tr></table></figure></li><li>获取Class，主要通过扩展属性<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从实例获取</span></span><br><span class="line"><span class="keyword">val</span> jClass = Person().javaClass</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从KClass获取</span></span><br><span class="line"><span class="keyword">val</span> jClass = Person::<span class="keyword">class</span>.java</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java中有Class，而Kotlin则有它的KClass，说说二者的区别和联系。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://oynix.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://oynix.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://oynix.github.io/tags/Kotlin/"/>
    
    <category term="Java" scheme="https://oynix.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP介绍</title>
    <link href="https://oynix.github.io/2022/04/1657b987f4f2/"/>
    <id>https://oynix.github.io/2022/04/1657b987f4f2/</id>
    <published>2022-04-17T13:28:01.000Z</published>
    <updated>2022-04-18T07:28:51.453Z</updated>
    
    <content type="html"><![CDATA[<p>TCP，Transmission Control Protocol，传输控制协议，是众多网络协议中较为重要的一个协议，网上多是写三次握手和四次挥手的，一搜就能看到一片又一片，多数都是CV战士的杰作，CV战士绝不认输，所以这篇文章来全面的说说TCP。</p><span id="more"></span><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>如果抛开复杂的协议，只看网络的话，网络传输的就是二进制数据流，也就是一串，或者一长串0011、0101的数据。网络的目的是为了通信、为了交流，这些数据流的通信方式就是，发送方和接收方约定好每个位置的0或1代表着什么，这样接收方收到数据时，就知道发送方想要表达的意思了。但是，一个发送方不可能只给一个接收方发送数据，接收方也不能只接收一个发送方，而且发送方也不总是发送方，也有可能接收数据，因此，为了方便发送和接收，不出现五花八门的约定，大家便统一了数据的格式，这就是协议（protocol）。同时，为了更好的适应不同的情形所产生的需求，各种各样的协议应用而生，数据格式只是协议中的一部分，除此之外，每种协议还规定了各自的发送、接收的特点等等诸多细节，而TCP，就是这众多协议中的一员，这是一个相当复杂的协议，作为一个可靠性连接协议，你不知道它为了能让你的数据正确且完整的到达接收端在背后付出了多大的努力。</p><h3 id="2-简介"><a href="#2-简介" class="headerlink" title="2. 简介"></a>2. 简介</h3><p>数据在TCP层称为流（Stream），数据分组称为分段（Segment）。数据在IP层称为Datagram，数据分组称为分片（Fragment）。UDP中分组称为Message。</p><h3 id="3-运作方式"><a href="#3-运作方式" class="headerlink" title="3. 运作方式"></a>3. 运作方式</h3><p>TCP协议的运行划分为三个阶段：连接创建(connection establishment)、数据传送（data transfer）和连接终止（connection termination）。操作系统将TCP连接抽象为套接字表示的本地端点（local end-point），作为编程接口给程序使用。在TCP连接的生命期内，本地端点要经历一系列的状态改变。</p><p>TCP在每一个要发送的数据包前面，都会添加一个数据头，这个数据头的长度是20个字节，长大概这个样子<br><img src="https://s2.loli.net/2022/04/18/KzldYFkO8nfXUQ2.png"><br>一行代表32个bit，也就是4个字节。前4个字节分别存储源端口和目标端口，序列号seq和确认号ack各占4个字节，接下来的4个字节存储标识位和窗口大小，最后4个字节存储校验和和紧急指针。</p><h4 id="3-1-创建通路"><a href="#3-1-创建通路" class="headerlink" title="3.1 创建通路"></a>3.1 创建通路</h4><p>TCP用三次握手创建一个连接，通常是服务器打开一个套接字socket进行监听listen，等待被动打开，客户端连接服务器，主动打开。服务器执行listen之后，会创建两个队列：</p><ul><li>SYN队列：存放完成两次握手的连接，长度由listen的参数backlog指定</li><li>ACCEPT队列：存放完成三次握手的连接，长度由listen的参数backlog指定</li></ul><p>三次握手过程，下面就直接写Client和Server，不写客户端和服务端</p><ol><li>Client通过执行connect向Server发送一个SYN包，消息序列号seq为随机数A，请求主动打开</li><li>Server收到一个合法的SYN包后，将该包放入SYN队列中，返回一个SYN/ACK，ACK为A+1，消息序列号seq为随机数B</li><li>Client收到SYN/ACK包后，发送一个ACK为B+1的包，消息序列号seq为A+1。然后Client的connect函数返回成功。当Server收到这个ACK包后，把请求帧从SYN队列移出，放到ACCEPT中，如果accept函数处于阻塞状态，可以被唤醒来从ACCEPT中取出ACK包，重新创建一个新的用于双向通信的sockfd，并返回</li></ol><p>三次握手的目的是为了防止已失效的连接请求报文段传送到了服务器，因而产生错误，也为了解决网络中存在延迟的重复分组。例如，Client发出的第一个SYN包没有丢失，而是在某个网络节点长时间的滞留了，以致延误到Client连接释放后的某个时间才到达Server。本来这是一个已失效的报文段，但Server收到后并不知已失效，而是当作Client的连接请求来处理，于是向Client发出确认报文段，同意创建连接。假设不采用三次握手，那么只要Server发出确认，新的连接就在Server创建了。由于Client并没有发出创建连接的请求，因此不会处理Server发过来的确认包，也就不会向Server发送数据。但是在Server端新的传输连接已经创建，并一直等待Client发来数据，这样便会一直占用Server的资源，造成浪费。采用三次握手可以防止这种情况的发生。</p><p>就像你去医院看病一样，你（Client）在大厅挂了一个号（SYN），等到医生（Server）拿到病人的号后，他需要对着等候区喊一声（ACK/SYN）：253号病人在不在？你大声的回一声（ACK）：在！这个时候医生才能给你看病。如果等医生喊的时候，你已经提前有事走了，那么就不用再在你身上花时间了，毕竟医生很忙。两次握手就像是医生拿到病人的号后喊了一声：253号病人该你了，就开始准备相关的资料等你来，但是你已经离开了，医生并不知情，就只能一直等，等一个等不来的人。而四次握手、五次握手，就相当于，在你回答了一声：在，之后医生又问：253号病人在不在？你说：在，医生又问：253号病人在不在？你接着说：在。可以是可以，但没必要。</p><h4 id="插播：seq和ack"><a href="#插播：seq和ack" class="headerlink" title="插播：seq和ack"></a>插播：seq和ack</h4><p>这里插播seq和ack的说明，seq以一个随机数开始，叫做ISN（之所以随机是为了克制TCP序号预测攻击），它是一个32位的无符号数。每个数据包在头信息中都会带着seq和ack，seq表示自己成功发送的数据量，而ack表示自己成功接收的有序字节的最大字节量。这里要用seq和ack减去ISN，这个时候才表示真实数据数量，这个在WireShark里叫做相对seq，relative sequence number。</p><p>这里强调有序是因为存在丢包的情况，比如发送方发了1，2，3，4，5个包，但是包3在路上丢了，所以接收方回复包4和包5的ack都是2。</p><p>seq表示自己成功发送的数据，所以每个包中都是有实际用处的。但是ack并不是在每个包中都会用到，比如建立连接时的第一个包，这个时候连接还未建立，所以谈客户端收到多少来自服务器的数据是没有意义的，因此在标识位用了一个bit来标识ack是否有效。</p><p>ack表示自己成功接收的数据量，每次收到对方的seq后，如果可以正确处理（这里要考虑异常情况，比如上面的丢包情况，这时候则不能正确处理，要等着丢失的包），则更新ack，表示已经成功接收这么多的数据，然后将ack确认回复给发送方。</p><p>seq表示自己成功发送的数据量，每次收到对方的ack后，就会更新自己的seq，表示这么多字节的数据已经成功发送。</p><h4 id="3-2-握手异常情况"><a href="#3-2-握手异常情况" class="headerlink" title="3.2 握手异常情况"></a>3.2 握手异常情况</h4><ol><li><p>客户端第一个SYN包丢了<br>这种情况下，服务器不知道客户端曾经发过包，在TCP协议中，某端的一组请求-应答中，在一定时间范围内，只要没有收到应答的ACK包，无论是请求包对方没有收到，还是对方的应答包自己没有收到，均认为是包丢了，都会触发超时重传机制。所以此时会进入重传SYN包，根据协议，会尝试三次，间隔分别为5.8s，24s，48s，共76s左右，而大多数伯克利系统建立一个连接的最长时间，限制为75s。也就是说，第一个SYN包丢了，会重传，最长重试时间是75s。</p></li><li><p>服务器收到SYN，回复的SYN/ACK包丢了<br>这种情况，从客户端来看，会认为是SYN丢了没发过去，处理方式就是上面1中所说的。对于服务器而言，发送完SYN/ACK后，在超时时间内没有收到ACK包，也会触发重传，此时服务器处于SYN_RCVD状态，依次等待3s，6s，12s后，重新发送SYN/ACK包。<br>这个重传次数，不同的操作系统有不同的配置，Linux中默认重试次数是5次，重试间隔从1s开始倍增，1s，2s，4s，8s，16s，共31s。第5次发送完会等待32s才认为第5次也超时了，所以，一共需要31s+32s=63s，TCP才会断开这个连接。使用TCP的三个参数来调整行为：tcp_synack_retries减少重试次数；tcp_max_syn_backlog 增加SYN连接数量；tcp_abort_on_overflow 决定超出能力时的行为。<br>同时由于客户端没有收到SYN/ACK，也会重传，当客户端重传的SYN被收到后，服务器会立即重新发送SYN/ACK包。</p></li><li><p>客户端最后一次回复的ACK包丢了<br>发送完ACK后，客户端进入ESTABLISHED状态，服务器因为收不到ACK会走重传机制。客户端进入ESTABLISHED状态后，则认为连接已建立，会立即发送数据，但是服务器因为没有收到最后一个ACK，依然处于SYN_RCVD状态。那么，现在的问题是，处于SYN_RCVD的服务器，收到客户端的数据包后如何处理呢？有些资料写，此时服务器会直接回复RST包，表示服务器错误（我都还没建立连接，数据咋都发过来了），并进入CLOSE状态。但是，试想一下，服务器还在通过三次握手确定对方是否真实存在，此时对方的数据已经发过来了，那肯定是存在的。<br>实际情况是，处于ESTABLISHED状态下的客户端，开始发送数据时，会带上ACK，所以即便是一个单独发ACK的包丢了，服务器在收到这个最新的包时，也能通过里面的ACK，正常进入ESTABLISHED状态。</p></li><li><p>客户端故意不发最后的ACK<br>上面几种异常，都是客观因素导致，比如网络环境差等，而这种情况，就是故意而为之了。服务器发送完SYN/ACK后，收不到客户端的ACK，它会认为自己发出去的包丢了，就会走异常2的逻辑，进入重传，根据上面所说我们可以知道，此时这个连接处在服务器在listen时创建的SYN队列中。如果短时间内有大量这样的请求，SYN队列就会被占满，此时再来新的SYN请求，服务器就会自动丢弃，这就是所谓的SYN FLOOD攻击。针对这种情况，现在主要有两种应对方案，<br>一个是syn cookie方案，在收到SYN包后，服务器根据一定的算法，以数据包的源地址、端口号等信息作为参数计算出一个cookie值作为SYN/ACK包的序列号发给客户端，但并不立即分配资源，等到收到ACK包，重新根据数据包的源地址、端口计算该包的确认号是否正确，正确则建立连接，否则丢弃。<br>另一个方案是SYN Proxy防火墙，服务器防火墙会对收到的每一个SYN包进行代理和回应，并保持连接状态，等到发送方将ACK返回后，再重新构造SYN包发送到服务器，建立真正的TCP连接。</p></li></ol><h4 id="3-3-资源使用"><a href="#3-3-资源使用" class="headerlink" title="3.3 资源使用"></a>3.3 资源使用</h4><p>主机收到一个TCP包时，用两端的IP地址和端口号来标识这个TCP包属于哪个session，使用一张表来存储所有的session，表中的每条称作Transmission Control Block（TCB），tcb结构定义包括连接使用的源端口、目的端口、目的ip、序号、应答序号、对方窗口的大小、己方窗口的大小、tcp状态、tcp输入/输出队列，应用层输出队列、tcp的重传有关变量等。对于不能确认的包、接收但还没读取的数据，都会占用系统资源。</p><h4 id="3-4-数据传输"><a href="#3-4-数据传输" class="headerlink" title="3.4 数据传输"></a>3.4 数据传输</h4><p>在TCP的数据传送状态中，很多重要的机制保证了TCP的可靠性和强壮型，它们包括：使用序号，对收到的TCP报文段进行排序以及检测重复的数据，使用校验和检测报文段的错误，即无错传输，使用确认和计时器来检测和纠正丢包或延时，流控制，拥塞控制，丢包重传等。</p><h4 id="3-5-重传机制"><a href="#3-5-重传机制" class="headerlink" title="3.5 重传机制"></a>3.5 重传机制</h4><p>TCP为了实现可靠的传输，实现了重传机制，最基本的重传机制，就是超时重传，即在发送数据报文时，设定一个定时器，到达超时时间后还没有收到应答报文，就会重发该报文，那么这个时间设置多少合适呢？如果比较小，那很有可能数据没有丢失只是慢，就触发重传了，如果设置较大，那就会造成等待过长。一个数据包发出去来回的时间，即数据包的一次往返时间，叫做RTT（Round-Trip Time）。超时重传时间RTO（Retransmission Timeout），一般情况下略大于RTT，意思是在一个来回的时间内还没收到应答，发送发就重发。</p><p>但是，实际情况是，RTO就是在RTT的基础上计算出来的，毕竟由于网络不是稳定不变的，所以RTT也是一直在变的，这个公式，叫做Jacobson/Karels算法，主要利用平滑移动的思想，具体不展开了。</p><p>除了超时重传，还有快速重传机制，毕竟超时重传中每次都要等待RTO后才会触发重传，相比于此，快速重传则是基于接收端反馈的ACK来触发重传，接收方每次的应答包里ACK告知的是最大的有序报文段，当出现某个包丢失时，ACK就会卡在丢失包的前一个包，当发送方连着收到三个重复冗余的ACK后，也就是连着收到四个一样的ACK，就知道这个ACK后面的包丢失了，此时便会触发快速重传，重发丢失报文，而不用等待RTO。但这种方式会有个问题，因为发送方是连着发送多个包给接收方，发送方在收到3个冗余的ACK后，只知道接收方收到的最大有序报文是ACK，但不知道ACK之后有哪些收到了、哪些没收到，那么重传的时候，是只发送ACK后紧邻着的包，还是把ACK后面的所有的包都发一遍呢？</p><p>于是，又有了一种重传方式，带选择的快速重传SACK（Selective)，它的机制就是，在快速重传的基础上，接收端返回最近收到的报文的序列号范围，这样发送方就知道接收方哪些数据没收到，很清楚就能知道需要重传哪些数据了，SACK标记是加在TCP头部的选项字段里面的。</p><p>除此之外，还有一种，D-SACK，Duplicate SACK，即重复SACK，在SACK的基础上做了一些扩展，主要用来告诉发送方，有哪些数据自己重复接受了。目的是帮助发送方判断，是否发生了包失序、ACK丢失、包重复或伪重传，让TCP可以更好的做网络控流。</p><h4 id="3-5-滑动窗口"><a href="#3-5-滑动窗口" class="headerlink" title="3.5 滑动窗口"></a>3.5 滑动窗口</h4><p>TCP发送一个数据，需要收到确认应答后，才会发送下一个数据，这样有个缺点，就是效率比较低。为了解决这个问题，TCP引入了窗口，它是操作系统开辟的一个缓存空间，窗口的大小表示无需等待确认应答，而可以继续发送的数据的最大值。</p><p>TCP头部有个字段叫win，16位，它告诉对方本端的TCP缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到流量控制的目的。直白讲就是，一个包一个包发送太慢，那就多发几个，但是发的太多了，接收方可能处理不了，多出来的就被丢弃了，这样就白发了，所以，接收方在每次返回ACK的时候，顺带告诉发送方自己这边还剩下的窗口大小，这样发送方就可以根据这个窗口大小来决定发送多少数据了。</p><h4 id="3-6-拥塞控制"><a href="#3-6-拥塞控制" class="headerlink" title="3.6 拥塞控制"></a>3.6 拥塞控制</h4><p>拥塞控制是作用于网络的，防止过多的数据注入到网络中，避免出现网络负载过大的情况，它的目标是最大化利用网络上瓶颈链路的带宽。它和流量控制的区别是，流量控制是作用于接收方，根据接收方的实际接受能力控制发送的流量，防止数据段丢失。</p><p>发送方维护一个拥塞窗口（congestion window）的变量，用来估算在一段时间内这条链路可以承载和运输的数据的数量。它的大小代表着网络的拥塞程度，并且是动态变化的，为了达到最大的传输效率，最简单的方法就是不断增加传输的数据量，一直到出现丢包，实际上，拥塞控制主要有这几种算法：慢启动、拥塞避免、拥塞发生和快速恢复。</p><p>慢启动，在TCP建立连接之后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度，由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，每收到一个ACK，就将拥塞窗口cwnd大小加1，单位MSS（max segment size）。每轮次发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。</p><ul><li>TCP连接完成，初始化cwnd=1，表示可以传一个MSS单位大小的数据</li><li>每当收到一个ACK，cwnd就加一</li><li>每当过了一个RTT，因为每个ACK都会加1，所以cwnd就会增加一倍，呈指数增长</li></ul><p>但是，为了防止swnd增长过大引起网络阻塞，还需要设置一个慢启动阈值（slow start threshold）状态变量，当cwnd到达该阈值后，进入拥塞避免算法。一般来说，慢启动阈值是65535字节，cwnd到达阈值后</p><ul><li>每收到一个ACK，cwnd = cwnd + 1 / cwnd</li><li>当每过一个RTT时，cwnd = cwnd + 1，呈线性增长</li></ul><p>当网络拥塞发生丢包时，会出现两种情况</p><ul><li>RTO超时重传</li><li>快速重传<br>如果是RTO超时重传，就会使用拥塞发生算法</li><li>慢启动阈值 = cwnd / 2</li><li>cwnd = 1</li><li>进入新的慢启动过程<br>如果是快速重传</li><li>拥塞窗口cwnd = cwnd / 2</li><li>慢启动阈值= cwnd</li><li>进入快速恢复算法<br>快速重传和快速恢复一般同时使用，快速恢复算法认为，还有3个冗余ACK收到，说明网络也没那么糟糕，所以没有别要想RTO超时那么反应强烈</li><li>cwnd = 慢启动阈值 + 3</li><li>重传重复的那几个ACK（即丢失的那几个数据包）</li><li>如果再收到重复的ACK，那么cwnd = cwnd + 1</li><li>如果收到新的ACK后，cwnd = 慢启动阈值，表明恢复过程结束，再次进入拥塞避免算法，即线性增长</li></ul><h4 id="3-7-Nagle算法和延迟确认"><a href="#3-7-Nagle算法和延迟确认" class="headerlink" title="3.7 Nagle算法和延迟确认"></a>3.7 Nagle算法和延迟确认</h4><p>TCP/IP协议中，无论发送多少数据，总是要在数据钱带上协议头，同时，接收方收到数据，也需要发送ACK确认，为了尽可能利用网络带宽，TCP总是希望尽可能发送足够大的数据，Nagle算法便是为了发送尽可能大的数据块，避免网络中充斥着许多小数据块。基本定义是：任意时刻，最多只能有一个未被确认的小段，小段指的是小于MSS尺寸的数据块，未被确认指的是一个数据块发出去后，没有收到对方发送的ACK确认包。</p><p>延迟确认是指，在接收方收到数据包后，如果暂时没有数据要发给对端，它可以等一段时间再发送确认包（Linux默认是40ms），如果在这段时间内刚好有数据要传给对端，ACK就随着数据包一起传输，如果超时后没有数据要发送，就单独发送ACK，避免对方以为丢包。有些场景不能延迟发送确认，比如出现乱包，要及时发送ACK告知</p><p>一般二者不能同时使用，一个是延迟发送数据包，一个是延迟发送确认，二者一起会造成更大的延迟，产生性能问题。</p><h4 id="3-8-保活定时器"><a href="#3-8-保活定时器" class="headerlink" title="3.8 保活定时器"></a>3.8 保活定时器</h4><p>根据TCPI/IP协议的描述，TCP连接建立后，如果双方都没有通信。连接可以一直保存下去，例如中间路由器崩溃或者中间的某条线路断开，只要两端的主机没有被重启，连接就一直被保持着。TCP是面向连接的，不是说两个主机之间一直存在一个连接，而是在各自的主机上面分配了一些资源，如内存，以及上面提到的session表，来存储对端的一些信息，连接断开，对于端点则是意味着清理掉这些连接信息，释放掉所占用的资源。所以，如果连接中客户端突然掉线，服务器就需要能够感知这种变化，然而，TCP规范中并未规定连接的保活功能。</p><p>尽管TCP协议中未做要求，但是在很多TCP协议的实现中，却提供了保活定时器。保活定时器一般配置的时间是2个小时，即服务器每2个小时就会想客户端发送探查消息，如果收到客户端的反馈消息，则在等2个小时再发，如果等不到反馈，则再等75s再发一次，这样连续发送10次，如果10次都没有收到反馈，就认为客户端异常断开了，此时，TCP层的程序就会向上层应用程序发送一条连接超时的反馈。</p><p>由于TCP的很多实现中，保活定时器的时间比较长（一般大于2个小时），在实际的服务器开发中，很难利用该时间来判断客户端是否断开连接，因此，服务器程序多是在上层自己提供保活功能，常见的有，心跳连接，或者ping/pong消息等。</p><h4 id="3-9-终结通路"><a href="#3-9-终结通路" class="headerlink" title="3.9. 终结通路"></a>3.9. 终结通路</h4><p>连接终止使用了四次挥手过程。</p><ul><li>由客户端发起FIN请求，发出FIN后，客户端从ESTABLISHED进入FIN-WAIT-1状态，wait1，就是在等服务器的ACK</li><li>服务器收到客户端的FIN后，回复ACK，并从ESTABLISHED进入CLOSED-WAIT状态，开始做一些断开连接前的准备工作。客户端收到ACK后，wait1结束，进入到FIN-WAIT-2状态，wait2是在等服务器的FIN</li><li>服务器完成断开准备后，发送FIN/ACK给客户端，请求断开连接，服务器进入LAST-ACK状态，也就是等待最后一个ACK</li><li>客户端收到FIN/ACK后，回复ACK，然后进入TIME_WAIT状态，等待2MSL（max segment lifetime）的等待，之后进入CLOSED状态。服务器收到ACK后进入CLOSED状态</li></ul><p>需要四次挥手的原因在于，双方都需要发送FIN表示可以断开，同时接收对方发的ACK，来保证自己和对端状态正确。而客户端想要断开的时候，服务器不一定准备好，所以服务器回复的ACK和自己要发的FIN没法合并，要先发ACK，等到自己准备好之后再发FIN/ACK，这样一来就是四次了。而握手只需要三次是因为，服务器的ACK和SYN可以合并，这样便减少一次。</p><p>为什么服务器不需要等2MSL，而客户端需要等呢？状态同步是通信的首要基础，服务器给客户端发送了FIN，当它收到客户端发来的ACK时，对于服务器来说，他们双方都知道了服务器要关闭这件事，状态同步了，那么服务器就可以CLOSED。那么对于客户端来说呢，它在发出ACK之后，并不知道服务器是否成功接收，所以有两种可能</p><ul><li>服务器没收到自己发的ACK，那么服务器在等待超时后，会重传FIN</li><li>服务器收到了自己发的ACK，那么服务器会关闭，不会再发任何消息<br>不管哪种情况，客户端都要等，要取两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏的情况是：</li><li>去向ACK消息最大存活时间MSL + 来向FIN消息的最大存活时间MSL<br>也就是客户端需要等待的2MSL。</li></ul><p>如果不等，客户端释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的TCP报文段可能与新TCP连接报文段冲突，造成数据冲突，为避免此种情况，则需要耐心等待网络中老的TCP连接的活跃报文段全部超时无效。</p><h4 id="3-10-四次挥手异常情况"><a href="#3-10-四次挥手异常情况" class="headerlink" title="3.10 四次挥手异常情况"></a>3.10 四次挥手异常情况</h4><ol><li><p>客户端的FIN包丢了<br>这个和前面的SYN包丢失类似，客户端会触发超时重传。对于服务器来说，客户端发来的FIN没有收到，就没有任何感知。会在一段时间后，断开连接。</p></li><li><p>服务器第一次回复ACK包丢了<br>此时客户端没有收到ACK，会触发超时重传FIN，服务器收到后，会立即再重传。而此时，服务器已经处于CLOSED-WAIT状态，开始做断开连接前的准备工作，准备好之后，会发送FIN/ACK，这个消息是带了之前ACK的响应号的。只要这个消息没丢，客户端可以凭借FIN/ACK包中的响应号，直接从FIN-WAIT-1状态进入TIME-WAIT状态，开始2MSL的等待。</p></li><li><p>服务器发的FIN/ACK丢了<br>服务器会在超时后触发重传，此时客户端有两种情况，要么处于FIN-WAIT-1状态（之前的ACK也丢了，wait1是在等ACK，还没等到），要么处于FIN-WAIT-2状态（收到了ACK，在等FIN），收到服务器的重传来的FIN后，发送ACK给服务器，然后开始2MSL的等待。</p></li><li><p>客户端最后的ACK丢了<br>客户端回复ACK后，会进入2MSL的TIME-WAIT等待，服务器因为没有收到ACK，会重试一段时间，直到超时服务器主动断开。在服务器重试的期间内，客户端可能释放了端口，此时如有新的客户端连接服务器，就会收到服务器发的重试消息FIN，这时客户端会回复RST，服务器收到RST后，会复位状态。</p></li><li><p>客户端收到ACK后，服务器掉线了<br>客户端收到ACK后，进入了FIN-WAIT-2状态，等待FIN，如果服务器不在了，那么这个FIN将永远等不到。在TCP协议中，是没有对这个状态的处理机制的，但是操作系统会接管这个状态，例如在Linux下，可以通过tcp_fin_timeout参数，来对这个状态设定一个超时时间。需要注意的是，当超过tcp_fin_timeout的限制后，客户端的状态不是切换到TIME_WAIT，而是直接进入到CLOSED状态</p></li><li><p>客户端收到ACK后，客户端掉线<br>客户端掉线后，服务器发的FIN/ACK就得不到应答，会不断的走超时重传机制，在超过一定时间后，服务器主动断开。如果在重试期间，有新的客户端接入这个连接，发送SYN给服务器，表示想要建立连接，此时这个SYN会被服务器忽略，并直接回复FIN/ACK，新客户端收到FIN/ACK后不会认的，就会给服务器发送RST，服务器收到RST，会复位状态</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;TCP，Transmission Control Protocol，传输控制协议，是众多网络协议中较为重要的一个协议，网上多是写三次握手和四次挥手的，一搜就能看到一片又一片，多数都是CV战士的杰作，CV战士绝不认输，所以这篇文章来全面的说说TCP。&lt;/p&gt;</summary>
    
    
    
    <category term="网络协议" scheme="https://oynix.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="TCP" scheme="https://oynix.github.io/tags/TCP/"/>
    
  </entry>
  
</feed>
