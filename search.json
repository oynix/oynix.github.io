[{"title":"Room的使用","url":"/2021/08/6960a7d25570/","content":"Room是一个数据库，基于SQLite的抽象层，也可以直接使用SQLite，但强烈建议使用Room。\n\n官方文档：[Android Room](https://developer.android.com/training/data-storage/room)\n\n<!--more-->\n\n### 导入依赖\n```groovy\ndependencies {\n    // ..... 其他依赖 .....\n\n    // Room\n    def room_version = \"2.3.0\"\n\n    implementation \"androidx.room:room-runtime:$room_version\"\n    annotationProcessor \"androidx.room:room-compiler:$room_version\"\n\n    // To use Kotlin annotation processing tool (kapt)\n    kapt \"androidx.room:room-compiler:$room_version\"\n}\n```\n\n### 创建表。\nRoom里的表，需要用@Entry注解标注，这里用个简单的学生表\n```kotlin\n// table_name就是表的名字，indecies是可选项，用来生成表的索引\n@Entity(tableName = \"student\", indices = [Index(value = [\"num\"], unique = true)])\ndata class Student(\n    @PrimaryKey val id: Int,\n    val num: Int,\n    val name: String,\n    val age: Int\n)\n```\n\n### 创建数据表访问类。\n这里我们只需要声明接口，并加以@Dao注解标注，具体实现交给Room来做，\n```kotlin\n// 这里只定义CRUD，增删改查，也可根据需要定义其他接口，如查询分数大于某个数值的所有学生\n@Dao\ninterface StudentDao {\n    @Insert\n    fun insert(student: Student): Long\n\n    @Delete\n    fun delete(student: Student): Int\n\n    @Update\n    fun update(student: Student): Int\n\n    @Query(\"SELECT * FROM student WHERE num = :num\")\n    fun query(num: Int): Student?\n}\n```\n\n### 表有了，访问方式也有了，下面创建数据库。\n```kotlin\n// 继承自RoomDatabase，其中已经实现了绝大数功能，我们只需要额外声明几个接口，用来提供Dao数据类\n// 方法的具体实现交给Room来做\n@Database(entities = [Student::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun studentDao(): StudentDao\n}\n```\n\n### 万事俱备，现在可以用了。在Activity里调用下试试看\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // 通过Room提供的Builder创建数据库的实例\n        // 第一个参数是个context，第二个参数是数据库的Class，第三个参数是数据库文件的名字\n        val db = Room.databaseBuilder(this, AppDatabase::class.java, \"app.db\").build()\n\n        // 获得一个Dao\n        val dao = db.studentDao()\n\n        // 添加一条记录\n        dao.insert(Student(1, 1, \"john\", 98))\n    }\n```\n\n### 添加完成，运行一下。\n然后你会发现，崩溃了。。。日志如下：\n```shell\njava.lang.RuntimeException: Unable to start activity ComponentInfo{com.oynix.room.sample/com.oynix.room.sample.MainActivity}: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.\n```\n这句话的意思是说，不能在main thread，也就是主线程访问数据库，因为这样有可能会把页面卡住一段很长的时间。这样的检测机制算是合理的，毕竟这属于IO操作，而IO操作都应该放到单独的线程去跑。\n但是也可以去掉这种检测，在创建数据库的时候额外传入个配置：\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val db = Room.databaseBuilder(this, AppDatabase::class.java, \"app.db\")\n            .allowMainThreadQueries() // 允许在主线程操作\n            .build()\n        val dao = db.studentDao()\n        dao.insert(Student(1, 1, \"john\", 98))\n    }\n```\n这个时候再运行一下，就会发现顺利执行\n\n### 数据库文件\n这个时候，在Android Studio的Device File Explorer中，可以在data/data/{包名}/database目录下发现3个文件，app.db、app.db-shm和app.db-wal，其中.db是数据库文件，另外两个是临时文件。\n把这三个文件导出到电脑桌面，然后用能打开db文件的软件将app.db打开，如SQLite Professional、SQLite Studio等，会看到我们创建的student表，以及表中刚刚插入的那条数据。\n\n### 增加一张表\n这个时候，业务发生调整，我们需要增加一张教师表，如下\n```kotlin\n@Entity(tableName = \"teacher\", indices = [Index(value = [\"num\"], unique = true)])\ndata class Teacher(\n    @PrimaryKey val id: Int,\n    val num: Int, // 教师编号\n    val name: String,\n    val course: String\n)\n\n@Dao\ninterface TeacherDao {\n    @Insert\n    fun insert(teacher: Teacher): Long\n\n    @Delete\n    fun delete(teacher: Teacher): Int\n\n    @Update\n    fun update(teacher: Teacher): Int\n\n    @Query(\"SELECT * FROM teacher WHERE num = :num\")\n    fun query(num: Int): Teacher?\n}\n```\n同时，也要修改数据库类，增加新的教师表实体\n```kotlin\n\n@Database(entities = [Student::class, Teacher::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun studentDao(): StudentDao\n    abstract fun teacherDao(): TeacherDao\n}\n```\n增加一条教师的记录。张老师，他很厉害，会教数学\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val db = Room.databaseBuilder(this, AppDatabase::class.java, \"app.db\")\n            .allowMainThreadQueries()\n            .build()\n        // John，学号：1\n        val dao = db.studentDao()\n        dao.insert(Student(1, 1, \"John\", 14))\n        \n        // 张老师，教数学\n        val teacherDao = db.teacherDao()\n        teacherDao.insert(Teacher(1, 1001, \"Miss Zhang\", \"Math\"))\n    }\n```\n再一运行，发现又报错了。。。\n```shell\njava.lang.RuntimeException: Unable to start activity ComponentInfo{com.oynix.room.sample/com.oynix.room.sample.MainActivity}: java.lang.IllegalStateException: Room cannot verify the data integrity. Looks like you've changed schema but forgot to update the version number. You can simply fix this by increasing the version number.\n```\n这句话的意思是说，数据库的schema，也就是结构发生了改变，但是版本号没有更新，Room不知道怎么处理这些schema的修改，然后就报了个错。\n\n### 数据库升级\n就想刚刚那样，在版本的迭代更新中，常常会有修改数据库结构的情况。在Room中，数据库是通过version号，来管理数据库版本的，每做一次修改，version都要增加，一般增加1，你每次加2也没人能拿你怎么样。我们在创建数据库的同时，还要告诉Room版本更新做了哪些操作，这些需要通过addMigrations来添加。\n只修改schema，而不增加version，程序会崩溃。\n只增加version，而不提供Migration，程序会删除并重建数据库\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val db = Room.databaseBuilder(this, AppDatabase::class.java, \"app.db\")\n            .allowMainThreadQueries()\n            .addMigrations(object : Migration(1, 2){\n                override fun migrate(database: SupportSQLiteDatabase) {\n                    database.execSQL(\"CREATE TABLE IF NOT EXISTS `teacher` (`id` INTEGER NOT NULL, `num` INTEGER NOT NULL, `name` TEXT NOT NULL, `course` TEXT NOT NULL, PRIMARY KEY(`id`))\")\n                    database.execSQL(\"CREATE UNIQUE INDEX IF NOT EXISTS `index_teacher_num` ON `teacher` (`num`)\")\n                }\n            })\n            .build()\n        // 这里要注掉，因为表里已经有了一个id为1的记录了\n        // val dao = db.studentDao()\n        // dao.insert(Student(1, 1, \"John\", 14))\n\n        val teacherDao = db.teacherDao()\n        teacherDao.insert(Teacher(1, 1001, \"Miss Zhang\", \"Math\"))\n    }\n```\n如上，从1到2后，我们新加了一个teacher表，并在表上加了一个索引，那么这么写就可以了。\n如果说，不想写这么长的SQL语句怎么办？也好办，全局搜AppDatabase_Impl.java文件，这里面就是Room已经写好的。\n再次运行，发现没有再崩溃，打开app.db，里面多了一张表，表里有一条刚加的张老师的记录。\n\n### addMigrations\n这里要单独说一说这个方法，程序运行后，如果本地数据库版本和代码里的版本不一致，这个时候这个方法才会派上用场，如果一致则无用。\n先帖下文档里的说明：\n```kotlin\n/**\nAdds a migration to the builder.\nEach Migration has a start and end versions and Room runs these migrations to bring the database to the latest version.\nIf a migration item is missing between current version and the latest version, Room will clear the database and recreate so even if you have no changes between 2 versions, you should still provide a Migration object to the builder.\nA migration can handle more than 1 version (e.g. if you have a faster path to choose when going version 3 to 5 without going to version 4). If Room opens a database at version 3 and latest version is >= 5, Room will use the migration object that can migrate from 3 to 5 instead of 3 to 4 and 4 to 5.\nParams:\nmigrations – The migration object that can modify the database and to the necessary changes.\nReturns:\nThis RoomDatabase.Builder instance.\n*/\n@NonNull\npublic Builder<T> addMigrations(@NonNull Migration... migrations)\n```\n它接收可变参数，即可同时接收多个Migration。每个Migration都有个startVersion，以及一个endVersion，Room将会运行这些Migration，将本地数据库的版本一步步升级到代码里的最新版本。如果缺失当前版本到最新版本的Migration，Room将会清空数据库并重建。所以，即便在两个版本之间没有变化，仍然需要提供一个Migration给builder。\n一个Migration可以处理多个版本，例如，当前是版本3，最新是版本5，你提供了3到4的Migration、4到5的Migration以及3到5的Migration，那么Room就会选择更快的Migration，即3到5，而不是由3到4再到5。\n\n### 数据加密\n虽然Android高版本在数据安全这一块已经提升了很多，未root的手机基本看不到其他应用独立存储空间里的内容，但为了以防万一，可以进一步将数据库文件，也就是app.db，进行加密。\n当前有很多种实现思路，如每次写之前，将数据加密，读之后，将数据解密，等。\n这里介绍个第三方加密库，使用很方便，当然也有缺点，就是包体会变大，因为用到了native库，增大6M左右\n- 引入依赖\n```groovy\n // room cypher maven\nmaven { url \"https://s3.amazonaws.com/repo.commonsware.com\" }\n\n// room cypher\nimplementation \"com.commonsware.cwac:saferoom.x:1.2.1\"\n```\n- 增加Factory，openHeloperFactory，\n```kotlin\n override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val db = Room.databaseBuilder(this, AppDatabase::class.java, \"app.db\")\n            .allowMainThreadQueries()\n            .openHelperFactory(SafeHelperFactory(\"your_database_password\".toCharArray()))\n            .addMigrations(object : Migration(1, 2){\n                override fun migrate(database: SupportSQLiteDatabase) {\n                    database.execSQL(\"CREATE TABLE IF NOT EXISTS `teacher` (`id` INTEGER NOT NULL, `num` INTEGER NOT NULL, `name` TEXT NOT NULL, `course` TEXT NOT NULL, PRIMARY KEY(`id`))\")\n                    database.execSQL(\"CREATE UNIQUE INDEX IF NOT EXISTS `index_teacher_num` ON `teacher` (`num`)\")\n                }\n            })\n            .build()\n//        val dao = db.studentDao()\n//        dao.insert(Student(1, 1, \"John\", 14))\n\n//        val teacherDao = db.teacherDao()\n//        teacherDao.insert(Teacher(1, 1001, \"Miss Zhang\", \"Math\"))\n    }\n```\n- 加密之后，再导出来的app.db就无法打开了\n\n### 总结\n以上，Room的简单使用就这些了，相比于SQLite，简单、方便了不少，本地化数据可以多考虑使用。\n另外还有些更高级的用法，比如和ViewModel的结合、和Hilt的结合、异步操作数据流，等等，这里就就不做说明了。\n\n附上Github地址：[https://github.com/oynix/RoomSample](https://github.com/oynix/RoomSample)","tags":["Android","Kotlin","Room"],"categories":["Android"]},{"title":"管理 MacOS 上的 Python 环境版本","url":"/2021/06/d54bb8006555/","content":"\n### 00.前言\nMacOS 上的 Python不同版本的环境一直是个让人头大的问题，原因在于，系统预先安装了2.7版本，但这是个老版本了，老版本是不能卸载的，一些系统程序都在依赖它。\n\n现在市面上开发的新程序多数在用3.x版本，部分老代码还在用2.x版本，两个大版本还是有些区别的，无法完全兼容，这就让管理多版本共存成了个问题。\n\n当然，也有一些管理工具，如pyenv，但其实python的venv模块已经足够了，下面会简单说一说使用。\n<!--more--> \n### 01.卸载干净\n据不完全统计，目前发现了以下这些还算固定的安装目录：\n\n- 自己安装的Python在这个目录，即通过官网下载的安装程序安装\n/Library/Frameworks/Python.framework\n\n- Python应用目录\n/Applications/Python3.x\n\n- 通过brew命令安装在这个目录，brew是个包管理工具，使用它安装的都在Cellar目录\n/usr/local/Cellar\n\n- 通过CommandLineTools安装在这个目录，这是个Xcode带的工具包\n/Libaray/Developer/CommandLineTools/Library/Frameworks\n\n- 系统预安装的在这个目录，这个看看就行了，不能删\n/System/Library/Frameworks/Python.framework\n\n```sh\n$ which python\n$ which python3\n```\n\n通过这两个命令，找到python可执行程序\n- /usr/local/bin，这个目录下的，可以删除\n- /usr/bin，这个目录下的，想删也删不了，没权限。Catalina以下的通过关闭SIP可以操作/usr/bin目录下的文件，但以上的版本关掉SIP也不行了。我在早年间通过这种方式在/usr/bin目录下放了一个python3的可执行程序，现在升级到了Big Sur版本，导致这个可执行文件删不掉了，除了重装系统，我也没想到什么好办法，暂时就先这么放着。\n\n终端窗口执行python会进入2.7的交互解释环境，执行python3会报错command not found\n```sh\n$ python3\n-bash: python3: command not found\n\n$ which python\n/usr/bin/python\n\n$ python\nWARNING: Python 2.7 is not recommended. \nThis version is included in macOS for compatibility with legacy software. \n```\n\n至此，现在系统里应该只剩下系统预安装的python2.7了，可执行文件在/usr/bin目录，同时/usr/local/bin目录不再有python可执行文件。\n\n### 02.安装最新\n直接用brew安装就好，别再用其他的各路神仙工具了，听我一句劝，不要在意别人怎么怂恿，就用brew就可以了，这个是macOS上最普遍、最通用的包管理工具，用最简单的方式做最大的事，多了不起。\n\n如果不是新买的机器，应该都装了brew工具了，要是没装，那就先装一下，一行代码，等着就好了\n```sh\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n然后，安装python3，一行代码，还是等着就好了，python3有多个版本，3.6、3.7、3.8以及最新的3.9，不指定版本会默认安装最新，如果有需要，可以指定版本：python@3.x，如果同时存在多个3.x，要注意名字的区分\n```sh\n$ brew install python3\n```\n\n这里唠叨几句pip，pip是python的包管理工具，前身是easy_install，这两者的关系是，python是可执行文件，pip是python的一个模块，可有也可无，非必需，建议还是用pip，毕竟其他方式管理包很麻烦。如果意外把pip删除了也可以单独安装\n\n```sh\n# 安装\n$ python3 -m ensurepip\n$ python3 -m pip install pip --upgrade\n# 目标位置\n$ which pip\n/usr/local/bin/pip\n# 卸载\n$ python3 -m pip uninstall pip\n\n# 默认会安装这个三个，再安装用pip install {package}即可\n$ pip list -v\npip          21.1.2    /usr/local/lib/python3.9/site-packages     pip\nsetuptools   57.0.0    /usr/local/lib/python3.9/site-packages     pip\nwheel        0.36.2    /usr/local/lib/python3.9/site-packages     pip\n```\n\n一个pip关联一个python可执行文件，像上面这样，就是将pip关联到了python3，通过这个pip安装的包只有python3可调用到，系统自带的python调用不到，如果有需要，也可以为系统python可执行文件也装个pip工具，但要注意名字的区分\n\n```sh\n# 安装\n$ python -m ensurepip\n# python是系统自带的，但没有操作系统目录的权限，所以需要加上--user\n$ python -m pip install pip --upgrade --user\n# --user后会安装到当前用户目录库下，我的在这\n$ cd /Users/{username}/Library/Python/2.7/bin\n# 然后在pip同样的位置创建一个软连接就可以了\n$ ln -s /Users/{username}/Library/Python/2.7/bin/pip /usr/local/bin/pip2\n# 目标位置\n$ which pip2\n/usr/local/bin\n\n# 卸载\npython -m pip uninstall\n\n# 这个就比较多了，而且都在系统目录里，咱也操作不了\n# 再安装要加--user，这样会安装到当前用户目录库文件下: pip2 install {package} --user\n# /Users/{username}/Library/Python/2.7/lib/python/site-packages\n$ pip2 list -v\naltgraph   0.10.2  /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python\nasn1crypto 0.24.0  /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python\nbdist-mpkg 0.5.0   /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python\nbonjour-py 0.3     /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python\n```\n\n### 03.日常使用\n日常使用是通过venv模块，一般一个项目使用一个venv环境，互相独立、互不干扰。\n\n这种模式，就像是在一座大房子（机器）里可以建造很多不同类型（版本）的小房间（虚拟环境），每个小房间（虚拟环境）里的操作的影响范围只限于在这个房间（虚拟环境）内，各个房间（虚拟环境）互相独立互不影响，房间（虚拟环境）可以随时创建（新建）和拆除（删除）。\n\n```sh\n# 切换到项目的根目录下\n$ cd PyProj\n\n# 创建一个venv环境，第二个参数venvDir是环境目录的名称，一般使用venv，可随意，合法即可\n$ python3 -m venv venvDir\n\n# 查看虚拟环境，可看到如下内容\n$ ls -l venvDir\ndrwxr-xr-x  12 username  staff  384 Jun  8 23:44 bin\ndrwxr-xr-x   2 username  staff   64 Jun  8 23:44 include\ndrwxr-xr-x   3 username  staff   96 Jun  8 23:44 lib\n-rw-r--r--   1 username  staff   90 Jun  8 23:44 pyvenv.cfg\n\n# 激活当前venv环境，之后每行前面会多个(venvDir)，表示在该环境中\n$ source venvDir/bin/activate\n\n# 查看python可执行文件位置，此时在虚拟环境中，只有一个python，所以不要再输入python3\n(venvDir)$ which python\nPyPorj/venvDir/bin/python\n\n# 查看pip\n(venvDir)$ which pip\nPyPorj/venvDir/bin/pip\n\n# 此时的python可执行程序和pip可执行程序只在当前环境内有效，若要退出当前环境则执行\n(venvDir)$ deactivate\n```\n\n### 04.附录\n- 查看pip版本\n```sh\n$ pip -V\n```\n\n- 用pip安装package时，加上--user参数，会安装到当前用户的库目录中，只对当前用户有效，不加--user会安装到全局目录，对所有用户有效。如果你的电脑只有一个用户，那么二者没有区别\n```sh\n$ pip install --user\n～/Library/Python/3.9/lib/python/site-packages/\n\n$ pip install\n/usr/local/lib/python3.9/site-packages/\n```\n\n- brew安装目录\n/usr/local/Cellar\nHomebrew配置目录\n/usr/lcoal/etc\nHomebrew命令目录\n/usr/local/bin\n\n- brew常用命令\nbrew install FORMULA\nbrew cleanup\nbew searh FORMULA\nbrew info FORMULA\nbrew upgrade FORMULA\nbrew update","tags":["Python","MacOS"],"categories":["Python"]},{"title":"CircleImageView","url":"/2020/02/c0c9e38ff81e/","content":"\nAndroid 系统默认的 ImageView 是矩形，但有时页面上需要展示圆形的图片，如头像。这里提供一种最简单的实现思路。\n\n<!--more-->\n将圆形遮罩当作目标（DST），图片当作源（SRC）\n先画的是destination，后画的是source\n\n```java\npublic class CircleImageView extends AppCompatImageView {\n\n    private Paint mPaint;\n    private Xfermode mXfermodeDstOut;\n    private Path mPath;\n\n    public CircleImageView(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    private void init() {\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.FILTER_BITMAP_FLAG);\n        mPaint.setStyle(Paint.Style.FILL);\n        mXfermodeDstOut = new PorterDuffXfermode(PorterDuff.Mode.DST_OUT);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        if (mPath == null) {\n            int w = getWidth();\n            int h = getHeight();\n            int cx = w / 2;\n            int cy = h / 2;\n            mPath = new Path();\n            mPath.moveTo(0, 0);\n            mPath.lineTo(w, 0);\n            mPath.lineTo(w, h);\n            mPath.lineTo(0, h);\n            mPath.addCircle(cx, cy, Math.min(cx, cy), Path.Direction.CCW);\n        }\n        canvas.saveLayer(0, 0, getWidth(), getHeight(), mPaint, Canvas.ALL_SAVE_FLAG);\n        super.onDraw(canvas);\n        mPaint.setXfermode(mXfermodeDstOut);\n        canvas.drawPath(mPath, mPaint);\n        mPaint.setXfermode(null);\n        canvas.restore();\n    }\n}\n```\n[源文件](https://github.com/oynix/widgetlib/blob/master/widget/src/main/java/com/oynix/widget/CircleImageView.java)","tags":["Android","Widget","CircleImageView"],"categories":["Android"]},{"title":"Paint常用方法说明","url":"/2020/02/bcaaeeb315b6/","content":"\n# Paint常用方法说明\n\n[原文地址](https://blog.csdn.net/aigestudio/article/details/41316141)，写的很详细并且有趣。这里只挑出一些常用的，难于理解的，单独拿出来做个笔记。\n\n<!--more-->\n\n## setAntiAlias(boolean aa)\n\n设置抗锯齿。也可以在 new 的时候传入 Paint.ANTI_ALIAS_FLAG。\n\n## setColorFilter(ColorFilter filter)\n\n类 ColorFilter 没有具体实现，它有三个子类：\n\n### ColorMatricColorFilter\n\n矩阵颜色过滤器，在 Android 中图片是以 RGBA 像素点的形式加载到内存中的，修改这些橡塑信息需要一个 ColorMatrix 类的支持，其定义了一个 4x5 的 float[] 类型的矩阵：\n\n```java\nColorMatrix colorMatric = new ColorMatrix(new float[]{\n  1, 0, 0, 0, 0,// R\n  0, 1, 0, 0, 0,// G\n  0, 0, 1, 0, 0,// B\n  0, 0, 0, 1, 0,// A\n});\n```\n\n其中，第一行表示 R(红色) 的向量，第二行表示 G(红色) 的向量，第三行表示 B(蓝色) 的向量，最后一行表示 A(透明度) 的向量，这一顺序是固定的，不可改变。每一行的前 4 个值表示的是 RGBA 的值，其范围在 0.0F 至 2.0F 之间，1 为保持原图的 RGB 的值。每一行的第 5 个表示偏移值，想让颜色更倾向于某个颜色时，就增加该颜色的偏移值。\n\n> 何为偏移值？顾名思义当我们想让颜色更倾向于红色的时候就增大R向量中的偏移值，想让颜色更倾向于蓝色的时候就增大B向量中的偏移值，这是最最朴素的理解，但是事实上色彩偏移的概念是基于白平衡来理解的，什么是白平衡呢？说得简单点就是白色是什么颜色！如果大家是个单反爱好者或者会些PS就会很容易理解这个概念，在单反的设置参数中有个色彩偏移，其定义的就是白平衡的色彩偏移值，就是当你去拍一张照片的时候白色是什么颜色的，在正常情况下白色是（255, 255, 255, 255）但是现实世界中我们是无法找到这样的纯白物体的，所以在我们用单反拍照之前就会拿一个我们认为是白色的物体让相机记录这个物体的颜色作为白色，然后拍摄时整张照片的颜色都会依据这个定义的白色来偏移！而这个我们定义的“白色”（比如：255, 253, 251, 247）和纯白（255, 255, 255, 255）之间的偏移值（0, 2, 4, 8）我们称之为白平衡的色彩偏移。\n\nColorMetrix 类里面提供一些实在的方法，如 setSaturation(float sat) 设置饱和度。\n\n### LighingColorFilter\n\n光照颜色过滤，该类只有一个构造方法：\n\n```java\nLightingColorFilter(int mul, int add)\n```\n\n其中 mul 的全称是 colorMultiply 意为色彩倍增，add 全称是 colorAdd 意为色彩增加，这两个值都是 16 进制的色彩值 0xAARRGGBB。\n\n### PorterDuffColorFilter\n\n同 LightingColorFilter 一样，只有一个构造方法：\n\n```java\nPorterDuffColorFilter(int color, PorterDuff.Mode mode)\n```\n\n接受两个值，一个是 16 进制的颜色值，另一个是 PorterDuff 内部类 Mode 中的常量值，表示混合模式。Mode 不仅仅应用于色彩混合，还应用于图形混合，如果在 PorterDuffColorFilter 中强行设置图形混合的模式，将不会看到任何对应的效果。\n\n## setXfermode(Xfermode xfermode)\n\nXfermode，可以直接理解为图像混合模式，它没有具体实现，但有 3 个子类，这 3 个子类实现的功能比 setColorFilter 的 3 个子类复杂\n\n### AvoidXfermode\n\n这个 API 因为不支持硬件加速所以在 API 16 已经过时了，如果想在高于 16 的机器上使用，必须关闭硬件加速，可以在 [HardwareAccelerate](https://developer.android.com/guide/topics/graphics/hardware-accel.html) 文档中查看如何关闭硬件加速，以及查看更多不支持硬件加速的 API。\n\nAvoidXfermode 只有一个含参的构造方法：\n\n```java\nAvoidXfermode(int opColor, int tolerance, AvoidXfermode.Mode mode)\n```\n\n具体实现和 ColorFilter 一样都被封装在 C/C++ 内，我们只管调用就好。第一个参数 opColor 表示一个 16 进制的可以带透明通道的颜色值，第二个参数 tolerance 表示容差值，可以理解为一个标识「精确」或「模糊」的东西，最后一个参数 AvoidXfermode 表示具体模式，可选值只有两个：AvoidXfermode.Mode.AVOID 或 AvoidXfermode.Mode.TARGET\n\n#### AvoidXfermode.Mode.TARGET\n\n在该模式下 Android 会判断画布上的颜色是否有跟 opColor 一样的颜色，比如 opColor 是红色，TARGET 模式下就会判断画布上是否有存在红色的地方，如果有则把该区域「染」上一层画笔定义的颜色，否则不「染」色，而 tolerance 容差值则表示画布上的像素和 opColor 之间的差别是多少的时候才去「染」，比如当前画布有一个像素的色值是(200, 20, 13)，而 opColore 是 (255, 0, 0)，当 tolerance 容差值为 255 时，即便(200, 20, 13)并不等于 opColor 也会被染色，容差值越大「染」色范围越广。\n\n#### AvoidXfermode.Mode.AVOID\n\n与 TARGET 恰恰相反，TARGET 是与 opColor 与画布颜色一样，而 AVOID 是 opColor 与 画布颜色不一样，其他的都类似。\n\n### PixelXorXfermode\n\n与 AvoidXfermode 一样也在 API 16 过时了，该类也提供了一个含参的构造方法\n\n```java\nPixelXorXfermode(int opColor)\n```\n\n该类的计算实现很简单，从官方给出的计算公式来看就是：op^src^dst，像素色值按位异或运算\n\n### PorterDuffXfermode\n\nXfermode的最后一个子类也是唯一一个没有过时切沿用至今的子类。该类同样只有一个构造方法：\n\n```\nPorterDuffXfermode(PorterDuff.Mode mode)\n```\n\n其中的 PorterDuff.Mode 和上面讲的 ColorFilter 用到的 PorterDuff.Mode 是一样的。PorterDuffXfermode 就是图形混合模式的意思，其概念最早来自 SIGGRAPH 的 Tomas Porter 和 Tom Duff，名字就是这两个人的名字的组合\n\n![](https://i.loli.net/2021/07/19/ALKqGnE3UshgClQ.jpg)\n\n这张图片从一定程度上形象地说明了图形混合的作用，两个图形一圆一方通过一定的计算产生不同的组合效果，在 API 中 Android 提供了 18 种（比上图多了两种 ADD 和 OVERPLAY）模式：\n\n![](https://i.loli.net/2021/07/19/3kGpPcMVwu7XaxL.jpg)\n\nSa 全称 Source Alpha，Sc 全称 Source Color，Da 全称 Destination Alpha，Dc 全称 Destination Color。每个中括号由两个值组成：[Alpha, Color]。\n\nSource 为源图像，意为将要绘制的图像；Destination 为目标图像，意为将源图像绘制到的图像。简单理解，先绘制的是 dst，后绘制的是 src。\n\n#### 总结\n\nOVER：谁在上谁在下的问题\n\nIN：绘制相交部分，SRC_IN绘制SRC，DST_IN绘制DST\n\nOUT：绘制不相交部分，SRC_OUT绘制SRC，DST_OUT绘制DST\n\nATOP：SRC_ATOP只绘制SRC中相交部分，DST_ATOP只绘制DST中相交部分\n\n## setDither(boolean dither)\n\n设置绘制图像时的抗抖动，也称为递色\n\n放大来看，其在很多相邻像素之间插入了一个中间值，使颜色过渡变得些许柔和\n\n## setMaskFilter(MaskFilter maskFilter)\n\nMaskFilter 类中没有任何实现方法，它有两个子类 BlurMaskFilter 和 EmbossMaskFilter，前者为模糊遮罩滤镜，而后者为浮雕遮罩滤镜，不支持硬件加速\n\n### BlurMaskFilter\n\n只有一个含参的都早方法\n\n```java\nBlurMaskFilter(float radisu, BlurMaskFilter.Blur style)\n```\n\n其中 radius 表示阴影半径，值越大越扩散。第二个参数 style 表示模糊类型，有四种选择：SOLD 效果是在图像的 Alpha 边界产生一层与 Paint 颜色一致的阴影效果而不影响图像本身；NORMAL 会将整个图像模糊掉；OUTER 会在 Alpha 边界外产生一层阴影且会将原本的图像变得透明；INNER 则会在图像内部产生模糊，很少用\n\n如上所说 BlurMaskFilter 是根据 Alpha 通道的边界来计算模糊的，如果是一张图片（注：Android 会把复制到资源目录的图片转为 RGB565）你会发现没有任何效果，那么如何给图片加一个类似阴影的效果呢？其实很简单，可以尝试从 Bitmap 中获取其 Alpha 通道，并在绘制 Bitmap 前先以该 Alpha 通道绘制一个模糊就可以了\n\n```java\npublic class BlurMaskFilterView extends View {\n\tprivate Paint shadowPaint;// 画笔\n\tprivate Context mContext;// 上下文环境引用\n\tprivate Bitmap srcBitmap, shadowBitmap;// 位图和阴影位图\n \n\tprivate int x, y;// 位图绘制时左上角的起点坐标\n \n\tpublic BlurMaskFilterView(Context context) {\n\t\tthis(context, null);\n\t}\n \n\tpublic BlurMaskFilterView(Context context, AttributeSet attrs) {\n\t\tsuper(context, attrs);\n\t\tmContext = context;\n\t\t// 记得设置模式为SOFTWARE\n\t\tsetLayerType(LAYER_TYPE_SOFTWARE, null);\n \n\t\t// 初始化画笔\n\t\tinitPaint();\n \n\t\t// 初始化资源\n\t\tinitRes(context);\n\t}\n \n\t/**\n\t * 初始化画笔\n\t */\n\tprivate void initPaint() {\n\t\t// 实例化画笔\n\t\tshadowPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);\n\t\tshadowPaint.setColor(Color.DKGRAY);\n\t\tshadowPaint.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.NORMAL));\n\t}\n \n\t/**\n\t * 初始化资源\n\t */\n\tprivate void initRes(Context context) {\n\t\t// 获取位图\n\t\tsrcBitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.a);\n \n\t\t// 获取位图的Alpha通道图\n\t\tshadowBitmap = srcBitmap.extractAlpha();\n \n\t\t/*\n\t\t * 计算位图绘制时左上角的坐标使其位于屏幕中心\n\t\t */\n\t\tx = MeasureUtil.getScreenSize((Activity) mContext)[0] / 2 - srcBitmap.getWidth() / 2;\n\t\ty = MeasureUtil.getScreenSize((Activity) mContext)[1] / 2 - srcBitmap.getHeight() / 2;\n\t}\n \n\t@Override\n\tprotected void onDraw(Canvas canvas) {\n\t\tsuper.onDraw(canvas);\n\t\t// 先绘制阴影\n\t\tcanvas.drawBitmap(shadowBitmap, x, y, shadowPaint);\n \n\t\t// 再绘制位图\n\t\tcanvas.drawBitmap(srcBitmap, x, y, null);\n\t}\n}\n```\n\n## setPathEffect(PathEffect effect)\n\nPathEffect 很明显就是路径效果的意思，其一共有六个子类，效果如下\n\n![](https://i.loli.net/2021/07/19/MUrCkB97ZFY8Hya.jpg)\n\n从上到下：未设置PathEffect，CornerPathEffect，DiscretePathEffect，DashPathEffect，PathDashPathEffect，ComposePathEffect，SumPathEffect\n\n## setStrokeCap(Paint.Cap cap)\n\n设置画笔笔触风格，ROUND，SQUARE 和 BUTT\n\n##setStrokeJoin(Paint.Join join)\n\n设置结合处的形态\n\n## setShadowLayer(float radius, float dx, float dy, int shadowColor)\n\n为绘制的图形添加一个阴影层效果，不支持硬件加速\n\n## setShader(Shader shader)\n\n着色器，有五个子类\n\n### BitmapShader\n\n只有一个含参的构造方法，其他 4 个子类都有两个\n\n```java\nBitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY)\n```\n\nShader.TileMode 有三种：CLAMP 拉伸，MIRROR 镜像和 REPEAT 重复\n\n### LinearGradient\n\n线性渐变\n\n```java\nLinearGradient(float x0, float y0, float x1, float y1, int color0, int color1, Shader.TileMode tile)\n```\n\n(x0, y0) 渐变的起点，(x1, y1) 渐变的终点，color0 起点颜色，color1 终点颜色\n\n```java\nLinearGradient(float x0, float y0, float x1, float y1, int[] colors, float[] positions, Shader.TileMode tile)\n```\n\ncolors 表示支持多个颜色，positons 表示各个颜色的分界位置，如 {Color.RED, Color.GREEN, Color.BLUE}，{0, 0.3F, 0.8F}，positions 为null 时均分渐变区域\n\n### SweepGradient\n\n梯度渐变，也称扫描式渐变，累死雷达扫描效果\n\n```java\nSweepGradient(float cx, float cy, int color0, int color1)\n\nSweepGradient(float cx, float cy, int[] colors, float[] positons)\n```\n\n同 LinearGradient\n\n### RadialGradient\n\n径向渐变，从圆心中心向四周渐变的效果，构造方法就先写一个，同上\n\n```java\nRadialGradient(float cx, float cy, float radius, int centerColor, int edgeColor, Shader.TileMode tile);\n```\n\n### ComposeShader\n\n组合 Shader\n\n```java\nComposeShasdr(Shader s0, Shader s1, Xfermode mode);\nComposeShader(Shader s0, Shader s1, PorterDuff.Mode mode)\n```\n\n## Metrix\n\n3 x 3 坐标矩阵，初始值:\n\n```java\nnew float[]{\n  1, 0, 0, // x\n  0, 1, 0, // y\n  0, 0, 1, // 1\n}\n```\n\n第一列表示 x 轴方向缩放，第二列表示 y 轴方向缩放，第三列表示偏移\n\n### setTranslate scale\n### preTranslate scale\n### postTranslate scale\n常应用于中心缩放\n```java\nmatrix.setScale(interpolatedTime, interpolatedTime);\nmatrix.preTranslate(-centerX, -centerY);\nmatrix.postTranslate(centerX, centerY);\n```\n","tags":["Android","Paint"],"categories":["Android"]},{"title":"Flask API 单元测试 unittest，mock && patch","url":"/2019/12/97c306187ae6/","content":"\n单元测试，主要是为了测试某个方法，或是某个代码快，对于各种输入的处理，输出是否符合预期。但由于其他库、或模块的依赖，以至于很难独立测试我们自己实现的逻辑代码。\n\n对此，引出 mock。\n<!--more--> \n## 一、Flask\n**Flask**是个轻量 API 框架，使用起来非常容易上手\n```python\n# 安装：pip install flask\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Hello Flask'\n\napp.run(port=5000)\n```\n这样，一个简单的 server 就跑起来了，访问 **http:localhost:5000** 便可以看到返回的数据：**Hello Flask**\n\n下面举例说明，如果对单一的接口写测试用例\n\n## 二、举例：用户登录\n1. 用户登录是个常见的功能接口，接口逻辑之外的部分基本同上，这里省略不写。用户使用 **name** 和 **password** 进行登陆操作，服务器收到请求后，根据 **name** 从数据库查询 **password** ，一致则返回 **200 OK**，不一致返回 **400 Bad Request**，很简单的实现，如下：\n\t```python\n\tfrom flask import request\n\tfrom app.model import UserDB\n\t\n\t@app.route('/login')\n\tdef login():\n\t    name = request.args.get('name')\n\t    if not name:\n\t        return 'name is required', 400\n\t   \n\t    password = request.args.get('password')\n\t    if not password:\n\t        return 'password is required', 400\n\t  \n\t    # 从数据库获取用户数据\n\t    user = UserDB.get_user(name)\n\t    if user.get('password') == password:\n\t        return 'OK', 200\n\t    else:\n\t        return 'password is wrong', 400\n\t```\n    其中 **UserDB** 为数据模块中，从数据库查询用户数据的类。这里对于**登录逻辑**的单元测试，只指测试该部分最小的代码块，对于代码块中引入的依赖，在测试时都认为是正常的。例如，在测试 **login()** 的时候，我们认为 **UserDB** 是正常的、可用的，至于 **UserDB** 的可靠性，需要 **UserDB** 模块的单元测试来保障。\n    对于待测试模块内引入的依赖，采用 **mock** 的方式模拟。\n2. **Flask** 的单元测试，先看代码\n\t```python\n\timport unittest\n\tfrom unittest.mock import Mock\n\tfrom unittest.mock import patch\n\t# 该app为创建的Flask实例\n\tfrom application import app\n\t\n\tfrom app.model import UserDB\n\t\n\tclass LoginTestCase(unittest.TestCase):\n\t  \n\t    def setUp(self):\n\t        # push一个上下文，便可以使用flask中的全局变量，如g\n\t        app.app_context().push()\n\t        app.testing = True\n\t        # 测试用的http client\n\t        self.client = app.test_client()\n\t    \n\t    def test_login_success(self):\n\t        # 真实请求中的url，host和port可省略\n\t        url = '/login?name=flask&password=flaskpassword'\n\t        # 模拟的方法名称，也可直接写字符串： get_user\n\t        func_name = UserDB.get_user.__name__\n\t        # 模拟的方法，不管请求参数是什么，都会返回return_value的值（Mock还有其他用法）\n\t        mock_func = Mock(return_value={'name': 'flask', 'password': 'flaskpassword'})\n\t        # patch意为，当UserDB的get_user方法被调用时，用mock出来的func来处理\n\t        # 而mock的func，不管请求参数，都会返回return_value\n\t        # 故而，只要UserDB的get_user被调用，都会返回{'name': 'flask', 'password': 'flaskpassword'}\n\t        # with，表示这种处理方式的作用范围\n\t        # 当在with的范围之外时，调用UserDB的get_user不受mock影响，会正常调用\n\t        with patch.object(UserDB, func_name, func):\n\t            # response为返回的响应\n\t            response = self.client.get(url)\n\t            # 因为传入的name和password，和UserDB的mock func返回的name和password相同\n\t            # 所以，该请求会返回200\n\t            # assertEqual意为，认定返回码与200相等，若不等则该用例不通过\n\t            self.assertEqual(response.status_code, 200)\n\t       \n\t    def test_login_failed(self):\n\t        # 测试传入错误密码的情况\n\t        url = '/login?name=flask&password=wrongpassword'\n\t        func_name = UserDB.get_user.__name__\n\t        mock_func = Mock(return_value={'name': 'flask', 'password': 'flaskpassword'})\n\t        with patch.object(UserDB, func_name, func):\n\t            response = self.client.get(url)\n\t            # 因为传入密码错误，所以在此我们认定返回码是400\n\t            self.assertEqual(response.status_code, 400)\n\t```\n\n此外，还可以对测试缺少参数，这里不再赘述。这样，便可对接口的各种情况进行测试了。\n","tags":["Flask","Python"],"categories":["Flask"]},{"title":"React - Webpack 项目脚手架搭建","url":"/2019/11/05d3ed0e9549/","content":"\n> 把手还是伸向了前端，抽空折腾了几天，算是理清了起步门槛。\n<!--more--> \n##### 一、首先确保安装了 npm，如果没装....那就想办法装上\n```sh\n$ npm\nUsage: npm <command>\n\nwhere <command> is one of:\n    access, adduser, bin, bugs, c, cache, completion, config,\n    ddp, dedupe, deprecate, dist-tag, docs, doctor, edit,\n    explore, get, help, help-search, i, init, install,\n    install-test, it, link, list, ln, login, logout, ls,\n    outdated, owner, pack, ping, prefix, profile, prune,\n    publish, rb, rebuild, repo, restart, root, run, run-script,\n    s, se, search, set, shrinkwrap, star, stars, start, stop, t,\n    team, test, token, tst, un, uninstall, unpublish, unstar,\n    up, update, v, version, view, whoami\n\nnpm <command> -h     quick help on <command>\nnpm -l           display full usage info\nnpm help <term>  search for help on <term>\nnpm help npm     involved overview\n\nSpecify configs in the ini-formatted file:\n    /Users/xiaoyu/.npmrc\nor on the command line via: npm <command> --key value\nConfig info can be viewed via: npm help config\n\nnpm@5.6.0 /usr/local/lib/node_modules/npm\n```\n##### 二、安装 create-react-app。如果用 WebStorm，可以跳过这一步。\n> IDE 可以选择创建 React App，省去了手动执行，所以创建后的目录内容是一样的。\n```sh\n// -g : global\n$ npm install create-react-app -g\n/usr/local/bin/create-react-app -> /usr/local/lib/node_modules/create-react-app/index.js\n+ create-react-app@3.2.0\nadded 91 packages in 24.685s\n\n$ create-react-app\nPlease specify the project directory:\n  create-react-app <project-directory>\n\nFor example:\n  create-react-app my-react-app\n\nRun create-react-app --help to see all options.\n```\n如介绍所言，创建一个app，名字任意，合法即可\n```sh\n$ create-react-app my-react-app\n```\n项目结构如下：\n```sh\n$ ls my-react-app\nREADME.md\t\t    package-lock.json\tpublic\nnode_modules\t\tpackage.json\t\tsrc\n```\n- README.md : 你懂的\n- node_moudles : 依赖都在找个目录下\n- package.json : npm的配置文件，或者说是项目的配置文件\n- package-lock.json : 锁定版本号\n- public : 存放静态资源\n- src :  代码／资源\n\n#### 三、安装 webpack 全家桶\n> npm install 参数说明：package.json 有几个依赖节点，`dependencies` 、 `devDependencies` 和 `optionalDependencies`，前者会随着项目发布出去；后者顾名思义，只在开发时使用；后后者为可选阶段\n>  - - - - - - - \n> -S， --save ：依赖添加到 `dependencies` 节点，\n> -D，--save-dev ：依赖添加到 `devDependencies` 节点\n> -O，--save-optional ：依赖添加到  `optionalDependencies` 节点\n\n以下命令，在项目根目录下执行\n```sh\n// 也可以放在一行执行\n$ npm install webpack -D\n$ npm install webpack-cli -D\n$ npm install webpack-dev-server -D\n```\n**注意，这里有个坑：这三个依赖的版本号一定要相互匹配，如果你要指定版本，一定要确认指定的版本号是行不通的，不然就会报错。都用最新版，目前一切正常。**\n\n#### 四、配置 webpack server\n鉴于 webpack 可用于本地 server，也可用于打包，各自使用不同的配置文件。在项目根目录创建个文件夹 `wepack`，用于存放 webpack 配置文件。\n1. webpack/webpack.config.js，用于开发 server\n```js\nconst path = require('path');\nconst webpack = require('webpack');\nconst __repo = path.dirname(__dirname);\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: { // 程序唯一入口\n        'index': path.resolve(__repo, 'src/index.jsx'),\n    },\n    mode: 'development',\n    output: { // 打包文件输出位置\n        path: path.resolve(__repo, \"build\"),\n        filename: \"bundle.js\",\n        publicPath: \"/\"\n    },\n    devServer: {\n        contentBase: [path.join(__repo, 'public'),], // 本地服务器索价在的页面所在目录\n        compress: false,\n        port: 7788, // server 使用端口\n        disableHostCheck: true,\n        inline: true, // 实时刷新\n        historyApiFallback: true, // 不跳转\n        hot: true\n    },\n    module: {\n        rules: [\n            {\n                test: /(\\.jsx|\\.js)$/, // 匹配所护理文件的扩展名正则表达式\n                exclude: /(node_modules|bower_components)/, // 手动添加／屏蔽的文件\n                use: {\n                    loader: 'babel-loader', // loader名称\n                }\n            },\n            {\n                test: /\\.(css|styl)$/,\n                use: [\n                    {\n                        loader: 'style-loader'\n                    },\n                    {\n                        loader: 'css-loader'\n                    }\n                 ]\n            },\n            {\n                test: /\\.html$/,\n                use: [\n                    {loader: 'html-loader'}\n                ]\n            },\n            {\n                test: /\\.(gif|jpg|png|svg|ttf|eot|woff|woff2)$/,\n                use : {\n                    loader: 'file-loader?name=fonts/[name].[ext]'\n                }\n            },\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            filename: 'index.html',\n            template: 'public/index.html'\n        })\n    ]\n};\n```\n其中的 `module`，就是 webpack 的 loader，都是用来打包用的：\n- **babel-loader**：打包jsx、js文件，转化成浏览器认识的格式，因该loader配置选项较多，一般单抽取出独立的文件`.bebelrc`，放在项目根目录，webpack可以自动识别到\n- **css-loader**，**style-loader**：打包css、style文件\n- **html-loader**：打包html文件\n- **file-loader**：打包其他格式文件，如配置中所写\n\n**.babelrc 内容如下：**\n```json\n{\n  \"presets\": [\"@babel/preset-react\", \"@babel/preset-env\"], // 支持的编码\n  \"plugins\": [\n    \"@babel/plugin-transform-runtime\"\n  ]\n}\n```\n其中，所有的loader、plugin，都需要手动安装\n```shell\n$ npm install -D babel-core babel-loader css-loader style-loader html-loader file-loader\n\n$ npm install -D @babel/preset-env @babel/preset-react @babel/plugin-transform-runtime html-webpack-plugin\n```\n2. 配置 package.json，使用webpack/webpack.config.js。修改 package.json 中的`scripts` 节点，如下：\n```json\n\"dev\": \"webpack-dev-server --config webpack/webpack.config.js\"\n```\n此时，在项目根目录下执行该命令，即可。\n\n```sh\n$ npm run dev\n```\n\n#### 五、配置 webpack 打包配置\n和 server 类似，这里直接贴上配置文件\n1. **webpack/webpack.config.build.js**\n\n```js\nconst path = require('path');\nconst webpack = require('webpack');\nconst __repo = path.dirname(__dirname);\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    mode: \"production\",\n    entry: path.resolve(__repo, 'src/index.jsx'),\n    devtool: \"#source-map\",\n    output: {\n        path: path.resolve(__repo, \"dist\"),\n        filename: \"app/[name].bundle.js\",\n        publicPath: \"/\"\n    },\n    module: {\n        rules: [\n            {\n                test: /(\\.jsx|\\.js)$/, // 匹配所护理文件的扩展名正则表达式\n                exclude: /(node_modules|bower_components)/, // 手动添加／屏蔽的文件\n                use: {\n                    loader: 'babel-loader', // loader名称\n                }\n            },\n            {\n                test: /\\.(css|styl)$/,\n                use: [\n                    {\n                        loader: 'style-loader'\n                    },\n                    {\n                        loader: 'css-loader'\n                    }\n                ]\n            },\n            {\n                test: /\\.html$/,\n                use: [\n                    {loader: 'html-loader'}\n                ]\n            },\n            {\n                test: /\\.(gif|jpg|png|svg|ttf|eot|woff|woff2)$/,\n                use : {\n                    loader: 'file-loader?name=fonts/[name].[ext]'\n                }\n            },\n        ]\n    },\n\n    plugins: [\n        new HtmlWebpackPlugin({\n            filename: 'index.html',\n            template: 'public/index.html'\n        })\n    ]\n};\n```\n2. 修改`package.json`中的scripts节点，如下\n\n```json\n\"build\": \"webpack --config webpack/webpack.config.build.js\"\n```\n执行打包命令后，所有文件会输出到项目根目录下的`dist`中。\n```sh\n$ npm run build\n```\n打包后的文件，配合`nginx`就可以访问请求了。\n","tags":["React","Webpack"],"categories":["React"]},{"title":"RHEL(Red Hat Enterprise Linux) 安装 zip、unzip","url":"/2019/11/4ae565dbddd3/","content":"\n> 多数的系统镜像文件中都是包含这两个命令，但总有意外。\n<!--more--> \n- 一般方法\n```sh\n$ sudo yum install zip unzip\n```\n- 如果一般方法报错，这个是安装unzip\n```sh\n$ sudo rpm -ivh https://rpmfind.net/linux/mageia/distrib/cauldron/x86_64/media/core/release/unzip-6.1c-6.mga8.x86_64.rpm\n```\n\n##### 其他版本的系统，链接从这里找 -> [点一下呗](https://rpmfind.net/linux/rpm2html/search.php?query=unzip)\n","tags":["Linux"],"categories":["Linux"]},{"title":"yum 安装最新版本 mysql","url":"/2019/11/fda8ed989b0e/","content":"---\n\n#### 一. 先到官网查询最新的版本，[官网地址](https://dev.mysql.com/downloads/repo/yum/)\n注意选择自己Linux对应的版本，查询方式：\n<!--more--> \n```shell\n$ cat /etc/*-release\nNAME=\"Red Hat Enterprise Linux Server\"\nVERSION=\"7.7 (Maipo)\"\n......\n\n$ uname -m\nx86_64\n```\n根据以上信息，选择所需版本的 rpm 名称，如图\n![](https://i.loli.net/2021/07/07/JsqNMBWZcmKpEXu.png)\n#### 二. 安装、启动\n1. 下载 rpm 文件。可以在网页上点 Download，然后在传送到服务器，也可以直接在服务器上下载，如下，替换链接后面部分即可：\n\t```sh\n\t$ wget http://repo.mysql.com/mysql80-community-release-el7-3.noarch.rpm\n\t```\n2. 导入 yum repo。\n\t```sh\n\t$ sudo rpm -ivh mysql80-community-release-el7-3.noarch.rpm\n\t```\n3. 安装\n\t```sh\n\t$ sudo yum install mysql-server\n\t```\n4. 启动\n\t```sh\n\t$ sudo systemctl start mysqld.service\n\t```\n\n#### 三. 连接、密码\n1. 连接\n\t```sh\n\t$ mysql -u root -p\n\t```\n2. 如果需要密码，去 `/var/log/mysqld.log`里面找，格式类似如下，`5Vgr6>Go.Azi`即是\n\t```sh\n\t2019-11-25T08:46:57.138469Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 5Vgr6>Go.Azi\n\t```\n3. 登陆成功之后，如果提示用`ALTER USER`修改密码，如下\n\t```sh\n\tmysql> alter user 'root'@'localhost' identified by 'new_password';\n\t```\n4. 如果提示密码不合格，查看一下当前密码要求，如下，length表示密码最小长度，mixed_case_count表示大小写字母混合数量，number_count表示数字数量，special_char_count表示特殊字符数量\n\t```sh\n\tmysql> show variables like 'validate_password%';\n\t+--------------------------------------+--------+\n\t| Variable_name                        | Value  |\n\t+--------------------------------------+--------+\n\t| validate_password.check_user_name    | ON     |\n\t| validate_password.dictionary_file    |        |\n\t| validate_password.length             | 6      |\n\t| validate_password.mixed_case_count   | 1      |\n\t| validate_password.number_count       | 1      |\n\t| validate_password.policy             | MEDIUM |\n\t| validate_password.special_char_count | 0      |\n\t+--------------------------------------+--------+\n\t7 rows in set (0.00 sec)\n\t```\n5. 如果想设置个简单好记的密码，修改一下密码检查，exit退出mysql，再连接登陆后生效\n\t```sh\n\tmysql> set global validate_password.mixed_case_count=0;\n\tmysql> set global validate_password.special_char_count=0;\n\t```","tags":["Linux","mysql","yum"],"categories":["Linux"]},{"title":"nginx路由匹配","url":"/2019/11/6e1530768100/","content":"\n几种匹配模式，今天涉及到了，在此记录。\n<!--more--> \n1. =\n精确匹配\n2. ^~\n精确前缀匹配\n3. ~\n正则匹配（大小写敏感）\n4. ~*\n正则匹配（大小写不敏感）\n5. /uri\n普通前缀匹配\n6. /\n通用匹配\n","tags":["nginx"],"categories":["nginx"]},{"title":"nginx 转发错误 13 permission denied","url":"/2019/11/5e5a9e36111c/","content":"---\n\n今天在做 nginx 转发的时候，总是权限的错误：\n<!--more-->\n```shell\n2019/11/23 14:22:28 [crit] 19986#19986: *1 connect() to 127.0.0.1:5050 failed (13: Permission denied) while connecting\n```\n\n从网上翻了翻，大多数文章都在说修改 nginx 用户，而且这些文章的内容还都是一样的，这让着急解决问题的我很恼火....不知道是一个人写完在各个地方发了一遍，还是别的什么，我没无聊到查这些... -_-#\n\n修改 nginx 配置文件，`/etc/nginx/nginx.conf`，改成 root\n```shell\nuser root\n```\n\n然后用 root 权限 restart nginx 服务\n```shell\n$ sudo systemctl restart nginx\n```\n\n一般到这就结束了，但是却还没解决我的问题，权限问题依然在。又在网上一番找，原来是 linux 给拦截了，暂时关掉就可以了 [链接](https://www.cnblogs.com/songxingzhu/p/10063043.html)\n```sh\n$ setenforce 0                  ##设置SELinux 成为permissive模式\n```\n","tags":["nginx"],"categories":["nginx"]},{"title":"ELK 单机部署，多 beat 节点","url":"/2019/11/c712d783ad18/","content":"\n[参考文章](https://www.cnblogs.com/sparkdev/p/10554076.html)\n\n适用场景：多个项目或服务，独立部署，各个服务有自己的 log 文件。为便于查看、过滤等，可单机部署 ELK 服务后，各个服务通过 filebeat 服务将 log 发送至 ELK 机器。\n<!--more--> \n![](https://i.loli.net/2021/07/07/rNvnGcQ4SyhpZlf.png)\n\n#### 一、安装 java\n```sh\n$ sudo yum install java\n\n$ java -version\nopenjdk version \"11.0.5\" 2019-10-15 LTS\nOpenJDK Runtime Environment Corretto-11.0.5.10.1 (build 11.0.5+10-LTS)\nOpenJDK 64-Bit Server VM Corretto-11.0.5.10.1 (build 11.0.5+10-LTS, mixed mode)\n```\n\n> 对于 elasticsearch、logstash 和 kibana，**Elastic.co** 都提供了多种环境的安装方式，这里只介绍通过 RPM 的方式，其他环境可参考[官网文档](https://www.elastic.co/guide/index.html)。\n#### 二、安装 elasticsearch \n1. 下载安装公钥。\n\t```sh\n$ rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch\n\t```\n2. 增加 yum 源。在 `/etc/yum.repos.d/` 创建文件 `elasticsearch.repo` 并写入以下内容:\n\t```sh\n[elasticsearch-7.x]\nname=Elasticsearch repository for 7.x packages\nbaseurl=https://artifacts.elastic.co/packages/7.x/yum\ngpgcheck=1\ngpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch\nenabled=1\nautorefresh=1\ntype=rpm-md\n\t```\n3. 安装、启动\n    ```sh\n$ sudo yum install elasticsearch\n\n$ sudo systemctl daemon-reload\n\n$ sudo systemctl enable elasticsearch.service\n Created symlink from /etc/systemd/system/multi-user.target.wants/elasticsearch.service to /usr/lib/systemd/system/elasticsearch.service.\n\n$ sudo systemctl start elasticsearch.service\n\n$ sudo systemctl | grep elasticsearch\n elasticsearch.service   loaded active running   Elasticsearch\n    ```\n    **注意**：elasticsearch 基于 java，默认占用的最小内存是 1G，如果机器内存不够启动时会报错 `Not enough space`，将 `/etc/elasticsearch/jvm.options` 中的 `-Xms` 和 `-Xmx` 改小后重试即可。\n\n\n#### 三、安装 logstash\n1. 下载安装公钥。如果上面执行过，可跳过。\n\t```sh\n$ rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch\n\t```\n2. 增加 yum 源。在 `/etc/yum.repos.d/` 创建文件 `logstash.repo` 并写入以下内容:\n\t```sh\n[logstash-7.x]\nname=Elastic repository for 7.x packages\nbaseurl=https://artifacts.elastic.co/packages/7.x/yum\ngpgcheck=1\ngpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch\nenabled=1\nautorefresh=1\ntype=rpm-md\n\t```\n3. 安装\n\t```sh\n$ sudo yum install logstash\n\t\n$ sudo systemctl daemon-reload\n\t\n$ sudo systemctl enable logstash.service\n Created symlink from /etc/systemd/system/multi-user.target.wants/logstash.service to /etc/systemd/system/logstash.service.\n\t```\n4. 配置。在 `/etc/logstash/conf.d/` 创建文件 `beat2es.conf`，并写入以下内容：\n\t```js\ninput {\n    beats{\n        port => 5044\n        ssl => false\n    }\n}\nfilter {\n    grok {\n        match => { \"message\" => \"%{TIMESTAMP_ISO8601:[@metadata][timestamp]} %{DATA:message\" }\n        overwrite => [ \"message\" ]\n    }\n    date {\n        match => [ \"[@metadata][timestamp]\" , \"yyyy-MM-dd HH:mm:ss,SSS\" ]\n    }\n}\noutput {\n    elasticsearch {\n        hosts => [\"localhost:9200\"]\n        index => \"%{[fields][appname]}-%{+YYYY.MM.dd}\"\n        sniffing => true\n    }\n}\n\t```\n5. 启动\n\t```sh\n$ sudo systemctl start logstash\n\t```\n\n#### 四、安装 kibana\n1. 下载安装公钥。如果上面执行过，可跳过。\n\t```sh\n$ rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch\n\t```\n2. 增加 yum 源。在 `/etc/yum.repos.d/` 创建文件 `kibana.repo` 并写入以下内容:\n\t```sh\n[kibana-7.x]\nname=Kibana repository for 7.x packages\nbaseurl=https://artifacts.elastic.co/packages/7.x/yum\ngpgcheck=1\ngpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch\nenabled=1\nautorefresh=1\ntype=rpm-md\n\t```\n3. 安装、启动\n\t```sh\n$ sudo yum install kibana\n\n$ sudo systemctl daemon-reload\n\n$ sudo systemctl enable kibana.service\nCreated symlink from /etc/systemd/system/multi-user.target.wants/kibana.service to /etc/systemd/system/kibana.service.\n\t\n$ sudo systemctl start kibana.service\n\t```\n\n###### 至此，ELK 服务已经部署完成。logstash 监听 5044 端口，所有发送到 5044 端口的内容都会传送至 elasticsearch，可通过 kibana 可视化搜索页面进行查询。\n###### kibana 默认部署在 locaohost:5601，为了增加安全性，需通过 nginx 为 kibana 设置用户登陆访问。\n###### 如果不需要安全性，可修改 `/etc/kibana/kibana.yml` 文件，将其中的 `server.host` 的值改为 `0.0.0.0` 后重启 kibana 服务，这样外网可直接通过该机器的 5601 端口访问 kibana 服务。\n\n#### 五、设置 kibana 登陆访问\n1. 添加 nginx 源\n\t```sh\n$ sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\n\t```\n2. 安装 nginx\n\t```sh\n$ sudo yum install nginx\n\t```\n3. 配置 nginx。修改 `/etc/nginx/conf.d/default.conf` 中 `/` 路由的配置，如下：\n\t```sh\nlocation / {\n     auth_basic \"secret\";\n     auth_basic_user_file /etc/nginx/db/passwd.db;\n     proxy_pass http://localhost:5601;\n     proxy_set_header Host $host:5601;\n     proxy_set_header X-Real-IP $remote_addr;\n     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n     proxy_set_header Via \"nginx\";\n  }\n\t```\n4. 安装 httpd\n\t```sh\n$ sudo yum install httpd\n\t```\n5. 设置用户。用户名：jack，密码：123456\n\t```sh\n$ sudo htpasswd -bc /etc/nginx/pwd.db jack 123456\n\t```\n6. 启动 nginx\n\t```sh\n$ sudo systemctl nginx.service\n\t```\n\n###### 至此，访问该机器的 80 端口，通过用户密码验证，即可访问到 kibana 服务。\n\n#### 六、安装 filebeat\n> filebeat 服务可安装在任何有 log 文件的机器上，其实时监听 log 文件，并将内容发送至 logstash 服务。\n1. 下载 rpm 文件，并安装\n\t```sh\n$ curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.4.2-x86_64.rpm\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100 22.7M  100 22.7M    0     0  24.8M      0 --:--:-- --:--:-- --:--:-- 24.8M\n\n$ sudo rpm -vi filebeat-7.4.2-x86_64.rpm\nPreparing packages...\nfilebeat-7.4.2-1.x86_64\n\n$ filebeat version\nfilebeat version 7.4.2 (amd64), libbeat 7.4.2 [15075156388b44390301f070960fd8aeac1c9712built 2019-10-28 19:46:13 +0000 UTC]\n\t```\n2. 配置。配置文件按模块分为了几部分，如 Filebeat inputs、Filebeat modules、Outputs等，在这里只需关心两个模块，一是 Filebeat inputs，另个为 Outputs。\nFilebeat inputs 用来配置 Filebeat 服务所监听、读取的文件，以及读取时的一些选项，这里的文件，即为 log 文件。\n\n\t```\n\t   enabled: true 表示开启\n\t\n\t   paths: 指定 log 文件的路径\n\t\n\t   fields: 配置元数据，appname 为必填项，用来区分不同项目\n\t\n\t   multiline.pattern: 正则表达式\n\t\n\t   multiline.negate: 是否反向。true 表示匹配 multiline.pattern 时开始新的一行；false 表示不匹配时开始新的一行\n\t\n\t   multiline.match: 连接的位置。after 表示不匹配 multiline.pattern 时连在上一句后面；before 表示连在下一句前面\n\t\n\t   这 3 项用来设置多行识别，'^[0-9]{4}-[0-9]{2}-[0-9]{2}' 是识别，行首格式为 YYYY-MM-DD 的日期，即每当行首为该格式的日期时，如 2019-11-15，都会重新开始一行。\n\t```\n   \n   Outputs 用来配置读取到的内容，如何输出。配置里缺省的输出方向是 Elasticsearch，这里需要切换为 Logstash。Logstash 的 SSL 目前尚未开启，因此只需配置 hosts 即可。\n\n\t```\nhosts: [\"{host}:5044\"]，logstash 服务所在的主机地址\n\t```\n\n   如无特殊需求，修改下面内容中的 `paths` 和 `appname` 以及 `hosts`，替换原 filebeat.yml 文件内容，即可。\n\n\t```sh\n\t   #=========================== Filebeat inputs =============================\n\t \n\tfilebeat.inputs:\n\t \n\t- type: log\n\t  enabled: true\n\t  paths:\n\t    - /var/log/app.log\n\t  fields:\n\t    appname: {your-app-name}\n\t  multiline.pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'\n\t  multiline.negate: true\n\t  multiline.match: after\n\t \n\t#============================= Filebeat modules ===============================\n\t \n\tfilebeat.config.modules:\n\t  # Glob pattern for configuration loading\n\t  path: ${path.config}/modules.d/*.yml\n\t \n\t  # Set to true to enable config reloading\n\t  reload.enabled: false\n\t \n\t#==================== Elasticsearch template setting ==========================\n\t \n\tsetup.template.settings:\n\t  index.number_of_shards: 1\n\t  #index.codec: best_compression\n\t  #_source.enabled: false\n\t \n\t#================================ Outputs =====================================\n\t \n\t#----------------------------- Logstash output --------------------------------\n\toutput.logstash:\n\t  # The Logstash hosts\n\t  hosts: [\"{host}:5044\"]\n\t \n\t  # Optional SSL. By default is off.\n\t  # List of root certificates for HTTPS server verifications\n\t  #ssl.certificate_authorities: [\"/etc/pki/root/ca.pem\"]\n\t \n\t  # Certificate for SSL client authentication\n\t  #ssl.certificate: \"/etc/pki/client/cert.pem\"\n\t \n\t  # Client Certificate Key\n\t  #ssl.key: \"/etc/pki/client/cert.key\"\n\t \n\t#================================ Processors =====================================\n\t \n\tprocessors:\n\t  - add_host_metadata: ~\n\t  - add_cloud_metadata: ~\n\t ```\n3. 启动\n\t```sh\n\t$ sudo systemctl enable filebeat.service\n\t\n\t$ sudo systemctl start filebeat.service\n\t```","tags":["ELK","Linux"],"categories":["ELK"]},{"title":"Elastic Beanstalk (EB) 引入 CloudWatch Log 服务","url":"/2019/11/95ca4e5703e9/","content":"\n- 原因\n 现所有 EB 环境服务的 log，均以文件的形式，存储在 EB 机器本地。当机器因各种问题（包含但不限于 bug ），造成无法远程访问时，无法读取其上的 log 来定位问题。故引入 AWS 的 CloudWatch Log 服务。\n\n<!--more-->\n\n- 原理\n CloudWatch Log 是一项服务。功能是，以接近实时的速度以流的方式读取、并存储文件。\n\n- 配置\n 1. 在项目根目录下创建名为`.ebextentions`的目录；\n 2. 在`.ebextentions`中新建文件`default.config`，扩展名必须为`.config`，文件名任意，合法即可；\n 3. 写入如下内容，部署时自动执行，具体见[AWS文档](https://docs.aws.amazon.com/zh_cn/elasticbeanstalk/latest/dg/ebextensions.html)\n```yaml\npackages:\n  yum:\n    awslogs: []\n\nfiles:\n  \"/etc/awslogs/awscli.conf\" :\n    mode: \"000600\"\n    owner: root\n    group: root\n    content: |\n      [plugins]\n      cwlogs = cwlogs\n      [default]\n      region = `{\"Ref\":\"AWS::Region\"}`\n\n  \"/etc/awslogs/awslogs.conf\" :\n    mode: \"000600\"\n    owner: root\n    group: root\n    content: |\n      [general]\n      state_file = /var/lib/awslogs/agent-state\n\n  \"/etc/awslogs/config/logs.conf\" :\n    mode: \"000600\"\n    owner: root\n    group: root\n    content: |\n      [/var/log/automation/app.log]\n      log_group_name = `{\"Fn::Join\":[\"/\", [\"/aws/elasticbeanstalk\", { \"Ref\":\"AWSEBEnvironmentName\" }, \"var/log/automation/app.log\"]]}`\n      log_stream_name = {instance_id}\n      file = /var/log/automation/app.log\n\ncommands:\n  \"1_init_log_dir\":\n      cwd: /var/log/\n      command: |\n        mkdir automation\n        chmod 775 automation\n        chgrp wsgi automation\n        chown wsgi automation\n      ignoreErrors: true\n  \"2_check_awslogs\":\n    command: chkconfig awslogs on\n  \"3_reload_awslogs\":\n    command: service awslogs restart\n```\n\n- 说明\n配置文件中使用了 3 个键，**packages**、**files** 和 **commands**。具体说明可见AWS文档。\n 1. **packages**\n - 使用 yum 安装 CloudWatch Log 服务，**awslogs**。\n \n 2. **files**：写入 awslogs 的配置文件，其中前两个 **awscli.conf** 和 **awslogs.conf** 在此不需要关心，只需关注第 3 个 **logs.conf**。\n - **log_group_name:** 在 CloudWatch Log 中显示的 **group** 的名称，对应下图中红色框；\n - **log_stream_name:** 在 CloudWatch Log 中显示的 **stream** 的名称，对应下图中蓝色框；\n - **file:** 该数据流所关联的文件的绝对路径\n ![](https://i.loli.net/2021/08/02/F7rtfBhgzmG6iLW.png)\n \n 3. **commands**\n 为便于查看和管理，统一将log放到了路径 `/var/log/` 下，并每个独立程序使用一个目录，这里使用automation说明。在 2 中，参数 **file** 使用的值是 `/var/log/automation/app.log`，所以在启动前需先创建 **automation** 目录。\n  - **1_init_log_dir：** 创建目录并修改权限，EB环境中，程序的默认执行用户是 wsgi；\n  - **2_check_awslogs：** 更新 awslogs 服务；\n  - **3_reload_awslogs：** 重启 awslogs 服务。\n\n- 使用\n将配置文件 **default.config** 中 **logs.conf** 的 **log_group_name**、**log_stream_name**和**file**以及 **1_init_log_dir** 替换为对应项目信息即可，在 **CloudWatch Log** 中可根据 **group_name** 和 **stream_name** 查找 **log**。\n\n- 扩展\n如有需要，可同时创建多个流，修改 **logs.conf** 即可，格式参考如下\n```yaml\n\"/etc/awslogs/config/logs.conf\" :\n    mode: \"000600\"\n    owner: root\n    group: root\n    content: |\n      [/var/log/messages]\n      log_group_name = `{\"Fn::Join\":[\"/\", [\"/aws/elasticbeanstalk\", { \"Ref\":\"AWSEBEnvironmentName\" }, \"var/log/messages\"]]}`\n      log_stream_name = {instance_id}\n      file = /var/log/messages\n\n      [/var/log/dmesg]\n      log_group_name = `{\"Fn::Join\":[\"/\", [\"/aws/elasticbeanstalk\", { \"Ref\":\"AWSEBEnvironmentName\" }, \"var/log/dmesg\"]]}`\n      log_stream_name = {instance_id}\n      file = /var/log/dmesg\n\n      [/var/log/automation/app.log]\n      log_group_name = `{\"Fn::Join\":[\"/\", [\"/aws/elasticbeanstalk\", { \"Ref\":\"AWSEBEnvironmentName\" }, \"var/log/automation/app.log\"]]}`\n      log_stream_name = {instance_id}\n      file = /var/log/automation/app.log\n```\n","tags":["AWS","CloudWatch Log"],"categories":["AWS"]},{"title":"保持ssh远程连接不断开","url":"/2019/09/ced3db1f808e/","content":"\n通过`ssh user@server`登陆到远程服务器时，经常会遇到一个问题，\n\n```sh\nConnection closed by remote host\n```\n意思就是服务器断开了这个连接。\n<!--more--> \n##### 解决方法\n\n```sh\n// 先登录到远程服务器\n$ ssh -i ./ssh/authorization.pem {root}@{server}\n\n// 切换到root\n$ sudo su -\n\n// 修改配置文件\n# vi /etc/ssh/sshd_config\n\n// 将其中的两行\n#ClientAliveInterval 0\n#ClientAliveCountMax 3\n// 修改为\nClientAliveInterval 2\nClientAliveCountMax 3\n// :wq 保存，并退出\n\n// 重启ssh服务\n# /etc/init.d/sshd restart\nStopping sshd:                                             [  OK  ]\nStarting sshd:                                             [  OK  ]\n```\n\n断开当前ssh连接，重新登录，问题解决。","tags":["Linux","ssh"],"categories":["Linux"]},{"title":"在AWS Lambda中使用psycopg2连接Redshift","url":"/2019/09/6df5f8cca1a9/","content":"\n- 环境：MacOS 10.12.6\n\n开始说正题。\n\nRedshift是基于PostgreSQL的二次开发应用，所以，能连接PostgreSQL的工具都可以用来连接Redshift。我选择的是使用最广泛的`psycopg2`。\n<!--more--> \n如果上来就执行:\n```sh\n$ pip install psycopg2\n```\n你会看到下面的提示错误：\n\n```sh\nError: pg_config executable not found.\n    \n    pg_config is required to build psycopg2 from source.  Please add the directory\n    containing pg_config to the $PATH or specify the full executable path with the\n    option:\n    \n        python setup.py build_ext --pg-config /path/to/pg_config build ...\n    \n    or with the pg_config option in 'setup.cfg'.\n    \n    If you prefer to avoid building psycopg2 from source, please install the PyPI\n    'psycopg2-binary' package instead.\n    \n    For further information please check the 'doc/src/install.rst' file (also at\n    <http://initd.org/psycopg/docs/install.html>).\n    \n    ----------------------------------------\nERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output.\n```\n提示需要一个叫做`pg_config`的东西。`pg_config`是个编译PostgreSQL源码后得到的一个文件。所以想要通过这种方式安装`psycopg2`就需要手动去编译源码。\n\n如果懒得编译，人家已经替你想好了办法，正如提示里所言，\n\n```sh\n If you prefer to avoid building psycopg2 from source, please install the PyPI\n    'psycopg2-binary' package instead.\n```\n因此，通过下面命令安装删减版的`psycopg2`，\n\n```sh\n$ pip install psycopg2-binary\n```\n然后，在本机上就可以正常使用了。\n\n---\n\n**但是，Lambda不可以。不同于独立的机器，Lambda需要完整的依赖包才能执行。**\n\n在Github上搜到了[awslambda-psycopg2](https://github.com/jkehler/awslambda-psycopg2)，作者介绍说是专门解决在Lambda上使用`psycopg2`的。\n\n按照`README.md`的步骤，先编译PostgreSQL，再用生成的`pg_config`去编译`psycopg2`。但执行后总会报一个错误，\n\n```python\nNo module named 'psycopg2._psycopg'\n```\n看着[issue](https://github.com/jkehler/awslambda-psycopg2/issues/47)里面几个老外说来说去，也没说出个可行的解决方案。\n\n几番尝试下来，终究是填了坑。\n\n**其实是编译环境的问题，在什么环境下编译生成的依赖包，只能在该环境下使用。Lambda是在Linux机器上执行的，所以必须在Linux上进行编译，生成的依赖包才可以使用。**\n\n就是这么简单。\n\n![](https://i.loli.net/2021/07/07/IX1DjFi72OblPoG.png)\n","tags":["AWS Lambda","python"],"categories":["Python"]},{"title":"在Spark中加载Redshift数据问题汇总","url":"/2019/09/e4951d749391/","content":"\n#### 1. java.sql.SQLException: No suitable driver\n这个错误是因为，连接Redshift时需要一个driver，而程序执行时找不到能用的driver，所以报错。AWS提供了多个版本连接Redshift的driver，[**点击查看**](https://docs.aws.amazon.com/zh_cn/redshift/latest/mgmt/configure-jdbc-connection.html#download-jdbc-driver)。\n<!--more--> \n#### 2. java.lang.NoClassDefFoundError: com/amazonaws/services/kinesis/model/Record\n经过几次尝试发现，直接使用AWS提供的驱动可以连上Redshift，打印出表结构，但是不能加载数据，一加载数据会报这个奇怪的错误，表结构都可以打印出来，为什么不能加载数据呢？我想不通。几番查询，找到了一个包装库，[**github地址**](https://github.com/databricks/spark-redshift#python)。\n\n#### 3. java.lang.IllegalArgumentException: AWS Access Key ID and Secret Access Key must be specified as the username or password (respectively) of a s3n URL, or by setting the fs.s3n.awsAccessKeyId or fs.s3n.awsSecretAccessKey properties (respectively).\n按照2里面的github库里的文档说明配置好后，可能会报这个错。因为spark-redshift用到了S3，所以要配置key和secret才可以。文档里也提供了[**几种方式**](https://github.com/databricks/spark-redshift#configuration)，i、ii和iii，开始我选择的是第三种方式，直接写在了URI里面。\n\n#### 4. java.lang.NoClassDefFoundError: com/eclipsesource/json/Json\n紧接着，配置好aws的key和secret，可能会遇到这个错误。这个错误一眼看上去感觉奇怪，为什么会报json的错误呢？在[**spark-redshift的issue**](https://github.com/databricks/spark-redshift/issues/279)里面找到了遇到同样问题的人，最下面**arvindkanda**提供了解决方案，启动时提供一个额外的jar包就可以了。\n\n\n#### 5. java.sql.SQLException: [Amazon](500310) Invalid operation: S3ServiceException:The S3 bucket addressed by the query is in a different region from this cluster.\n这个问题是说，S3和EMR必须在同一个region，不然Spark是读不到Redshift的数据的。我这里用的都是us-west-2，Oregon，俄勒冈。\n\n\n#### 6. com.amazon.ws.emr.hadoop.fs.shaded.com.amazonaws.services.s3.model.AmazonS3Exception: Bad Request (Service: Amazon S3; Status Code: 400; Error Code: 400 Bad Request; \n这个问题，就比较厉害了，卡了我好几个小时。网上各种方案都在说，因为签名版本的问题，所以访问S3时，必须指定S3的endpoint，查来的都是`s3a`的，[**比如这个**](https://stackoverflow.com/questions/34209196/amazon-s3a-returns-400-bad-request-with-spark)。但是因为spark-redshift里用的是`s3n`，我就将a替换成了n，但是这个问题还是在。各种方案不断尝试，可能是运气好，莫名的就试对了一种方式：将3里面的方式替换成ii，然后再配置`sc.hadoopConfiguration.set(\"fs.s3a.endpoint\", \"s3.us-west-2.amazonaws.com\")`，就可以了。\n\n#### 最终代码如下，\n\n```java\nspark = SparkSession.builder.getOrCreate()\nspark._jsc.hadoopConfiguration().set('fs.s3n.awsAccessKeyId', aws_access_key_id)\nspark._jsc.hadoopConfiguration().set('fs.s3n.awsSecretAccessKey', aws_secret_access_key)\nspark._jsc.hadoopConfiguration().set(\"fs.s3n.endpoint\", \"s3.us-west-2.amazonaws.com\")\n\nrsdf = spark.read\\\n        .format('com.databricks.spark.redshift')\\\n        .option('url', 'jdbc:redshift://host:port/schema')\\\n        .option('dbtable', 'table_name')\\\n        .option('user', 'username')\\\n        .option('password', 'password')\\\n        .option('tempdir', 's3n://bucket/dir')\\\n        .load()\n# 打印表结构\nrsdf.printSchema()\n# 打印表内容\nrsdf.show()\n```\n\n##### 关于spark启动命令参数，[**这篇文章**](https://blog.csdn.net/u012402124/article/details/99485901)已经说明过，这里就不再赘述。","tags":["AWS","Spark","Redshift"],"categories":["Spark"]},{"title":"「AWS」入门安装aws cli","url":"/2019/08/c35313b67e87/","content":"\n> cli，即Command Line Interface，是aws服务常用的命令工具\n<!--more--> \n[AWS官网地址](https://amazonaws-china.com/cn/cli/)\n\n- 环境：Python\n\n1. 安装\n\n安装起来只需要一条命令：\n```shell\n$ pip install awscli --user\n```\n \n执行完成之后，输入`aws`，输出如下，则说明安装成功了：\n```shell\n$ aws\nusage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]\nTo see help text, you can run:\n\n  aws help\n  aws <command> help\n  aws <command> <subcommand> help\naws: error: the following arguments are required: command\n```\n\n查看支持的命令，其中的`AVAILABLE SERVICES`便是支持的命令，内容过多，只罗列了部分\n```shell\n$ aws help\nNAME\n       aws -\n\nDESCRIPTION\n       The  AWS  Command  Line  Interface is a unified tool to manage your AWS\n       services.\n\nSYNOPSIS\n          aws [options] <command> <subcommand> [parameters]\n\n       Use aws command help for information on a  specific  command.  Use  aws\n       help  topics  to view a list of available help topics. The synopsis for\n       each command shows its parameters and their usage. Optional  parameters\n       are shown in square brackets.\nAVAILABLE SERVICES\n       o acm\n\n       o acm-pca\n\n       o alexaforbusiness\n\n       o amplify\n\n       o apigateway\n\n       o apigatewaymanagementapi\n\n       o apigatewayv2\n\n       o application-autoscaling\n\n       o appmesh\n\n       o appstream\n\n       o appsync\n\n       o athena\n\n       o autoscaling\n\n       o autoscaling-plans\n\n       o backup\n\n       o batch\n\n       o budgets\n\n       o ce\n\n       o chime\n\n       o cloud9\n\n       o clouddirectory\n\n       o cloudformation\n\n       o cloudfront\n\n       o cloudhsm\n\n       o cloudhsmv2\n\n       o cloudsearch\n\n```\n\n2. 配置\n\n其中有一个子命令`configure`，是用来配置aws cli的。aws cli访问的都是 aws 服务，而每个服务都是需要身份验证的，所以在使用之前，需要先配置身份信息。\n\n同样，先查看`configure`的说明：\n```shell\n$ aws configure help\nNAME\n       configure -\n\nDESCRIPTION\n       Configure  AWS  CLI  options. If this command is run with no arguments,\n       you will be prompted for configuration values such as your  AWS  Access\n       Key  Id  and you AWS Secret Access Key.  You can configure a named pro-\n       file using the --profile argument.  If your config file does not  exist\n       (the default location is ~/.aws/config), the AWS CLI will create it for\n       you.  To keep an existing value, hit enter when prompted for the value.\n       When  you  are prompted for information, the current value will be dis-\n       played in [brackets].  If the config item has no value, it be displayed\n       as  [None].  Note that the configure command only work with values from\n       the config file.  It does not use any configuration values  from  envi-\n       ronment variables or the IAM role.\n\n       Note:  the  values  you  provide  for the AWS Access Key ID and the AWS\n       Secret Access Key will  be  written  to  the  shared  credentials  file\n       (~/.aws/credentials).\n\nCONFIGURATION VARIABLES\n       The following configuration variables are supported in the config file:\n\n       o aws_access_key_id - The AWS access key part of your credentials\n\n       o aws_secret_access_key - The AWS secret access key part of  your  cre-\n         dentials\n\n       o aws_session_token  - The session token part of your credentials (ses-\n         sion tokens only)\n\n       o metadata_service_timeout - The number of seconds to  wait  until  the\n         metadata service request times out.  This is used if you are using an\n         IAM role to provide your credentials.\n\n       o metadata_service_num_attempts - The number  of  attempts  to  try  to\n         retrieve  credentials.   If you know for certain you will be using an\n         IAM role on an Amazon EC2 instance, you can set this value to  ensure\n         any intermittent failures are retried.  By default this value is 1.\n\n       For  more information on configuration options, see Configuring the AWS\n       Command Line Interface in the AWS CLI User Guide.\n\n       See 'aws help' for descriptions of global parameters.\n\n```\n\n其中有用的就是`CONFIGURATION VARIABLES`，一般需要两个参数，`aws_access_key_id`和`aws_secrct_access_key`，这两个参数登陆AWS后从IAM获取，下面是配置方法，`--profile`是给当前配置的身份起一个名字，这里起名叫`dev`：\n```shell\n$ aws configure --profile dev\nAWS Access Key ID [None]: \nAWS Secret Access Key [None]: \nDefault region name [None]: \nDefault output format [None]: \n```\n执行后会让你输入以上几项，`aws_access_key_id`和`aws_secrct_access_key`照常填写，后面几项可以不填，也可按需填写。\n\n这样，就配置完成了，使用`dev`这个身份，就可以访问aws的各种服务了。\n\n---\n\n**到这就算是入门了**","tags":["AWS","Python"],"categories":["AWS"]},{"title":"Golang 项目结构","url":"/2019/08/d923d0c927c5/","content":"\n>  好久没写 golang 的项目了，前两天接个临时需求，需求不难，但要求必须用golang来写。一时间竟然忘了如何开始，从哪入手了，故在此做个记录，以备不时之需。\n<!--more--> \n- 环境： MacOS\n- IDE：GoLand\n\n1. 项目路径\n    为了便于管理和引用其他 package，一般放在 `/{GOPATH}/src` 下。在该目录下，创建一个公司域名的文件夹，在此文件夹下创建项目命名的文件夹，如`/{GOPATH}/src/domain.com/project_name/`。\n\n2. 项目结构\n```\n  project_name/\n    |__bin/\n    |__build/\n    |__config/\n    |__cmd/\n    |  |__service_1/\n    |     |__service_1.go\n    |  |__service_2/\n    |     |__service_2.go\n    |__docs/\n    |__Godep/\n    |__pkg/\n    |    |__lib/\n    |    |__...\n    |    |__...\n    |__resource/\n    |__vendor/\n```\n- bin/：编译后的二进制文件\n- build/：编译、构建脚本文件\n- config/：配置文件，json/yaml等\n- cmd/：所有服务\n- cmd/service_1/：某个具体的服务\n- cmd/service_1/service_1.go：服务入口\n- docs/：文档\n- Godep/：godep 自动生成的目录\n- pkg/：主要代码\n- resource/：资源\n- vendor/：godep 自动生成的目录\n\n3. `godep`\n    包依赖管理工具，使每个项目的依赖的版本相互独立。在项目根目录下执行`godep save ./cmd`，自动生成 Godep 和 vendor。\n\n\n**大致，就这些。**","tags":["Golang"],"categories":["Golang"]},{"title":"AWS EMR 上运行 Spark + Kinesis: NoSuchMethodError: org.apache.spark.internal.Logging","url":"/2019/08/bb99d69df7f6/","content":"\n> 如题，因有需求，这两天在弄这个Spark，用的是AWS的EMR，具体是什么就不解释了。上面这个问题卡了很久，故在此记录一下。\n<!--more--> \n- Spark支持多种语言，如Scala、Java、Python、R，我用的是Python。\n\n官方有个叫WordCount的Example，我没看，直接照着文档撸代码。[Spark文档地址](https://spark.apache.org/docs/latest/streaming-kinesis-integration.html)\n\n\n初始化代码很简单，如下：\n\n```python \n# main.py\nfrom pyspark import SparkContext\nfrom pyspark.streaming import StreamingContext\nfrom pyspark.streaming.kinesis import KinesisUtils, InitialPositionInStream\n\naws_access_key_id = 'your-aws-access-key-id'\naws_secret_access_key = 'your-aws-secret-access-key'\n\nif __name__ == '__main__':\n    sc = SparkContext('local[*]', 'first_test0809')\n    ssc = StreamingContext(sc, 1)\n    kinesis_stream = KinesisUtils.createStream(\n        ssc,\n        'ssc_kinesis',\n        'kinesistest',\n        'https://kinesis.us-west-2.amazonaws.com',\n        'region-name',\n        InitialPositionInStream.TRIM_HORIZON,\n        2,\n        awsAccessKeyId=aws_access_key_id,\n        awsSecretKey=aws_secret_access_key\n    )\n\n    kinesis_stream.pprint(500)\n\n    ssc.start()\n    ssc.awaitTermination()\n```\n\n`kinesistest`是我创建的一个kinesis streaming，会有源源不断的数据写到这个streaming里，Spark负责处理这个streaming里的数据。\n\n接下来就是将这个文件部署到EMR上，依然是照着文档来操作。[文档地址](https://docs.aws.amazon.com/zh_cn/emr/latest/ReleaseGuide/emr-spark-submit-step.html)\n\n不得不说，AWS的文档既简约又简单，却不明了，在这个文档的指引下，没有一次我是顺利走通的。\n\n添加Step的命令：\n\n```shell\naws emr add-steps --cluster-id j-2AXXXXXXGAPLF --steps Type=Spark,Name=\"Spark Program\",ActionOnFailure=CONTINUE,Args=[--class,org.apache.spark.examples.SparkPi,/usr/lib/spark/lib/spark-examples.jar,10]\n```\n\n这个命令要分为两部分来看，前部分是AWS自身的命令`aws emr add-steps`，后部分就是`Args`这个参数的值。\n因为部署Spark程序实际上用的是`spark-submit`命令，而`Args`的值，都会传给`spark-submit`。\n\n前半部分比较简单，`cluster-id`就是在创建EMR集群后自动生成的id，这里需要注意的是，创建的EMR集群必须要设置共有IP，这样外部机器才能访问到。`Type`固定为Spark，`Name`自己随便写，`ActionOnFailure`一般都传CONTINUE，其他可选值可通过`aws emr add-steps help`查看。\n\n后半部分的`Args`的相关说明在[这里](https://github.com/apache/spark/blob/branch-1.3/core/src/main/scala/org/apache/spark/deploy/SparkSubmitArguments.scala#L454)，说的很详细。\n\n在部署运行之后，会报一些`ClassNotFound`的错误，这种错误不要紧，把缺的jar文件当作参数传上去就能解决问题。[Maven搜索地址1](https://mvnrepository.com/) | [Maven搜索地址2](https://search.maven.org/)\n\n上面的main.py用到了两个没有的jar文件，kinesisi和kcl，为了便于观看，使用了另一种格式，如下：\n\n```shell\n$ aws emr add-steps --cluster-id j-2AXXXXXXGAPLF --steps file://./step.json\n```\n\n将参数都抽取到一个josn文件中：\n```json\n[\n  {\n    \"Name\": \"Spark Program\",\n    \"Type\": \"Spark\",\n    \"ActionOnFailure\": \"CONTINUE\",\n    \"Args\": [\n      \"--master\",\n      \"local\",\n      \"--jars\",\n      \"local:///home/hadoop/spark-streaming-kinesis-asl_2.11-2.4.3.jar,local:///home/hadoop/amazon-kinesis-client-1.11.1.jar\",\n      \"local:///home/hadoop/main.py\"\n    ]\n  }\n]\n```\n\n注意，命令中所用到的所有文件，包括jar和py，都需要提前上传到机器上。具体上传方法见`aws emr put`命令\n\n至此，所有的工作基本完成，你以为这样就可以跑起来了吗？\nNO！\n\n最麻烦的问题，就是Spark版本的问题。之前用的最多、最稳定的就是1.6.5版本的，现在最新版已经2.4.3了，里面变动不小，尤其是`Logging`这个类，直接内部化了。\n\n仔细看会发现，上面的kinesis jar文件有两个版本号：2.11-2.4.3，后面的2.4.3是Spark大版本，前面的是什么我没查。在Maven里，这个版本最新的是2.12，所以最开始的时候我直接用了最新的，因为网上一直在强调的都是后面的2.4.3这个版本号，结果就出问题了，如题所写，总是报NoSuchMethodError。\n\n2.0之前的，Logging的位置是org.apache.spark.Logging，2.0之后变成了org.apache.spark.internal.Logging，但我用的都是最新版，为什么总说找不到呢？想了想，想了又想，试了各种办法，都行不通，这个过程持续了一天多，让人头大。\n\n后来不知是巧合，还是时候到了，偶然发现cluster机器上spark-core的版本号是2.11-2.4.3，报着尝试的心态从Maven下了2.11-2.4.3的kinesis jar文件，换上去一跑，哎，就这么成了。真是气人。\n\n所以说呢，有些时候解决问题是很简单的，困难的是发现问题。\n","tags":["AWS","EMR"],"categories":["Spark"]},{"title":"摸摸「浮点数」的底","url":"/2019/06/3754d5b7c490/","content":"\n> 摆理论和套公式其实也是为了说明问题，解释原理，不过有时却适得其反。\n\n\n\n前一个主题介绍了整数在计算机里的存储形式，浮点数，即小数，例如 3.14、2.71828 等，看起来和整数相近，而二者在计算机中存储的形式大为不同，作为一种常用的数据类型，来了解了解其中的本质，这个主题我们一起来摸摸「浮点数」的底。\n\n\n\n浮点数有多种类型，*但是我们写代码时常用到的有两种*，按照所占长度分为：一个是单精度，占用 32 个二进制位，另一个是双精度，占用 64 个二进制位。不管是什么类型、占用多少位，存储的**模式**都是类似的，而这也正是我们想要摸的「底」。\n\n\n\n##### 1. 化身为二进制的浮点数\n\n首先明确一点，不管什么类型的数据，整数也好，浮点数也罢，在计算机中都是以二进制形式存储，即 01001、10110 这样的形式。\n\n\n\n那么，二进制的浮点数该如何表示呢？\n\n\n\n在此之前，我们先来看下十进制的小数 22.71是如何表示的：**小数点左边第一位为个位，表示 1，第二位为十位，表示 10；小数点右边第一位为十分位，表示 1/10，即 10^<sup>-1</sup>，第二位为百分位，表示 1/100，即 10^<sup>-2</sup>，综合如下**。\n\n```java\n22.71 = 2*10^1 + 2*10^0 + 7*10^-1 + 1*10^-2\n      = 20 + 2 + 0.7 + 0.01\n      = 22.71\n```\n\n\n\n上面就是十进制浮点数的表示形式，而二进制与十进制整体相同，唯一区别就在于将 10 换成了 2，举个例子，如二进制浮点数 101.11：**小数点左边第一位表示 2^<sup>0</sup>，即 1，第二位表示 2^<sup>1</sup>，即 2，第三位表示2^<sup>2</sup>，即 4；小数点右边第一位表示 2^<sup>-1</sup>，即 0.5，第二位表示 2^<sup>-2</sup>，即 0.25，综合如下**。\n\n```java\n101.11 = 1*2^2 + 0*2^1 + 1*2^0 + 1*2^-1 + 1*2-2\n       = 4 + 0 + 1 + 0.5 + 0.25\n       = 5.75\n```\n\n\n\n##### 2. 自由转化的浮点数\n\n既然，浮点数既可以用十进制表示，也可以用二进制表示，那么同一个浮点数如何在这两种进制之间自由转化呢？由二进制转为十进制就不用说了，上面刚刚用 101.11 演示完，而由十进制转为二进制很多人都是直接套公式却没想过原理，接下来说说推导公式的过程。**这个转化过程需要将浮点数的整数部分和小数分别转化，之后再进行合并**。\n\n\n\n我们用 6.625 来举例说明。先看整数部分的 6，这个我们一眼就能看出来，结果是 110，但是如果换成 60、600，这些不能一眼看出的数呢？其实很多事情都是如此，将思考过程从「一眼就能看出的」的情况中抽象出来，就是计算方法。这个思考过程无非就是，想知道需要几个二进制位、每个二进制的值是多少，就可以表示 6。\n\n\n\n为了便于理解，我们先看一下计算表示 758 需要几个十进制位以及每位的值是多少。\n\n\n\n```java\n先从个位，即右起第一位开始:\n\n很显然，求个位的值用 758 对 10 取余即可：758 / 10 = 75···8，结果为 8，此时原数还剩下 75*10，大于 0，说明一位不够；\n\n继续求第二位的值：75*10 / 100 = 75 / 10 = 7···5，结果为 5，此时原数还剩下 7*100，大于 0，说明两位还是不够；\n\n继续求第三位的值：7*100 / 1000 = 7 / 10 = 0···7，结果为 7，此时原数还剩下 0*1000，等于 0，说明三位十进制够用了。\n\n最终结果，需要 3 个十进制位，从左到右的值分别是 7、5、8，即 758。\n\n同时我们发现的一个规律是：\n求第二位的值时，用计算完第一位的商对 10 取余即可，\n求第三位的值时，用计算完第二位的商对 10 取余即可。\n```\n\n**由此可得，求第 n 位的值时，用计算完 n-1 位的商对 10 取余数即可，当商为 0 时，结束，注意 n > 1。**如上，就是十进制抽取方法的过程，也同样适用于二进制，区别就在于将 10 换成了 2，实际计算一下。\n\n```java\n计算将 6 用二进制的值，同样从右起的第一位开始：\n\n先求第一位：6 / 2 = 3···0，结果为 0，原数还剩下 3*2^1，大于 0，说明一位不够；\n\n继续求第二位，3 / 2 = 1···1，结果为 1，原数还剩下 1*2^2，大于 0，说明两位不够；\n\n继续求第三位，1 / 2 = 0···1，结果为 1，原数还剩下 0*2^3，等于 0，说明三位二进制够了。\n\n最终结果，需要 3 个二进制位，从左到右的值分别是 1、1、0，即 110，而这也与我们直观上看到的结果相符。\n```\n\n\n\n与整数部分的计算类似，再看下小数部分的计算。同样，先用比较直观的十进制浮点数举例，从而从中总结规律。\n\n```java\n计算 0.358 用几位十进制的浮点数表示，及每位的值的过程，从左开始，\n\n先求第一位，注意，与整数不同的是，这里是取商，而不是余数：\n0.358 / 10^-1 = 0.358 * 10 = 3···0.58，结果是：3，原数还剩下：0.58*10^-1 > 0;\n继续求第二位，\n0.58*10^-1 / 10^-2 = 0.58 * 10 = 5···0.8，结果是：5，还剩下：0.8*10^-2 > 0;\n继续求第三位，\n0.8*10^-2 / 10^-3 = 0.8 * 10 = 8···0，结果是：8，还剩下：0，说明 3 位十进制够了。\n\n最终结果，需要 3 个十进制，从右向左分别是 3、5、8，即 0.358。\n\n同时，我们发现：\n求第二位时，用计算完第一位的余数乘 10 再取商即可，\n求第三位时，用计算完第二位的余数乘 10 再取商即可。\n```\n\n**由此可得，计算第 n 位时，用计算完第 n-1 位的余数乘 10 再取商即可，当余数等于 0 时结束，注意 n > 1。**紧接着，用我们从上面十进制例子中总结的方法计算下二进制。\n\n```java\n计算 6.625 的小数部分 0.625 的二进制形式，从左开始，\n\n先求第一位，0.625 * 2 = 1···0.25，结果是 1，原数还剩下：0.25*2^-1 > 0；\n继续求第二位，0.25 * 2 = 0···0.5，结果是 0，原数还剩下：0.5*2^-2 > 0；\n继续求第三位，0.5 * 2 = 1···0，结果是 1，原数还剩下：0，结束。\n\n最终结果，需要 3 个二进制位，从左向右分别是：1、0、1，即 0.101。\n```\n\n至此，我们完成了所有计算过程，整数部分：110，小数部分：101，最终结果为：110.101。\n\n\n\n##### 3. 如何存储\n\n前面做了那么多铺垫，现在终于可以开始说存储了。存储之前，需要先把二进制的浮点数用科学计数法表示，也称规范化，即 \n\n**N = ±a x 2^<sup>n</sup>** , a∈ **[1,2)**\n\n**a** 叫作尾数，**n** 叫作阶码。计算机存储的浮点数都是这种形式的，例如上面的 110.101 就需要变成 1.10101x2^<sup>2</sup>，而 0.1101 就需要变成 1.101x2^<sup>-1</sup>，这个变换的过程很简单。\n\n\n\n对于浮点数 **±a\\*2^<sup>n</sup>**，计算机将其分成了 3 个部分来进行存储，即存储正负的**符号位**、存储 n 的**指数域**和存储 a 的**尾数域**，是的，存储 a 的部分叫做**尾数域**。\n\n\n\n对于长度为 32 位二进制的浮点数，从左起，第 1 位用来表示符号，0 代表正数，1 代表负数。接下来的 8 位，即第 2 位到第 9 位，用来表示指数。而从第 10 位开始一直到最后的 32 位，都用来表示尾数，对于科学计数法下的 a，其整数部分的值永远都是 1，所以这个 1 就省略了，因此 23 位尾数二进制只存储了 a 的小数部分，即 1.10101 的 10101，1.101 的 101。\n\n\n\n和 32 位类似，长度为 64 位二进制的浮点数，从左起，第一位存储符号，接下来的 11 位存储指数，剩下的 52 位存储尾数，而尾数同样省略了 a 的整数部分，只存储小数部分。\n\n\n\n##### 4. 阶码\n\n符号位，0 或 1，尾数域，采用原码表示，这两种比较简单明了，这里要单独说一说阶码。\n\n\n\n在此之前，先回忆一下移码。所谓移码，实际上就是把负数映射到正轴上，通俗的说就是消灭负数。例如，4 个bit位能表示的范围，[-2^<sup>3</sup>, 2^<sup>3</sup> - 1]，即[-8, 7]。每个数字加上偏移量 2^<sup>3</sup>，即为移码。\n\n\n\n阶码在计算机中也是以移码的形式存储的，区别在于这个偏移量。**根据 IEEE 754 标准，k 位二进制位的解码，偏移量 bias 为 2^<sup>k-1</sup> - 1**，例如 32 位单精度浮点数，阶码为 8 位，则偏移量为 2^<sup>8-1</sup> - 1 = 127。\n\n\n\n**N = (-1)^<sup>S</sup> x 2^<sup>E-Bias</sup> x (1+M)**\n\n其中，**S为符号位的值，E为指数的值，M为尾数域的值，Bias为移码偏移量**。\n\n\n\n举个例子，-6.75，**单精度浮点数，转化为规范化二进制为：**-110.11 = -1.1011 x 2^<sup>2</sup>\n\n符号位 **S = 1**，\n\n阶码 **E = 2 + Bias = 2 + 127 = 129**\n\n尾数 **M = 1.1011 - 1 = 1011** (省去小数点)\n\n**1 10000001 10110000000000000000000** （尾数域：4 位精度 + 19 个 0，共 23 位）\n\n\n\n至此，浮点数就介绍完了。\n\n\n\n","tags":["编码","浮点数"],"categories":["编码"]},{"title":"「原码 反码 补码 移码」一探究竟（下）","url":"/2019/01/0a1eac4519fc/","content":"\n> 抛开复杂的理论，直探事物的本质。\n\n这是这个主题的第三篇文章，前两篇介绍了**这几种码的基本概念**，这篇文章来具体说说「移码」。\n<!--more-->\n**00. 回顾**\n\n先来回顾一下移码是什么，简单说定义就一句话：**将补码符号位取反，即为移码**。乍一看，是不是有点懵，这到底在说什么呢？什么是移码？为什么是这么算？它能干嘛用？莫急，这些问题一个一个都会解决。\n\n相比于移码，应该使用补码的几率更高一些。因为移码主要用在浮点数的阶码中，用的较少。注意，这里又出来了一个新名词，「阶码」，关于这块的内容比较乱，会单独写一篇文章来说。而现在只需要记住一句话，**移码的出现就是为了消灭负数**。\n\n<!--more--> \n\n**01. 如何「消灭」负数**\n\n\n先拿大家都熟悉的数轴举个例子。\n![](https://i.loli.net/2021/07/07/cdtpFeLJPyw9Txl.png)\n\n如图，数轴上一共有 5 个点，分别为 -2、-1、0、1、2，其中有 2 个负数，所谓消灭负数，就是用 5 个非负数来表示这 5 个点，方法就是**将 0 向左移动两个位置**，如下。\n![](https://i.loli.net/2021/07/07/HwXenQjWztJC2rY.png)\n\n很简单吧，这样一移动负数就被消灭了，而「**移码**」的计算就是这个道理，而**将 0 向左移动 2 个位置就等同于将所有数字加 2**，这个很好理解。很显然，**移动的位数就是表示范围内负数的个数。**\n\n**02. 为什么是补码符号位取反？**\n\n先明确一点：**因为移码都是非负数，不需要符号位，所以，所有的二进制位都是用来表示数据的。**\n\n接下来，根据上面得出的结论，我们亲自来算一算移码。为了便于计算，就拿 4 位二进制来举例。在计算机中，4 位二进制能表示的范围为 **[-2^3, 2^3-1] = [-8, 7]**，其中负数的个数为 -1 到 -8，共 **2^3** 个，也就是 8 个，所以需要将 0 向左移动 8 个位置，**即给每个数加上 8**，如下。\n\n```\n     补码   +8  移码\n-8  [1000]  0 [0000]\n-7  [1001]  1 [0001]\n-6  [1010]  2 [0010]\n-5  [1011]  3 [0011]\n-4  [1100]  4 [0100]\n-3  [1101]  5 [0101]\n-2  [1110]  6 [0110]\n-1  [1111]  7 [0111]\n 0  [0000]  8 [1000]\n 1  [0001]  9 [1001]\n 2  [0010] 10 [1010]\n 3  [0011] 11 [1011]\n 4  [0100] 12 [1100]\n 5  [0101] 13 [1101]\n 6  [0110] 14 [1110]\n 7  [0111] 15 [1111]\n```\n\n上面这样对比着看，应该很清晰了。经过计算得出的移码，刚好等于补码符号位取反，所以移码的定义就简化成了一句话：将补码符号位取反，即为移码。\n\n再说一个有点不好理解的方法，觉得啰嗦略过就好。除去首位的符号位不看，单看剩下的  3 位二进制，-8 到 -1 本身就符合从小到大的规律，而 0 到 7 也是如此，但 [0,7] 要大于  [-1,-8]，强转成无符号数，用符号位的 0 和 1 两个值便可以区分原本的 8 个负数和 8 个非负数，**最终就是将负数转化为了正数，将正数转化为了更大的正数**。\n\n**结束**\n\n至此，关于「**原码 反码 补码 移码**」主题的文章就告一段落了。\n\n段首写了这么一句话：「**抛开复杂的理论，直探事物的本质**」。我是这么理解这句话的，讲一样东西，只有把没什么基础的人都说明白了，说懂了，也不用过多的摆理论、套公式，这样才算是真的讲透彻了，话虽俗，理不俗。\n","tags":["编码"],"categories":["编码"]},{"title":"「原码 反码 补码 移码」一探究竟（中）","url":"/2019/01/76011953e8ea/","content":"---\n上文「原码 反码 补码 移码」一探究竟（上）说了基本定义和原码，对于补码，我们只知道是对原码符号位不变，其他位置取反，最后再加 1 得来的，为何如此呢？接下来咱们来揭下「补码」的面具，看看它到底是什么。\n\n<!--more--> \n\n**0. 关于 1 + (-1)**\n\n首先，先看一个问题。\n\n1 的原码为[0000 0001]，-1 的原码为[1000 0001]，所以计算这两个数相加，应该是这样的：\n\n```\n1 + (-1) \n\n= [0000 0001]原 + [1000 0001]原 \n\n= [1000 0010]原 \n\n= -2\n```\n\n结果竟然是 -2，很明显是错的，这样用原码计算就出问题了。当然，劳动人民的智慧不可估量，总能发现合适的方式来解决各种问题，于是，补码就诞生了，再看用补码计算的过程。\n\n```\n1 + (-1) \n\n= [0000 0001]原 + [1000 0001]原 \n\n= [0000 00001]补 + [1111 1111]补 \n\n= [0000 0000]补 \n\n= [0000 0000]原 \n\n= 0\n```\n\n结果正确，问题得以解决，而这也是计算机都是以补码的形式来存储整数的原因。\n\n但是，为什么用补码计算就能得到正确结果呢？为什么补码的计算方式是原码取反再加 1 呢？带着问题，我们继续往下看。\n\n\n**1. 钟表上的哲学**\n\n钟表，每个人应该都清楚的，上面的数字范围[0,11]，也可以理解为[1, 12]，毕竟上面没有写 0 这个数字，但是不变的是，都可以表示12个小时。\n\n比方说，现在是  9:00，时针指向9。我要想知道 7 个小时之前是几点，那么我只需要将时针向回拨动 7 个格子即可，结果很显然，时针将会指向 2，表示  2:00；但是，我要想知道 5 个小时后是几点呢？也很简单，将时针向前拨动 5 个格子，结果也很显然，时针也会指向 2，表示 2:00。\n\n通过不同方式，我们得到了同样的结果，**也就是说在钟表上，9 - 7 = 9 + 5 = 2**。不仅 7 和 5 有这样的规律，8 和 4、9 和 3等都有这样的规律，也就是说，相加等于 12 的两个数都符合这样的规律，即 **X - Y = X + (12 -Y)**，而 12 在这里有个名字，叫做这个钟表的**模**，12 - Y 叫做 Y 的**补数**。\n\n**减去一个数，等于加上这个数的补数，应用这个规律就可以将减法转换为加法了。**\n\n那么问题来了，模长该怎么求？\n\n\n**2. 通俗的「模」**\n\n通俗的讲，很简单。还是拿钟表举例，上面能表示的数字的总数就是其模长，所以不管是[0, 11]，还是[1, 12]，都为12。\n\n再来看 8 位二进制，其原码能表示的范围 (注意看，这里说的是原码)，**[1111 1111] ~ [0111 1111]**，即 **[-2^7 - 1, 2^7 - 1]** = **[-127, 127]**，因为我们是要将其全部转变为非负数，即能表示的范围为[0, 127]，所以模长为 128。\n\n说完了这些，我们再来重新看下 -3 的补码的计算过程。-3 原码为 **[1000 0011]**，而**取反的过程实际上等同于用[0111 1111]减去 -3 原码中的符号位之外的部分**，之后再加 1 即得到补码，所以：\n\n```\n-3 补码(未添加符号位)\n\n= [1000 0011]原 取反 + [0000 0001]\n\n= [0111 1111] - [0000 0011] + [0000 0001]\n \n= [0111 1111] + [0000 0001] - [0000 0011]\n \n= [1000 0000] - [0000 0011]\n\n= 128 - [0000 0011]\n\n= 模  - [0000 0011] \n\n= 模  - 3\n```\n\n看到这，是不是一下就明白了？**补码实际上就是模减去原码的值，再加上一个符号位，也就是所说的：符号位不变，取反再加1**。\n\n所以，在计算机中，整数都是以补码的形式存储的，是为了统一加减法运算。因为计算机之中是没有做减法的逻辑门，减法都会被转化为加法来完成计算。\n\n而通过溢出，符号位也可以直接参与计算，大大简化了计算过程，看个例子就明白了。\n\n```\n7 + （-3）\n\n= [0000 0111]原 + [1000 0011]原 \n\n= [0000 0111]补 + [1111 1101]补 \n\n= [0000 0100]补 (溢出部分不用处理)\n\n= [0000 0100]原 \n\n= 4 \n\n2 + （-3）\n\n= [0000 0010]原 + [1000 0011]原 \n\n= [0000 0010]补 + [1111 1101]补 \n\n= [1111 1111]补 \n\n= [1000 0001]原 \n\n= -1\n```\n\n再看个特例。\n\n```\n-1 + (-127) \n\n= [1000 0001]原 + [1111 1111]原 \n\n= [1111 1111]补 + [1000 0001]补 \n\n= [1000 0000]补 \n\n= -128\n```\n\n用原码能表示的最小负数为 **-127**，补码却能表示的最小负数为 **-128**，但是 **-128** 没有原码和反码表示，由于计算机中使用补码表示整数，所以这没有影响，因此 8 位二进制数，也就是 **byte** 类型能表示的范围是 **[-128, 127]**。\n\n说到这，对于补码，应该足够清晰了吧！","tags":["编码"],"categories":["编码"]},{"title":"「原码 反码 补码 移码」一探究竟（上）","url":"/2019/01/8ebb2c9120f0/","content":"\n> 抛开复杂的理论，直探事物的本质。\n\n**0. 二进制**\n\n相比于二进制，十进制数字大家都比较熟悉。从右往左依次是个位、十位、百位、千位等，每个位置上的数字范围 [0, 9]。个位上的 1 表示 1，十位上的 1 表示 10，百位上的 1 表示 100，即从右向左的第 n 位就代表 10^(n-1)：\n<!--more--> \n```\n761 = 7*100 + 6*10 + 1*1 = 7*10^2 + 6*10^1 + 1*10^0\n```\n\n而二进制，也是同样的道理，区别就是将 10 的 n-1 次幂变成了 2 的 n-1 次幂：\n\n```\n1101 = 1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 8 + 4 + 0 + 1 = 13\n```\n\n有了这些基础概念，接着再来看下面的内容。\n\n**1.** **这些「码」都是什么？**\n\n**计算机中的数字一般分为两种，有符号数和无符号数。**\n\n**原码**，是一种计算机中对数字的二进制表示的方法。\n\n**有符号数**，即用最高位的二进制位来表示正负，剩下的位来存储数据。\n\n**无符号数**，即所有的二进制位都来表示数据，所以无符号数字无法表示负数，全部大于等于 0。\n\n光看定义干巴巴的，用长度为 8 位二进制的类型举几个例子。\n\n有符号数，最高位表示正负，0 表示正数，1 表示负数。\n\n```\n   7 : [0000 0111]原\n  -3 : [1000 0011]原\n-127 : [1111 1111]原\n```\n\n无符号数，没有符号位，全部二进制位用来表示数据。\n\n```\n  7 : [0000 0111]原 \n 16 : [0001 0000]原\n255 : [1111 1111]原\n```\n\n上面就是原码的定义，而反码、补码、移码都是在原码的基础上做了对应的变换。\n\n**反码**：正数的反码就是其原码，负数的反码为，符号位不变，其余位取反，即 0 变 1，1 变 0。\n\n**补码**：正数的补码就是其原码，负数的补码为在其反码的基础上再加 1，而在计算机中，整数都是以补码的形式存储的。\n\n**移码**：将补码符号位取反，即为移码。\n\n**这几种码都是针对有符号数，而无符号数用原码就足够了**，后面会对此说明原因。同样，也举几个例子说明。\n\n```\n 7 : [0000 0111]原 [0000 0111]反 [0000 0111]补 [1000 0111]移\n-3 : [1000 0011]原 [1111 1100]反 [1111 1101]补 [0111 1101]移\n```\n\n关于定义，就说这些。既然原码就能表示数字，那为什么又会有这么多类型的码呢？而这些不同的码又是怎么来的呢？计算机中为什么要以补码而不是其他码来存储整数呢？移码又是做什么的呢？鉴于篇幅过长，下篇文章，会对这些问题一一说明。\n","tags":["编码"],"categories":["编码"]},{"title":"Goland调整Terminal窗口字体大小","url":"/2018/12/44fb710f68f6/","content":"\nGoland的Ternimal窗口样式和Console窗口公用同一个样式，修改路径:\n> Setting->Editor->Color Scheme->Console Font\n\n若不生效，重启一下IDE即可。\n<!--more--> \n\n![](https://i.loli.net/2021/07/07/pkb8qoWm7RzV2ij.png)\n","tags":["GoLand"],"categories":["Golang"]},{"title":"Golang websocket client读取数据","url":"/2018/11/f0d738b44296/","content":"\nGolang 既可以写 websocket 的 server 端也可以写 websocket 的 client 端，前者网上的资料很多后者甚少，今天遇到写 client 的需求，在此做个总结。\n\n- 测试地址：火币网\n- websocket包：golang.org/x/net/websocket\n<!--more--> \n### 1. 建立连接。\n连接成功建立后，client 和 server 均可以随时往数据通道里写数据同时也可以从中读取数据。\n\n```golang\nvar wsurl = \"wss://api.huobi.pro/ws\"\nvar origin = \"http://api.huobi.pro/\"\nws, err := websocket.Dial(wsurl, \"\", origin)\nif err != nil {\n    panic(err)\n}\n```\n### 2. 写数据。\n在通道已建立的前提下，写数据操作通过一行代码即可完成：\n\n```golang\nfunc sendMessage(data []bytes) {\n\tws.Write(msg)\n}\n```\n### 3.1 读数据。\n最简单的方法是调用`func (ws *Conn) Read(msg []byte) (n int, err error)`方法，定义一个用来接收数据的`[]byte`数组当作参数传入，但是由于不知道server发来的数据长度，所以一般是定义一个足够大的字节`[]byte`数组，这样读取一来浪费内存二来处理起来麻烦，不建议使用；\n\n```golang\nfunc readMessage(ws *websocket.Conn) {\n\tdata := make([]byte, 1024*10)\n\t_, err := ws.Read(data)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n```\n### 3.2 读数据。\n对于都是以json方式传输的数据，websocket包提供了将每条message读取到一个`interface{}`中的方法，等同于`json.Unmarshal`。\n\n```golang\nfunc readJsonMessage(ws *websocket.Conn) {\n\tvar data interfact{} // data的类型为接收的JSON类型struct\n\terr := websocket.Message.Receive(ws, data)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n```\n### 3.3 读数据。\n3.2是将接收到的数据直接unmarshal到struct里了，而我的需求比这个要麻烦一点：server发来的数据`[]byte`数组是压缩过的，所以接收到数据后第一步应该解压缩然后才能unmarshal，所以不能再用3.2的方式，参照3.2的源码，实现方式如下。\n\n```golang\nfunc readOriginMessage(ws *websocket.Conn) {\n\tagain:\n\t\tfr, err := ws.NewFrameReader()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"new frame reader err %v\", err)\n\t\t\treturn\n\t\t}\n\t\tframe, err := ws.HandleFrame(fr)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"handle frame err %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif frame == nil {\n\t\t\tgoto again\n\t\t}\n\t\t\n\t\tbytes, err := ioutil.ReadAll(frame)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"read frame data err %v\", err)\n\t\t}\n\t\tunzipData, err := utils.UnzipByte(bytes)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"unzip data err %v\", err)\n\t\t}\n\n\t\tvar message map[string]interface{}\n\t\te := json.Unmarshal(unzipData, &message)\n\t\tif e != nil {\n\t\t\tlog.Printf(\"unmarshal err %v\", e)\n\t\t}\n\t\t\n\t\tlog.Printf(\"message content= %+v\", message)\n}\n```","tags":["Goland","websocket"],"categories":["Golang"]},{"title":"Android WebView加载URL不显示图片","url":"/2018/10/ab916a013a16/","content":"---\n偶然遇到的一个问题\n<!--more--> \n```java\n        WebSettings settings = mWebView.getSettings();\n        settings.setJavaScriptEnabled(true);//启用js\n        settings.setBlockNetworkImage(false);//解决图片不显示\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            settings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);\n        }\n```\n","tags":["Android","WebView"],"categories":["Android"]},{"title":"Program type already present: org.iq80.leveldb.CompressionType","url":"/2018/08/f07f2aa62201/","content":"---\n添加新依赖时遇到一个报错。\n<!--more--> \n今天在Android Studio添加了一个新的依赖：\n```\nimplementation (\"org.ethereum:ethereumj-core:$ethereumj_version\")\n```\n然后`Sync`可以通过，但是`Rebuild`报错如标题，往上搜了几个方法都未奏效，最后只好顺着问题找答案。\n\n报错的内容就是说`CompressionType`重复了，换句话说，添加的新依赖不添加这个即可。双击`Shift`全局搜索`CompressionType`定位，如图：\n![](https://i.loli.net/2021/07/07/nOSFvNhZ4BTgCmE.png)\n\n添加依赖时增加：\n\n```\n implementation (\"org.ethereum:ethereumj-core:$ethereumj_version\") {\n        exclude group: 'org.iq80.leveldb', module: 'leveldb-api'\n    }\n```\n`Sync`通过，`Rebuild`又报新错误：\n\n```\nMore than one file was found with OS independent path 'META-INF/spring.tooling'\n```\n在`android`节点增加配置：\n\n```\nandroid {\n\tpackagingOptions {\n        pickFirst 'META-INF/*'\n    }\n}\n```\n继续`Sync`，通过；`Rebuild`，通过。\n\n问题解决。","tags":["Android","Gradle"],"categories":["Android"]},{"title":"[翻译]种子词","url":"/2018/08/a8ab36581124/","content":"\n> 原文地址：https://en.bitcoin.it/wiki/Seed_phrase\n\n### 种子短语\n种子短语、种子恢复短语或备用种子短语是存储恢复比特币钱包所需的所有信息的单词列表。钱包软件通常会生成一个种子短语并指示用户将其写在纸上。如果用户的电脑坏了或者他们的硬盘坏了，他们可以再次下载相同的钱包软件，使用纸质备份来取回他们的比特币。\n<!--more--> \n任何发现这个短语的人都可以偷比特币，所以比特币必须保存的像珠宝或现金一样安全。例如，它不能被键入任何网站。\n\n种子短语是备份和存储比特币的好方法，因此几乎所有受好评的钱包都使用它们\n\n#### 举例\n种子短语的一个例子是:\n```\nwitch collapse practice feed shame open despair creek road again ice least\n```\n单词的顺序是很重要的。\n\n#### 解释\n关于种子短语如何工作的一个简单的解释是，钱包软件有一个从字典中提取的单词列表，每个单词被分配给一个数字。种子短语可以转换为一个数字，该数字用作种子整数，以生成钱包中使用的所有密钥对的确定性钱包。\n\nBIP39标准2048字的英文词库,如果这个词只包含12个随机的单词,可能的组合的数量将是2048 ^ 12 = 2 ^ 132，并且短语有132位安全性。但是，BIP39短语中的一些数据不是随机的，所以12个单词的BIP39种子短语的实际安全性只有128位。这与所有比特币私钥的强度大致相同，因此大多数专家认为它足够安全。\n\n发明你自己的种子短语并不安全，因为人类不善于产生随机性。最好的方法是让钱包软件生成你写下的短语。\n\n#### 双重种子短语\n种子短语和所有备份一样，可以存储任意数量的比特币。这是一个令人担忧的想法，可能有足够购买整个建筑的钱，却只是写在一张纸上而没有任何保护。由于这个原因，许多钱包使得用密码加密种子短语成为可能。\n\n密码可用于创建一个双因素种子短语，其中需要“你拥有的东西”和“你知道的东西”才能解锁比特币。\n\n它的工作原理是钱包创建一个种子短语并向用户询问密码。然后需要种子短语和额外的单词，才能恢复钱包。Electrum和其他一些钱包把密码短语叫做“种子扩展”，“扩展词”或者“第13 /25个单词”。BIP39标准定义了一种保护种子短语的方法。在Electrum标准中也使用了类似的方案。如果没有密码，则使用空字符串“”。\n\n警告:忘记这个密码将导致比特币钱包和任何钱包里包含的钱丢失。不要高估你记住密码的能力，尤其是当你可能不经常使用密码的时候。\n\n警告:种子短语密码不应该与用于加密磁盘上钱包文件的密码混淆。这可能就是为什么许多钱包称它为扩展词而不是密码。\n\n#### 诱骗的钱包\n这个功能还提供了貌似合理的可否认性，因为每个密码都会生成一个有效的钱包，但只有正确的密码才会让你想要的钱包可用。您可以创建一个具有相同种子短语但不同密码的诱骗钱包，如果身体上被迫，那么只显示第一个密码，并将第二个密码保密。\n\n另一方面，强迫你的实体可能已经知道诱骗钱包的概念。他们可以继续打你，直到你放弃两三个密码。\n\n关于这个问题的更长的讨论，请参见存储比特币# 5美元扳手攻击\n\n#### 长期储存种子短语\n大多数人在纸上写下短语，但也可以用许多其他的方式来存储，比如记忆、雕刻金属、在书页空白处写字、刻石碑或任何其他有创意的方式。\n\n用铅笔在纸上书写要比用钢笔书写好得多。纸张应无酸味或档案纸，存放在黑暗中，避免高温和潮湿。\n\n有些人想把他们的短语分开。在一个地方储存6个单词，在另一个地方储存6个单词。这是一个糟糕的想法，不应该这样做，因为如果一组6个单词被发现，那么就更容易对剩下的短语进行暴力攻击。像这样在多个地方存储比特币应该通过多签名钱包来实现。\n\n另一个坏主意是添加一些对你有意义的随机假词，然后把它们删除，只留下12个单词短语。这个短语来自于一本已知的字典(见下一节)，所以任何人都可以用那本字典来除去假词。\n\n在同一张纸上写一些解释的词，这可能是个好主意。如果长期储存，你可能会忘记一个短语应该如何处理。可以加以修改的示例解释是:\n\n    这十二个字控制着比特币。保管好这张纸，像现金或珠宝一样保密。本文中的比特币信息用密码加密。它是一个多  签名钱包的一部分，是在2012年1月1日由电子比特币钱包软件制作的。\n\n#### 单词列表\n一般来说，种子短语只适用于创建它的相同的钱包软件。如果储存的时间很长，最好也写上钱包的名字。\n\nBIP39英语单词表中，每个单词都由前四个字母唯一地识别出来，这在空间有限的情况下是很有用的。\n\n#### 替代的名字“助记词”\n种子短语有时被称为“助记短语”，特别是在古老的文学作品中。这是一个不好的名字，因为单词助记意味着这个短语应该被记住。把它们叫做种子短语没有那么误导人。","tags":["区块链"],"categories":["区块链"]},{"title":"[翻译]比特币确定性钱包","url":"/2018/08/97037d409735/","content":"\n> 原文地址：https://en.bitcoin.it/wiki/Deterministic_wallet\n<!--more--> \n\n### 确定性钱包\n确定性钱包是一种系统，从一个被称为种子的单一起点获取密钥。种子允许用户在不需要任何其他信息的情况下轻松备份和恢复钱包，在某些情况下，用户可以在不知道私钥的情况下创建公共地址。种子通常被串行化为人类可读的字词。\n\n#### 好处\n早期的客户端，如Satoshi客户端，会生成一个新的随机私钥缓冲区，在将来用作接收和更改地址。在短时间内耗尽密钥池缓冲区(通常是100个地址)后，这将使备份失效。确定性钱包可以在动态中产生无限数量的地址，因此不会受到这个问题的影响。由于地址是以一种已知的方式生成的，而不是随机生成的，一些客户端可以在多个设备上使用，而不会造成资金损失。用户可以方便地以人类可读的格式创建种子的单个备份，这种格式将持续钱包的使用寿命，而不必担心这种备份会变得过时。\n特定类型的确定性钱包(BIP0032, Armory, Coinkite和Coinb)额外允许完全分离私有和公共密钥的创建，以获得更大的安全性和方便性。在这个模型中，服务器可以设置为只知道特定确定性钱包的主公钥。这允许服务器创建尽可能多的公钥来接收资金，但是MPK协议不会允许攻击者从钱包中花钱。它们也可以在Electrum和Armory中使用，以实现完全离线存储和花费，离线计算机知道私钥，而在线的计算机只知道MPK。通过USB存储器，两种计算机之间可以通过USB存储器进行交易，避免将离线计算机暴露给基于网络的攻击。\n由硬件钱包(TREZOR)实现的确定性钱包将生成的私钥保持离线状态，即使花钱时也不将它们暴露给计算机。\n\n#### 类型\n#### 类型1 确定性钱包\n类型1确定性钱包是一种从已知的起始字符串生成地址的简单方法，因此它不允许高级功能，如主公钥。要生成一个私钥，需要使用SHA256(string + n)，其中n是一个ascii编码的数字，它从1开始，并随着需要额外的键而增加。\n这种类型的钱包可以由Casascius比特币地址实用程序创建。\n#### 类型2 分层确定性钱包\n这种钱包类型在bip0032中进行了描述，并在TREZOR、Electrum和CarbonWallet中得到了充分的实现。种子是一个随机的128位值，用户可以使用常用的英语单词作为12个单词的种子短语。该种子在10万轮SHA256之后使用，以减缓对弱用户选择字符串的攻击。\n这种钱包类型的最初描述和工作原理都归功于格雷戈里·麦克斯韦。\n#### Armory确定性钱包\nArmory有自己基于“根键”和“链码”的2型确定性钱包格式。早期版本的Armory需要备份“根键”和“链码”，而较新的版本则以不可逆转的方式从私钥派生链码。这些新的Armory(0.89+)只需要一个256位的根键。这种旧格式打算逐步淘汰，以支持标准BIP0032格式。","tags":["区块链","Bitcoin"],"categories":["区块链"]},{"title":"[翻译]Bitcoin Address介绍","url":"/2018/08/6dcc04b57a51/","content":"\n> 原文地址: https://en.bitcoin.it/wiki/Address\n<!--more--> \n## 地址\n\n一个比特币地址或是一个简单地址，是一个26-35个字母或数字组成的标识符，以数字1或3开头，这代表了比特币支付的可能目的地。任何比特币的使用者不需要任何话费便可以生成地址。例如使用Bitcoin Core客户端，点击“New Address“就会被分配一个地址。通过一个交易所账号或者在线钱包服务来获得比特币地址也是可能的。目前正被使用中的地址有3种格式：\n 1. P2PKH类型，以数字`1`开头，例如：`1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2`.\n 2. P2SH类型，以数字`3`开头，例如：`3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy`.\n 3. Bech32类型，以`bc1`开头，例如：`bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq`.\n\n\n#### 比特币地址是一个一次性的令牌\n就像e-mail地址，你可以通过向一个人比特币地址中的一个地址发送比特币来实现给这个人发送比特币。然而，和e-mail地址不同的是，一个人可以拥有很多比特币地址，每一次交易应该使用一个唯一的地址。大多数比特币软件和网站都会帮助你在每次创建发票或付款请求时生成一个全新的地址。\n\n#### 地址可以离线创建\n创建地址无需互联网连接，也不需要与比特币网络进行任何联系或注册。可以使用免费的软件工具创建大量离线地址。生成大量地址在几个场景很有用，比如电子商务网站，为每个选择“用比特币支付”选项的客户提供一个唯一的预先生成的地址。较新的“HD钱包”可以生成一个“种子”令牌，可以用来让不受信任的系统(如webservers)生成无限数量的地址，而无需花费接收到的比特币。\n\n#### 地址通常是区分大小写和准确的\n旧式的比特币地址是大小写敏感的。比特币的地址应该尽可能地使用电脑的剪贴板复制和粘贴。如果你手工键入一个比特币地址，而每个字符都没有被准确地转录(包括大写)，那么不正确的地址很可能会被比特币软件拒绝。你必须检查你的条目，然后再试一次。一个输入错误的地址被接受为有效的概率是1 / 232，也就是大约1 / 42.9亿。新型bech32地址不区分大小写。\n\n#### 证明你收到了一个地址\n大多数比特币钱包都有一个“签名”信息的功能，这可以证明接收资金的实体已经同意该信息。例如，这可以用于在支付合同之前，以一种加密的可验证的方式确定合同。\n有些服务还将利用这种功能，只指定一个特定的地址进行身份验证，在这种情况下，该地址永远不应该用于实际的比特币交易。当您登录或使用他们的服务时，您将提供一个签名，证明您与预先商定的地址相同。\n值得注意的是，这些签名仅仅证明一个人收到了一个地址。由于比特币交易没有“来自”地址，你无法证明你是资金的发送者。\n目前的消息签名标准仅与“0版本”的比特币地址(以数字1开头)兼容。\n\n#### 地址验证\n如果希望在应用程序中验证比特币地址，建议使用[这个线程中](https://bitcointalk.org/index.php?topic=1026.0)的方法，而不是只检查字符串长度、允许的字符，或者地址以1或3开头。验证还可以使用[各种语言](http://rosettacode.org/wiki/Bitcoin/address_validation)的开放源代码或使用[在线验证工具](http://lenschulwitz.com/base58)进行。\n\n#### 多重签名的地址\n可以创建需要多个私钥组合的地址。由于它们利用了较新的特性，所以它们以较新的前缀3而不是旧的1开始。这可以被看作是向两方开出支票——“支付给某人和其他人的订单”——双方必须在支票上签字以获得资金。\n必须满足的实际需求(所需的私钥数量、相应的公钥等)是由生成此类地址的人预先决定的，一旦创建了地址，就不能在不生成新地址的情况下更改该需求。\n\n#### 一个地址里有什么\n大多数比特币的地址是34个字符。它们由随机数字、大写字母和小写字母组成，除了大写字母“O”、大写字母“I”、小写字母“l”和数字“0”从未使用来避免视觉上的歧义。\n一些比特币地址可以短于34个字符(少到26个字符)，但仍然有效。相当大比例的比特币地址只有33个字符，有些甚至可能更短。每个比特币地址代表一个数字。这些较短的地址是有效的，因为它们代表的是恰好以0开头的数字，当这些0被省略时，编码的地址就会变短。\n比特币地址中有几个字符被用作校验和，因此可以自动查找和拒绝排版错误。校验和还允许比特币软件确认一个33个字符(或更短)的地址实际上是有效的，而不是一个缺少字符的地址。\n\n#### 测试网络\n比特币Testnet上的地址是用不同的地址版本生成的，这会产生不同的前缀。有关详细信息，请参阅地址前缀和Testnet列表。\n\n### 误解\n\n#### 地址重用\n地址不打算被使用多次，这样做有许多相关的问题。有关地址重用的详细信息，请参阅专门的文章。\n\n#### 地址余额\n地址不是钱包或账户，也没有余额。他们只收钱，而你在任何时候都不发送“从”地址。各种混乱的服务和软件显示'用一个地址接收比特币',从随机不相关的交易中减去已发送的比特币作为一个'地址余额',但这个数字是没有意义的:它并不意味着向这个地址发送的比特币的接收者已经花掉了它们，也不意味着他们仍然持有接收的比特币。\n这种误解造成比特币损失的一个例子是，人们认为他们的地址包含3btc。他们花了0.5比特币，认为地址现在包含2.5比特币，而实际上它包含零比特币。剩余的2.5比特币被转移到一个没有备份的更改地址，因此丢失。这发生在一些使用纸质钱包的用户的场合。\n\n#### “从“地址\n比特币交易没有任何来源——来源——或“来自”地址。有关“来自地址”的详细信息，请参阅专门的文章。\n\n#### 地址图\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S43U7xMP-1625627005514)(https://en.bitcoin.it/w/images/en/4/48/Address_map.jpg)]\n","tags":["区块链","Bitcoin"],"categories":["区块链"]},{"title":"Linux服务器常用命令","url":"/2018/07/6e2872c17d01/","content":"我常用到的是这几个：\n<!--more--> \n### systemctl\n- systemctl status name.service\n   查看某个服务的状态\n- systemctl | grep name-partern\n   过滤显示所有服务名符合name-partern的服务\n- systemctl enable name.service\n   设置开机自启\n- systemctl restart name.service\n  重启服务\n\n### journalctl\n- journalctl -f -u unit-name\n  实时查看某个服务的log\n- journalctl --since 18:34 --until 19:12 -u unit-name\n  查看某个服务在该时间段内的log\n- journactl --since '2018-07-29 19:00' --until now -u unit-name\n  查看时间段内的日志\n\n### grep\n- grep -E 'regex'\n  根据正则表达式过滤\n- grep -w 'wrod'\n  根据单词word过滤\n- grep -c 'target'\n  显示过滤后的行数\n\n### tail\n- tail -n 2000 file.name\n  显示文件末尾的2000行内容\n- tail -f file.name\n  实时显示文件最新追加的内容\n- tail -s 1\n  显示内容刷新时间间隔为1秒\n\n### ls\n- ls -l\n  以列表形式显示\n- ls -a\n  显示所有文件\n- ls -h\n  以便于阅读的方式显示\n- ls -S\n  按照文件大小排序\n\n### vi\n- :set nu\n  显示行号\n- :set nonu\n  隐藏行号\n- 0\n  移动光标到行首\n- $\n  移动光标到行尾\n- gg\n  移动光标到内容开头\n- G\n  移动光标到内容结束\n- dd\n  删除行\n- x\n  删除一个字符\n- r\n  替换一个字符\n- R\n  一直替换\n- u\n  撤销上次操作\n- 10 j\n  向下移动光标10行\n- /c[ok]\\\\{1\\\\}mplete\n  查找complete\n","tags":["Linux"],"categories":["Linux"]},{"title":"持续集成与自动化测试 Continuous Integration，CI","url":"/2018/05/262671d24b2e/","content":"\n> 所谓持续集成与自动化，是指用机器替代人工持续不间断地集成代码，让产品可以快速迭代，同时还能保证代码质量。一个完整的持续集成环境需要Jenkins与Git、Gerrit一起配合，才能发挥出它最强大的功能。一般来说，在开发者Push代码后会首先到Gerrit进行代码Review。Review分为两部分，一部分是使用程序的自动化Review，主要是通过静态代码检测工具来进行代码质量分析（比如Sonar、CheckStyle、FindBugs等）；另一部分是人工Review，主要检测代码的运行逻辑，当Review完毕后，通过Git hook、Jenkins完成代码的自动拉取、编译和部署，最后通过自动化测试工具完成测试用例，并生成相应的测试报表。这样一整个测试流程需要人工来做的也就是人工代码Review部分，而其他部分全部通过自动化来实现，甚至可以在半夜对程序进行不间断Monkey测试，测试稳定性和潜在问题。\n<!--more--> \n**摘自《Android群英传：神兵利器》**","tags":["Android","CI"],"categories":["Android"]},{"title":"Java继承机制的弊端","url":"/2018/05/d71d19b7fe7b/","content":"\n转载，原文链接:http://www.sunxin.org/forum/thread/20672.html# \n\n为什么Java中继承多数是有害的 \n<!--more--> \n大多数好的设计者象躲避瘟疫一样来避免使用实现继承(`extends` 关系)。实际上80%的代码应该完全用`interface`写,而不是通过`extends`。Java设计模式一书详细阐述了怎样用接口继承代替实现继承。这篇文章描述设计者为什么会这么作。 \n\n`Extends`是有害的;也许对于*Charles Manson*这个级别的不是,但是足够糟糕的它应该在任何可能的时候被避开。JAVA设计模式一书花了很大的部分讨论用`interface`继承代替实现继承。 \n\n好的设计者在他的代码中,大部分用`interface`,而不是具体的基类。本文讨论为什么设计者会这样选择,并且也介绍一些基于`interface`的编程基础。 \n\n- 接口(`Interface`)和类(`Class`)? \n\n一次,我参加一个Java用户组的会议。在会议中,*Jams Gosling*(Java之父)做发起人讲话。在那令人难忘的Q&A部分中,有人问他:如果你重新构造Java,你想改变什么?。我想抛弃classes他回答。在笑声平息后,它解释说,真正的问题不是由于class本身,而是实现继承(`extends`) 关系。接口继承(`implements`关系)是更好的。你应该尽可能的避免实现继承。 \n\n- 失去了灵活性 \n\n为什么你应该避免实现继承呢?第一个问题是明确的使用具体类名将你固定到特定的实现,给底层的改变增加了不必要的困难。 \n\n在当前的敏捷编程方法中,核心是并行的设计和开发的概念。在你详细设计程序前,你开始编程。这个技术不同于传统方法的形式----传统的方式是设计应该在编码开始前完成----但是许多成功的项目已经证明你能够更快速的开发高质量代码,相对于传统的按部就班的方法。但是在并行开发的核心是主张灵活性。你不得不以某一种方式写你的代码以至于最新发现的需求能够尽可能没有痛苦的合并到已有的代码中。 \n\n胜于实现你也许需要的特征,你只需实现你明确需要的特征,而且适度的对变化的包容。如果你没有这种灵活,并行的开发,那简直不可能。 \n\n对于`Inteface`的编程是灵活结构的核心。为了说明为什么,让我们看一下当使用它们的时候,会发生什么。考虑下面的代码: \n```Java\nf() { \n\tLinkedList list = new LinkedList(); \n\tg(list); \n} \ng(LinkedList list) { \n\tlist.add( ... ); \n\tg2(list) ;\n} \n```\n假设一个对于快速查询的需求被提出,以至于这个`LinkedList`不能够解决。你需要用`HashSet`来代替它。在已有代码中,变化不能够局部化,因为你不仅仅需要修改`f()`也需要修改`g()`(它带有`LinkedList`参数),并且还有`g()`把列表传递给的任何代码。像下面这样重写代码: \n```Java\nf() { \n\tCollection list = new LinkedList(); \n\tg(list); \n} \ng(Collection list) { \n\tlist.add(...); \n\tg2(list);\n} \n```\n这样修改Linked list成hash,可能只是简单的用new HashSet()代替new LinkedList()。就这样。没有其他的需要修改的地方。 \n\n作为另一个例子,比较下面两段代码: \n```Java\nf() { \n\tCollection c = new HashSet(); \n\t//... \n\tg( c ); \n} \ng(Collection c) { \n\tfor(Iterator i = c.iterator(); i.hasNext()) \n\t\tdo_something_with(i.next()); \n} \nf2() { \n\tCollection c = new HashSet(); \n\t//... \n\tg2( c.iterator() ); \n} \ng2(Iterator i) { \n\twhile(i.hasNext()) \n\t\tdo_something_with(i.next()); \n} \n```\n\n`g2()`方法现在能够遍历`Collection`的派生,就像你能够从`Map`中得到的键值对。事实上,你能够写`iterator`,它产生数据,代替遍历一个`Collection`。你能够写`iterator`,它从测试的框架或者文件中得到信息。这会有巨大的灵活性。 \n\n- 耦合 \n\n对于实现继承,一个更加关键的问题是耦合---令人烦躁的依赖,就是那种程序的一部分对于另一部分的依赖。全局变量提供经典的例子,证明为什么强耦合会引起麻烦。例如,如果你改变全局变量的类型,那么所有用到这个变量的函数也许都被影响,所以所有这些代码都要被检查,变更和重新测试。而且,所有用到这个变量的函数通过这个变量相互耦合。也就是,如果一个变量值在难以使用的时候被改变,一个函数也许就不正确的影响了另一个函数的行为。这个问题显著的隐藏于多线程的程序。 \n\n作为一个设计者,你应该努力最小化耦合关系。你不能一并消除耦合,因为从一个类的对象到另一个类的对象的方法调用是一个松耦合的形式。你不可能有一个程序,它没有任何的耦合。然而,你能够通过遵守OO规则,最小化一定的耦合(最重要的是,一个对象的实现应该完全隐藏于使用他的对象)。例如,一个对象的实例变量(不是常量的成员域),应该总是`private`。我意思是某段时期的,无例外的,不断的。(你能够偶尔有效地使用`protected`方法,但是`protected`实例变量是可憎的事)同样的原因你应该不用get/set函数---他们对于是一个域公用只是使人感到过于复杂的方式(尽管返回修饰的对象而不是基本类型值的访问函数是在某些情况下是由原因的,那种情况下,返回的对象类是一个在设计时的关键抽象)。 \n\n这里,我不是书生气。在我自己的工作中,我发现一个直接的相互关系在我OO方法的严格之间,快速代码开发和容易的代码实现。无论什么时候我违反中心的OO原则,如实现隐藏,我结果重写那个代码(一般因为代码是不可调试的)。我没有时间重写代码,所以我遵循那些规则。我关心的完全实用?我对干净的原因没有兴趣。 \n\n- 脆弱的基类问题 \n\n现在,让我们应用耦合的概念到继承。在一个用`extends`的继承实现系统中,派生类是非常紧密的和基类耦合,当且这种紧密的连接是不期望的。设计者已经应用了绰号脆弱的基类问题去描述这个行为。基础类被认为是脆弱的是,因为你在看起来安全的情况下修改基类,但是当从派生类继承时,新的行为也许引起派生类出现功能紊乱。你不能通过简单的在隔离下检查基类的方法来分辨基类的变化是安全的;而是你也必须看(和测试)所有派生类。而且,你必须检查所有的代码,它们也用在基类和派生类对象中,因为这个代码也许被新的行为所打破。一个对于基础类的简单变化可能导致整个程序不可操作。 \n\n让我们一起检查脆弱的基类和基类耦合的问题。下面的类`extends`了Java的`ArrayList`类去使它像一个`stack`来运转: \n```Java\nclass Stack extends ArrayList { \n\tprivate int stack_pointer = 0; \n\tpublic void push( Object article ) { \n\t\tadd( stack_pointer++, article ); \n\t} \n\tpublic Object pop() { \n\t\treturn remove( --stack_pointer ); \n\t} \n\tpublic void push_many( Object[] articles ) { \n\t\tfor( int i = 0; i < articles.length; ++i ) \n\t\t\tpush( articles[i] ); \n\t} \n} \n```\n甚至一个象这样简单的类也有问题。思考当一个用户平衡继承和用`ArrayList`的`clear()`方法去弹出堆栈时: \n```java\nStack a_stack = new Stack(); \na_stack.push(\"1\"); \na_stack.push(\"2\"); \na_stack.clear(); \n```\n这个代码成功编译,但是因为基类不知道关于`stack`指针堆栈的情况,这个`stack`对象当前在一个未定义的状态。下一个对于`push()`调用把新的项放入索引2的位置。(`stack_pointer`的当前值),所以`stack`有效地有三个元素-下边两个是垃圾。(Java的stack类正是有这个问题,不要用它). \n\n对这个令人讨厌的继承的方法问题的解决办法是为`Stack`覆盖所有的`ArrayList`方法,那能够修改数组的状态,所以覆盖正确的操作`Stack`指针或者抛出一个例外。(`removeRange()`方法对于抛出一个例外一个好的候选方法)。 \n\n这个方法有两个缺点。第一,如果你覆盖了所有的东西,这个基类应该真正的是一个`interface`,而不是一个`class`。如果你不用任何继承方法,在实现继承中就没有这一点。第二,更重要的是,你不能够让一个`stack`支持所有的`ArrayList`方法。例如,令人烦恼的`removeRange()`没有什么作用。唯一实现无用方法的合理的途径是使它抛出一个例外,因为它应该永远不被调用。这个方法有效的把编译错误成为运行错误。不好的方法是,如果方法只是不被定义,编译器会输出一个方法未找到的错误。如果方法存在,但是抛出一个例外,你只有在程序真正的运行时,你才能够发现调用错误。 \n\n对于这个基类问题的一个更好的解决办法是封装数据结构代替用继承。这是新的和改进的Stack的版本: \n```Java\nclass Stack { \n\tprivate int stack_pointer = 0; \n\tprivate ArrayList the_data = new ArrayList(); \n\tpublic void push( Object article ) { \n\t\tthe_data.add( stack_poniter++, article ); \n\t} \n\tpublic Object pop() { \n\t\treturn the_data.remove( --stack_pointer ); \n\t} \n\tpublic void push_many( Object[] articles ) { \n\t\tfor( int i = 0; i < o.length; ++i ) \n\t\t\tpush( articles[i] ); \n\t} \n} \n```\n到现在为止,一直都不错,但是考虑脆弱的基类问题,我们说你想要在`stack`创建一个变量, 用它在一段周期内跟踪最大的堆栈尺寸。一个可能的实现也许象下面这样: \n```Java\nclass Monitorable_stack extends Stack { \n\tprivate int high_water_mark = 0; \n\tprivate int current_size; \n\tpublic void push( Object article ) { \n\t\tif( ++current_size > high_water_mark ) \n\t\t\thigh_water_mark = current_size; \n\t\tsuper.push( article ); \n\t} \n\tpublish Object pop() { \n\t\t--current_size; \n\t\treturn super.pop(); \n\t} \n\tpublic int maximum_size_so_far() { \n\t\treturn high_water_mark; \n\t} \n} \n```\n这个新类运行的很好,至少是一段时间。不幸的是,这个代码发掘了一个事实,`push_many()`通过调用`push()`来运行。首先,这个细节看起来不是一个坏的选择。它简化了代码,并且你能够得到`push()`的派生类版本,甚至当`Monitorable_stack`通过Stack的参考来访问的时候,以至于`high_water_mark`能够正确的更新。 \n","tags":["Android","Java"],"categories":["Android"]},{"title":"Android使用netty框架配置SSL适配7.0以上的系统","url":"/2018/05/5483a3584872/","content":"\n最近项目在使用的netty框架加上了SSL安全设置，SSL可单项验证也可双向验证，我使用的是双向验证，即Client验证Server同时Server也验证Client。\n以下只说明Client（Android）端的实现方式。\n<!--more--> \n- 首先需要两个文件，`client.p12`和`cacert.pem`，由服务器端提供。\n- 使用java的`keytool`工具将`cacert.pem`导入到keystore中\n```shell\n$ keytool -import -trustcacerts -keystore /Users/xxx/server.bks -file /Users/xxx/cacert.pem -storetype BKS -provider org.bouncycastle.jce.provider.BouncyCastleProvider\n```\n\n记住这个命令执行后要求输入的密码。\n*（其中的org.bouncycastle.jce.provider.BouncyCastleProvider如何添加使用自行百度即可。）*\n\n- 现在已经有了两个文件`client.p12`和`server.bks`\n- 准备完成，下面进行java实现。\n```java\npublic SSLContext createSSLContext(Context context) {\n        SSLContext sslContext = null;\n        try {\n\t        // 该密码为生成client.p12时设置的密码\n            String keyPassword = \"\";\n            // 该密码为生成server.bks时设置的密码\n            String trustPassword = \"\";\n            \n            // key store manager\n            KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n            InputStream keyInput = context.getResources().openRawResource(R.raw.client);\n            keyStore.load(keyInput, keyPassword.toCharArray());\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyPassword.toCharArray());\n            \n            // trust store manager\n            KeyStore trustStore = KeyStore.getInstance(\"BKS\");\n            InputStream trustInput = context.getResources().openRawResource(R.raw.server);\n            trustStore.load(trustInput, trustPassword.toCharArray());\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            trustManagerFactory.init(trustStore);\n            \n            // assemble\n            sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return sslContext;\n    }\n```\n\n- 接下来配置netty中的SSL\n```java\nclass ClientInitializer extends ChannelInitializer<SocketChannel> {\n\n        private SSLContext mSslContext;\n\n        public ClientInitializer(SSLContext sslContext) {\n            mSslContext = sslContext;\n        }\n        \n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n            ChannelPipeline pipeline = ch.pipeline();\n            SSLEngine sslEngine = mSslContext.createSSLEngine();\n            sslEngine.setUseClientMode(true);\n            pipeline.addFirst(\"ssl\", new SslHandler(sslEngine));\n            pipeline.addLast(\"decoder\", new ClientDecoder());\n            pipeline.addLast(\"encoder\", new ClientEncoder());\n            pipeline.addLast(\"handler\", new ClientHandler());\n\n        }\n    }\n```\n\n- 至此，所有工作就完成了，以上标准配置在android7.0以下的机器上均可正常运行，但是一旦运行到7.0及以上的机器上就会报错\n```java\njavax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found.\n        at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:374)\n        at libcore.net.http.HttpConnection.setupSecureSocket(HttpConnection.java:209)\n        at libcore.net.http.HttpsURLConnectionImpl$HttpsEngine.makeSslConnection(HttpsURLConnectionImpl.java:478)\n        at libcore.net.http.HttpsURLConnectionImpl$HttpsEngine.connect(HttpsURLConnectionImpl.java:433)\n        at libcore.net.http.HttpEngine.sendSocketRequest(HttpEngine.java:290)\n        at libcore.net.http.HttpEngine.sendRequest(HttpEngine.java:240)\n        at libcore.net.http.HttpURLConnectionImpl.getResponse(HttpURLConnectionImpl.java:282)\n        at libcore.net.http.HttpURLConnectionImpl.getInputStream(HttpURLConnectionImpl.java:177)\n        at libcore.net.http.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:271)\n```\n\n经过一番查询验证，在官网上找到了解决办法，[原链接](https://developer.android.google.cn/training/articles/security-ssl#CommonProblems)-不需翻墙即可访问。\n\n**解决方式如下**\n\n- 和服务器端再要一个文件`server.crt`。\n- 准备完成，下面修改java实现\n```java\npublic SSLContext createSSLContext(Context context) {\n        SSLContext sslContext = null;\n        try {\n            String keyPassword = \"\";\n\n             // key store manager\n            KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n            InputStream keyInput = context.getResources().openRawResource(R.raw.client);\n            keyStore.load(keyInput, keyPassword.toCharArray());\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyPassword.toCharArray());\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyPassword.toCharArray());\n\n            // trust store manager\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            InputStream caInput = context.getResources().openRawResource(R.raw.server);\n            Certificate ca;\n            try {\n                ca = cf.generateCertificate(caInput);\n            } finally {\n                caInput.close();\n            }\n            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            trustStore.load(null, null);\n            trustStore.setCertificateEntry(\"CA\", ca);\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            trustManagerFactory.init(trustStore);\n\n            // assemble\n            sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return sslContext;\n    }\n```\n**只需要修改`trust store`的创建方式，其他不需要改动。经过以上修改，程序在所有版本的机器上都可以正常运行了！棒**\n","tags":["Android","Netty"],"categories":["Android"]},{"title":"MySql的modify和change区别","url":"/2018/04/c9ea6aa5bbde/","content":"\n- 相同点：都是用来改变column的属性，change和modify执行成功后都会用本次设置的属性替换column原属性，请注意是【替换】；\n- 不同点：重命名只能使用change\n<!--more--> \n格式（mysql默认不区分大小写）\n\n 1 change\n```\nalter table table_name change current_column_name new_column_name type extra;\n// for example.（如果是改名字需要把column原属性都挂上，因为是替换）\nalter table user change id userid int(11) not null auto_increment;\n```\n 2 modify\n \n\n```\nalter table table_name modify column_name type extra;\n// for example\nalter table user modify id int(11) not null auto_increment;\n```","tags":["MySql"],"categories":["MySql"]},{"title":"「巧用Gradle构建Android应用」读书整理","url":"/2018/04/23aff262eba5/","content":"\n周末看完了「巧用Gradle构建Android应用」，故将新认知整理在此以便以后供自己以及有需要的人查看。\n<!--more--> \nGradle\n\n- Gradle构建过程实际上是执行DAG(Directed Acyclic Graph，有向无环图)，允许定义自己的task并插入到其中。\n  build.gradle中Android块时Android DSL()的入口。\n- 依赖的语法\n```groovy\n//完整语法 (禁用传递依赖)\ntestCompile group: 'junit', name: 'junit', version: '4.12'， transitive: false \n//排除依赖\nandroidTestCompile('org.splckframeword:spock-core:1.0-groovy-2.4') {\n\texclude group: 'org.codehaus.groovy'\n\texclude group: 'junit'\n}\n```\n\n- 配置仓库\n```groovy\nrepositories {\n\tmaven {\n\t// 其中的username值和password值可以写在gradle.properties或者在执行gradlew命令时以参数输入\n\t// ./gradlew -Puser=user_from_pFlag -Ppass=pass_from_pFlag\n\t\tusername 'username'\n\t\tpassword 'password'\n\t}\n\turl 'http://repo.mycompany.com/maven2'\n}\n// 还可以在ext块中配置\next {\n\tif (!project.hasProperty('user')) {\n\t\tdef username = 'alice'\n\t}\n\tif (!project.hasProperty('pass')) {\n\t\tdef password = 'passpass'\n\t}\n}\n```\n\n- 升级Gradle版本\n```groovy\n// 方法一\ntask wrapper(type: Wrapper) {\n\tgradleVersion = 2.12\n}\n./gradlew wrapper\n// 方法二：直接修改gradle-wrapper.properties文件的distributionUrl属性。\n```\n\n- 签名\n```groovy\nandroid {\n\t// ...other section...\n\tsigningConfigs {\n\t\trelease {\n\t\t\tkeyAlias 'my_alias'\n\t\t\tkeyPassword 'password'\n\t\t\tstoreFile file('/Users/kousen/keystores/myapp.ketstore')\n\t\t\tstorePassword 'password'\n\t\t}\n\t}\n}\n// 同样，密码可以放到gradle.properties中，或者以gradlew的参数输入\n```\n\n- 构建类型\n```groovy\nbuildTypes {\n// 加后缀区分可同时安装在同一设备上\n\tdebug {\n\t\tapplicationIdSuffix '.debug'\n\t\tversionNameSuffix '-debug'\n\t}\n}\n```\n\n- 产品定制&纬度\n```groovy\nandroid {\n\tproductFlavors {\n\t\tarrogant {\n\t\t\tdimension 'attitude'\n\t\t\tapplicationId 'com.oreilly.helloword.arrg'\n\t\t}\n\t\tfriendly {\n\t\t\tdimension 'attitude'\n\t\t\tapplicationId 'com.oreilly.helloword.fund'\n\t\t}\n\t\tstark {\n\t\t\tdimension 'client'\n\t\t}\n\t}\n}\n```\n\n- 自定义任务。Grale的DSL API已经存在很多任务，如Copy、Wrapper和Exec等，这些任务可以简单地设置属性然后使用。比如Copy任务所包含的from和into属性。\n```groovy\n// 复制任务\ntask copyApks(type: Copy) {\n\tfrom(\"$buildDir/outputs/apk\") {\n\t\texclude '**/*unsigned.apk', '**/*unaligned.apk'\n\t}\n\tinto '../apks'\n}\n// 显示所有可用任务的变种。这个任务中无论在doLast之前还是之后的所有事情都是在配置阶段执行，\n// doLast块中的代码在运行阶段执行\n// applicationVariants属性只针对com.android.application插件有效\n// libraryVariants属性只针对com.android.library插件有效\ntask printVariantNames() {\n\tdoLast {\n\t\tandroid.applicationVariants.all { variant ->\n\t\t\tprintln variant.name\n\t\t}\n\t}\n}\n// 执行安装所有应用的变种的任务\n// dependsOn属性显示这是配置阶段的一部分，而不是运行阶段。每一个变种名字都被首字母大写了\n// 并且相应的安装任务也被添加到installDebugFlavors任务的一个依赖\ntask installDebugFlavors() {\n\tandroid.applicationVariants.all { v ->\n\t\tif (v.name.endWiths('Debug')) {\n\t\t\tString name = v.name.capitalize()\n\t\t\tdependsOn \"install$name\"\n\t\t}\n\t}\n}\n```\n\n- 延长ADB超时时长\n```groovy\n// 30秒\nandroid {\n\tadbOptions {\n\t\ttimeOutInMs = 30 * 1000\n\t}\n}\n```\n\n- 添加自定义任务到构建过程\n```groovy\n// 基于assembleDebug的依赖意味着在运行copy任务之前所有调试APK都会被生成。\ntask copyApks (type: Copy, dependsOn: assembleDebug) {\n\tfrom(\"$buildDir/outputs/apk\") {\n\t\texclude '**/*unsigned.apk', '**/*unsigned.apk'\n\t}\n\tinto '../apks'\n}\n// 如果想要在每次构建的时候都运行copyApks任务，将其作为build任务的一个依赖\nbuild.dependsOn copyApks\n```\n\n- 排除任务\n```groovy\n> ./gradlw build -x lint\n// Gradle运行时，其组装了一个task graph，通过gradle获得这个图的饮用，所有对这个图的操纵都需要发生\n// 在其构建出来之后，所以需要使用whenReady属性\ngradle.taskGraph.whenReady { graph ->\n\tif (project.hasProperty('nolint')) {\n\t\tgraph.allTask.findAll {\n\t\t\tit.name ==~/lint.*/}*.enabled = false\n\t\t}\n\t}\n}\n```\n\n- 性能\n```groovy\n// gradle.properties\n// 守护进程\norg.gradle.daemon=true\n// 按需配置设置\norg.gradle.configureondemand=true\n// 选择JVM设置 Xmx最大内存 Xms初始内存 XX:MaxPermSize永代久空间 \n// HeapDumpOnOutOfMemoryError发生时，将堆中情况导出到一个文件中\norg.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError\n\n// 使用dex选项\ndexOptions {\n\tincremental true\n\tjavaMaxHeapSize '2g'\n\tjumboMode = true//运载dex文件中出现的大量字符串，可能需要配置ProdGuard\n\tpreDexLibraries = true\n} \n```","tags":["Android","Gradle"],"categories":["读书笔记"]},{"title":"gradle各个版本资源","url":"/2017/12/22d73a690578/","content":"\ngradle官网下载地址:[点击跳转](http://services.gradle.org/distributions/)\n\n但是这个网站有时需要翻墙有时下载速度慢，趁着现在翻墙方便一次性将上面的里程碑版本下了下来\n<!--more--> \n链接: https://pan.baidu.com/s/1i4Fm9Q9 密码: cjfd\n\n**最新更新日期:2017-12-22 18:17:06**(如果想的起来就更新)\n\nps: 如有小更新版本需求, 邮箱联系 : oynix@foxmail.com\n\n\n---\n**如何使用**\n\n当用AndroidStudio打开一个项目长时间卡在build页面，多半是项目所需要版本的gradle在本地没有，AS去上面那个网址下却又下不来。操作如下:\n\n1. 关闭AS, 找到项目所使用gradle的版本, 打开**项目根目录/gradle/wrapper/gradle-wrapper.properties**文件, 里面的**distributionUrl**就是;\n2. 将下载好的对应版本的gradle的zip压缩包复制到gradle本地路径, Windows和Mac相同, **~/.gradle/wrapper/dists/{项目使用的版本}/{一串数字字母的名字}/**, 如果该目录存在则直接替换, 复制完直接将zip解压到当前文件夹, 即解压到**{一串数字字母的名字}**文件夹下, 完成后重新打开AS即可.\n","tags":["Android","Gradle"],"categories":["Android"]},{"title":"HelloKotlin - Error:Gradle-failed to create directory","url":"/2017/12/11b68604d6b4/","content":"---\n今天在看Kotlin-Docs，于是随手建了一个HelloKotlin的项目准备练练手，于是引发了一连串的问题。在此记录过程。\n\n<!--more-->\n\n**环境**\n\n - Windows 7 64bit\n - AndroidStudio 3.0.1\n \n---\n一般的，像下面这样，直接写一个程序入口main函数，跑一些简单代码时不用构建apk省时省力：\n![](https://i.loli.net/2021/07/07/5vgDVB4MTyKipoW.png)\n\n同样的，我想创建一个Kotlin的程序入口。\n创建项目时勾选上Kotlin，AndroidStudio便自动导入Kotlin环境，然后直接新建了一个Hello.kt的文件，里面代码很简单，只有三行，如下：\n\n```kotlin\nfun main(args: Array<String>) {\n\tSystem.out.print(\"Hello Kotlin\")\n}\n```\n**fun**单词前有个彩色的Kotlin Logo，直接点击就可以运行HelloKotlin（按道理这样就可以正常跑起来了，我是这么以为的），**但是，报了下面这个错误**：\n![](https://i.loli.net/2021/07/07/g7Jp9tOwETl6diU.png)\n\n在网上搜索**Error:Gradle:failed to create directory**一番后，找到了解决办法，原来是新版AndroidStudio自带的Aapt2引起的，直接禁用就好：在**gradle.properties**添加如下配置即可：\n\n```\nandroid.enableAapt2=false\n```\n\n再次点击**fun**前面的彩色Kotlin Logo，我以为可以运行了，**但是，又报了下面这个错误**：\n![](https://i.loli.net/2021/07/07/uxXfnlNcjMZeOmP.png)\n\n**IDE说找不到HelloKt.class，然而勤劳的我却凭借双手找到了，措不及防**\n![](https://i.loli.net/2021/07/07/b4U69Lmts1A2qBn.png)\n<br>\n这下我就有点不知所措了。。。\n网上也没查出什么相关参考，又试了几种不同的写法，依然不行，最后不知怎么突然想到修改Gradle版本试试看，事实证明此路可行！\nAndroidStudio 3.0.1创建新项目默认的Gradle版本时4.1，Android Plugin Version是3.0.1。我把HelloKotlin项目向下降了一个版本，即Gradle-3.4，Android Plugin - 2.3.3，去掉DSL method google()\n![](https://i.loli.net/2021/07/07/7LJtogyjH4Od3GV.png)\n\n相应的，Module的build.gradle里一些版本都要下调。\n\n```groovy\n// 部分内容\nandroid {\n    compileSdkVersion 25\n    buildToolsVersion '25.0.3'\n    defaultConfig {\n        applicationId \"com.oy.hellokot\"\n        minSdkVersion 15\n        targetSdkVersion 25\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    ...\n}\n\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile\"org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version\"\n    compile 'com.android.support:appcompat-v7:25.3.1'\n    compile 'com.android.support.constraint:constraint-layout:1.0.2'\n    testCompile 'junit:junit:4.12'\n    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\n}\n```\n\n如上配置以后，再次点击**fun**之前的彩色Kotlin Logo，程序便可以跑起来了。","tags":["AndroidStudio","Kotlin"],"categories":["Kotlin"]},{"title":"Windows下编译OpenSSL","url":"/2017/11/0d432f214850/","content":"---\n\n今天为了获取FB秘钥，里面有个命令openssl，于是网上找了一下教程，众说纷纭，最后可算成功了，在此记录过程。\n<!--more-->\n#### **环境**\n - Windows 64位\n - 已安装Visual Studio 2017 社区版（已过期不过没影响）\n - 已安装Active Perl v5.16.2\n\n#### **准备源码**\n - [OpenSSL官网](https://www.openssl.org/)\n - 或者直接用文中所用的 :  https://pan.baidu.com/s/1pL0vDhx 密码: hndw\n\n---\n#### **过程**\n1. 在Microsoft Visual Studio目录下搜索**vcvarsall.bat**并进入所在目录。\n![](https://i.loli.net/2021/07/07/hbDj3oUKWFLJfuq.png)\n2. 在所在目录下打开cmd，运行`vcvarsall.bat x86_amd64`\n\n\t```sh\n\tC:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build>vcvarsall.bat x86_amd64\n\t[vcvarsall.bat] Environment initialized for: 'x86_x64'\n\t```\n3.  cmd切换到解压完的OpenSSL源码目录运行\n\n\t```sh\nC:\\Users\\it\\Desktop\\openssl-1.0.2m>perl Configure VC-WIN64A\n\t```\n4. 继续运行\n\n\t```sh\nC:\\Users\\it\\Desktop\\openssl-1.0.2m>ms\\do_win64a\n\t```\n5. 继续执行，这步在我的电脑上跑了好几分钟\n\n\t```sh\nC:\\Users\\it\\Desktop\\openssl-1.0.2m>nmake -f ms\\nt.mak \n\t```\n6. 继续执行。执行完第六步之后，编译好的OpenSSL就复制到了`\\usr\\local\\ssl\\lib`路径下，我是在桌面编译的，所以在C盘根目录\n\n\t```sh\nC:\\Users\\it\\Desktop\\openssl-1.0.2m>nmake -f ms\\nt.mak install\n\t```\n\n7. 将OpenSSL路径`C:\\usr\\local\\ssl\\bin`添加到系统路径path里\n\n8. 打开一个新的cmd窗口，运行openssl命令，如图表明成功\n![](https://i.loli.net/2021/07/07/UHcXsjCJErxna65.png)\n\n---\n#### **注意**\n第2步到第3步要在同一个cmd窗口里运行。开始运行第5步不管用，总提示找不到nmake命令，我就直接把nmake.exe（Microsoft Visual Studio目录下搜索到的，同步骤1）直接放到系统路径里了，可以运行，后来发现2、 3只要在同一个cmd窗口就可以了。\n","tags":["Windows","OpenSSL"],"categories":["OpenSSL"]},{"title":"「Effective Java」读书整理","url":"/2017/11/29c00d69eefc/","content":"---\n书地址 ：链接: https://pan.baidu.com/s/1kUAwYgv 密码: ij4j\n<!--more-->\n###  - Chapter 3 适用于所有对象\n#### **8. 重写`equals`方法**\n> 三个原则：对称性、传递性、一致性\n\n#### **9. 重写`equals`方法必定要重写`hashCode`方法**\n> 例如在HashMap中存储时会调用该方法\n\n#### **10. 始终要重写`toString`方法**\n> 便于阅读，使类用起来更加舒适\n\n#### **11. 谨慎的覆盖`clone`方法**\n> 相当于另一个构造器\n\n#### **12. 考虑实现Comparable接口**\n> 用于对象比较、排序（在集合里sort）\n\n----\n\n### - Chapter 4 类和接口\n#### **13. 使类和成员的可访问性最小化(encapsulation)**\n```java\n// 错误方式,安全漏洞; \n// 当域为基本类型或不可变对象时安全;\n// 当为可变对象的引用时存在安全漏洞, VALUE虽不可修改但数组里的对象可被修改\npublic static final Thing[] VALUE = {....};\n// 正确方式\nprivate static final Thing[] PRIVATE_VALUES = {...};\npublic static final List<Thing> VALUES = Collections.unodifiableList(Arrays.asList(PRIVATE_VALUES));\n```\n#### **14. 在公有类中使用访问方法而非公有域**\n> 总有类永远不应该暴露可变域\n\n#### **15. 使可变性最小化**\n成为不可变类的5条规则 :\n\n 1. 不要提供任何会修改对象状态的方法;\n 2. 保证类不会被扩展(fina);\n 3. 使所有域都是final的;\n 4. 使所有域都成为私有的;\n 5. 确保对于任何可变组件的互斥访问.\n\n#### **16. 复合优先于继承**\n> 当B和A的关系为\"is-a\"时，让B继承自A；否则B中应包含一个A的实例（复合），而不是扩展A（继承）。\n\n#### **17. 要么为继承而设计，并提供文档说明， 要么就禁止继承**\n> 1>. 关于程序文档有句格言：*好的API文档应该描述一个给定的方法做了什么工作，而不是描述它如何做到的。*\n\n为了允许继承，类还必须遵守其他一些约束：\n\n - 构造器决不能调用可被覆盖的方法；\n - 无论是clone（Cloneable接口）还是readObject（Serializable接口），都不可调用可覆盖的方法，不管是直接还是间接的方式。\n\n#### **18. 接口优先于抽象类**\n> 抽象类的演变比接口容易；\n> 骨架实现，即接口的简单实现\n\n#### **19. 接口只用于定义类型**\n> 避免常量接口；\n> 接口应该只被用来定义类型\n\n#### **20. 类层次优先于标签类**\n> 标签类过于冗长、容易出错，并且效率底下\n\n\n#### **21. 用函数对象表示策略**\n> 比较器：String.CASE_INSENSITIVE_ORDER\n\n#### **22. 优先考虑静态成员类**\n嵌套类种类\n\n 1. 静态成员类；\n 2. 非静态成员类；\n 3. 匿名类；\n 4. 局部类。\n\n后三种都被称为内部类。\n> 如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成为静态成员类，而不是非静态成员类。如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。例如ViewHolder。\n\n---\n\n### - Chapter 5 泛型\n\n#### 23. 请不要在新代码中使用原生态类型\n\n - `Set` : 原生态类型， 脱离了泛型系统；\n - `Set<?>` : 无限通配符类型，只能包含某种未知对象类型；\n - `Set<Object>`: 参数化类型，可以包含任何对象类型。\n\n```java\nif (o instanceof Set) {\n\tSet<?> m = (Set<?>) o;\n}\n```\n> 原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。\n\n术语 | 示例\n-------| -------\n参数化类型 | `List<String>`\n实际类型参数 | `String`\n泛型 | `List<E>`\n形式类型参数 | `E`\n无限制通配符类型 | `List<?>`\n有限制类型参数 | `<E extends Number>`\n递归类型限制 | `<T extends Comparable<T>>`\n有限制通配符类型 | `List<? extends Number>`\n泛型方法 | `static <E>List<E> asList(E[] a)`\n泛型令牌 | `String.class`\n\n#### **24. 消除非受检警告**\n> @SuppressWarnings(\"unchecked\")要放在一个声明上，要将禁止非受检警告范围缩到最小；每次使用时都要添加一个注释，说明为什么这么做是安全的。\n\n```java\n// 例如ArrayList中的toArray方法, 注解不加在方法上而是单独声明一个局部变量\n// 为的就是缩小非受检警告范围, 这么做是值得的.\npublic <T> T[] toArray(T[] a) {\n\tif (a.length < size) {\n\t\t// This cast is correct because the array we're creating \n\t\t// is of the same type as the one passed in, which is T[].\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tT[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());\n\t\treturn result;\n\t}\n\tSystem.arrayCopy(elements, 0, a, 0, size);\n\tif (a.length > size)\n\t\ta[size] = null;\n\treturn a;\n}\n```\n\n#### **25. 列表优先于数组**\n\n - 禁止创建泛型数组，优先使用集合；\n - 数组是协变且可以具体化的，泛型是不可变的且可以被擦除的。\n - 混合使用时如何得到编译时错误或者警告时，用列表代替数组。\n\n#### **26. 优先考虑泛型**\n> 使用泛型比使用需要在客户端代码中进行转换的类型来的更加安全，也更加容易。只要时间允许，就把现有的类型都泛型化。\n\n#### **27. 优先考虑泛型方法**\n\n```java\n// 递归泛型 类型参数\npublic static <T extends Comparable<T>> T max(List<T> list) {\n\tIterator<T> i = list.iterator();\n\tT result = i.next();\n\twhile (i.hasNext()) {\n\t\tT t = i.next();\n\t\tif (t.compare(result) > 0)\n\t\t\tresult = t;\n\t}\n\treturn result;\n}\n```\n\n#### **28. 利用有限制通配符来提升API的灵活性**\n> 为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。\n> **PECS表示producer-extends，consumer-super**\n> 换句话说， 如果参数化类型表示一个T生产者，就使用<? extends T>；如果表示一个T消费者，就使用<? super T>\n\n```java\n// 用Stack示例\npublic void pushAll(Iterable<? extends E> src) {\n\tfor (E e : src)\n\t\tpush(e);\n}\npublic void popAll(Collection<? super E> dst) {\n\twhile (!isEmpty()) \n\t\tdst.add(pop());\n}\n```\n修改过的使用通配符类型的声明：PECS规则，list生产T实例，T的comparable消费T实例并产生表示顺序关系的整值。comparable始终是消费者，因此使用时始终应该是`Comparable<? super T>`优先于`Comparable<T>`。对于comparator也一样，因此使用时始终应该是`Comparator<? super T>` 优先于`Comparator<T>`\n\n```java\npublic static <T extends Comparable<? super T>> T max(List<? extends T> list)  {\n\t// 这里做了修改\n\tIterator<? extends T> i = list.iterator();\n\tT result = i.next();\n\twhile (i.hasNext()) {\n\t\tT t = i.next();\n\t\tif (t.compare(result) > 0)\n\t\t\tresult = t;\n\t}\n\treturn result;\n}\n```\n#### **29. 优先考虑类型安全的异构容器**\n\n```java\npublic class Favorites {\n\tprivate Map<Class<?>, Object> favorites = new HashMap<Class<?>, Object>();\n\n\tpublic <T> void putFavorite(Class<T> type, T instance) {\n\t\tif (type == null) \n\t\t\tthrow new NullPointerException(\"type is null\");\n\t\tfavorites.put(type, instance);\n\t}\n\n\tpublic <T> T getFavorite(Class<T> type) {\n\t\treturn type.cast(favorites.get(type));\n\t}\n}\n```\n确保永远不违背它的类型约束条件：\n```java\nCollections.checkedXXX();\n```\n利用Class.asSubclass方法进行转换：\n\n```java\npublic <T extends Annotation> T getAnnotation(Class<T> annotationType);\nClass<?> typeOne = Class.forName(typeOneInstance);\ngetAnnotation(typeOne.asSubclass(Annotation.class));\n```\n\n### -Chapter 6 枚举和注解\n#### **30. 用enum代替int常量**\n> 枚举类型有一个自动产生valueOf（String）方法，它将常量的名字转变成常量本身；\n> 枚举中的switch语句适合于给外部的枚举类型增加特定于常量的行为。\n```java\npublic enum Operation {\n\tPLUS(\"+\") {double apply(double x, double y) {return x + y;} },\n\tMIMUS(\"-\") {double apply(double x, double y) {return x - y} },\n\tTIMES(\"*\") {double apply(double x, double y) {return x * y} },\n\tDIVEDES(\"/\") {double apply(double x, double y) {return x / y} };\n\n\tprivate String symbol;\n\tpublic Operation(String sym) {\n\t\tthis.symbol = sym;\n\t}\n\t@Override\n\tpublic void toString() {\n\t\treturn symbol;\n\t}\n\tabstract double apply(double x, double y);\n}\n```\n\n#### **31. 用实例域代替序数**\n> 所有的枚举都有一个`ordinal`方法， 它返回每个枚举常量在类型中的数字位置。永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例中\n\n```java\npublic enum Ensemble {\n\tSOLO(1), DUET(2), TRIO(3);\n\n\tprivate int numberOfMusicians;\n\tpublic Ensemble(int size) {\n\t\tthis.numberOfMusicians = size;\n\t}\n\tpublic int numberOfMusician() {\n\t\treturn numberOfMusicians;\n\t}\n}\n```\n\n#### **32. 用EnumSet代替位域**\n> 正是因为枚举类型要用在集合Set中, 所有没有理由用位域来表示它.EnumSet具有简洁和性能的优势.\n```java\npublic class Text {\n\tpublic enum Style {BOLD, ITALIC, UNDERLINE, STRIKETHROUGH}\n\t\n\t// 所有的Set都可传入, 但是EnumSet最好\n\t// 考虑到可能还有其他实现,所以使用Set<Style>而不是EnumSet<Style>\n\tpublic void applyStyles(Set<Style> styles){...}\n}\n\n// 下面是将EnumSet实例传递给applyStyles方法的客户端代码。EnumSet提供了丰富的\n// 静态工厂来轻松创建集合, 其中一个如下\ntext.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));\n```\n\n#### **33. 用EnumMap代替序数索引**\n\n```java\nMap<Herb.Type, Set<Herb>> herbsByType = new EnumMap<Herb.Type, Set<Herb>>(Herb.Type.class);\nfor (Herb.Type t : Herb.Type.values()) {\n\therbsByType.put(t, new HashSet<Herb>);\n}\nfor (Herb b : garden) {\n\therbsByType.get(b.type).add(b);\n}\n```\n\n#### **34. 用接口模拟可伸缩的枚举**\n> 避免扩展枚举类型(继承), 采用用枚举类型实现接口(实现)\n```java\n// 定义一个接口\npublic interface Operation{...}\n// ExtendOperation实现了这个接口\npublic ExtendOperation implements Operation{...}\npublic static void main(String[] args) {\n\tdouble x = 3.3;\n\tdouble y = 3.4;\n\t// 方法一\n\ttest(ExtendOperation.class, x, y);\n\t// 方法二\n\ttest(Arrays.asList(ExtendOperation.values()), x, y);\n}\n// 方法一 : 确保Class对象既表示枚举又表示Operation的子类型\nprivate static <T extends Enum<T> & Operation> void test(\n\tClass<T> opSet, double x, double y) {\n\tfor (Operation op : opSet.getEnumConstants()) {\n\t\t// do sth\n\t}\n}\n// 方法二 \nprivate static void test(Collection<? extends Operation> opSet, double x, double y) {\n\tfor (Operation op : opSet) {\n\t\t// do sth\n\t}\n}\n```\n\n#### **35. 注解优先于命名模式**\n\n```java\n// 注解类, 只用在无参数的静态方法上\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Test {}\n\n// 测试\nClass testClass = Class.forName(agrs[0]);\nfor (Method m : testClass.getDeclaredMethods()) {\n\t// 判断某个方法是否被Test注解标注\n\tif (m.isAnnotationPresent(Test.class)) {\n\t\ttry {\n\t\t\t// 可直接执行说明是静态方法; 传入null说明无参数\n\t\t\tm.invoke(null);\n\t\t} catch(InvocationTargetException ite) {\n\t\t\t// 1. 实例方法\n\t\t\t// 2. 一个或多个参数\n\t\t\t// 3. 不可访问的方法\n\t\t}\n\t}\n}\n\n// 只有抛出异常才算成功的注解类\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface ExceptionTest {\n\tClass<? extends Exception> value();\n}\n// 待测试的方法\n@ExceptionTest(ArithmeticException.class)\npublic static void method1() {\n\tint i = 0;\n\ti = i / i;\n}\n@ExceptionTest(ArithmeticException.class)\npublic static void method2() {\n\tint[] arr = new int[1];\n\tint i = arr[3];\n}\n@ExceptionTest(ArithmeticException.class)\npublic static void method3() {\n\t// do nothing\n}\n\n// 测试工具类\nif (m.isAnnotationPresent(ExceptionTest.class)) {\n\ttry {\n\t\tm.invoke(null);\n\t} catch (InvocationTargetExcetpion ite) {\n\t\t// 出现的异常类型\n\t\tThrowable exception = ite.getCause();\n\t\t// 期待的异常类型\n\t\tClass<? extends Exception> ex = m.getAnnotation(ExceptionTest.class).value();\n\t\t// 出现的异常与期待的异常时同一种\n\t\tif (ex.instanceOf(exception)) {...}\n\t}\n}\n\n// 多种类型异常注解类\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementTarget.METHOD)\npublic @interface ExceptionsTest {\n\tClass<? extends Exception>[] value();\n}\n// 待测试方法注解\n@ExceptionsTest({IndexOutOfBoundException.class, ArithmeticException.class})\npublic static void method4() {\n}\n```\n\n#### **36. 坚持使用Override注解**\n> IDE可检查\n\n#### **37. 用标记接口定义类型**\n**标记接口，类似于Serializable接口，没有方法，只是一个空接口作为标记，被标记过的实例可以通过ObjectOutputStream处理。**\n两者比较：标记接口和标记注解\n - 标记接口定义的类型是由被标记类的实例实现的；标记注解则是没有定义这样的类型。这个类型允许你在编译时捕捉在使用标记注解的情况下要到运行时才能捕捉到的错误；\n - 标记接口的另一个优点，可以被跟家精确的锁定；\n - 标记注解胜过标记接口的最大优点在于，它可以通过默认的方式添加一个或者多个注解类型元素，给一倍使用过的注解类型添加更多的信息。随着时间的推移，简单类型的标记注解可以演变成丰富的标记注解， 标记接口则不能。\n - 标记注解的另一个优点在于，它们是更大的注解机制的一部分。因此，标记注解在那些支持注解作为编程元素之一的框架中同样具有一致性。\n\n区分使用\n\n - 应用到任何程序元素（方法，字段等）而不是类或者接口，必须用标记注解；\n - 标记类和接口， 优先使用标记接口；\n - 标记只用于特殊接口的元素，将标记定义为该接口的一个子接口；\n - 如果以后需要扩展，用标记注解；\n - 当目标是ElementType.TYPE时，多考虑标记接口。\n\n### -Chapter 7 方法\n\n#### **38. 检查参数的有效性**\n\n - 在方法体的开头检查参数；\n - 使用断言assert，失败时抛出AssertionError；\n - 检查构造器的参数尤为重要\n\n#### **39. 必要时进行保护性拷贝**\n\n- 保护性拷贝是在检查参数有效性之前进行的，并且有效性检查是针对拷贝之后的对象；\n- 对于参数类型可以被不可信任方子类化的参数，请不要使用clone进行保护性拷贝\n\n#### **40. 谨慎设计方法签名**\n\n 1. 谨慎选择方法名称。\n 2. 不要过于追求提供便利的方法。\n 3. 避免过长的参数列表（小于等于4）。\n 4. 对于参数类型，优先使用接口而不是类。\n 5. 对于boolean参数， 优先使用两个元素的枚举类型。\n\n#### **41. 慎用重载**\n\n - 对于重载方法（overloaded method）的选择是静态的，而对于被覆盖的方法（overridden method）的选择是动态的。\n - 避免胡乱使用重载机制的安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法是可变参数，保守策略是根本不要重载它。\n\n#### **42. 慎用可变参数**\n#### **43. 返回零长度的数组或集合，而不是null**\n\n```java\nprivate final List<Cheese> cheeseInStock = ....;\nprivate final static Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];\n\npublic Cheese[] getCheese() {\n\treturn cheeseInStock.toArray(EMPTY_CHEESE_ARRAY);\n}\n\n// 集合值的方法\npublic List<Cheese> getCheeseList() {\n\tif (cheeseOfStock .isEmpty()) {\n\t\treturn Collections.emptyList();\n\t} else {\n\t\treturn new ArrayList<Cheese>(cheeseOfStock);\n\t}\n}\n```\n\n#### **44. 为所有到处的API元素编写文档注释**\n\n### -Chapter 8 通用程序设计\n\n#### **45. 将局部变量的作用域最小化**\n\n - 要是局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。\n - 几乎每个局部变量的声明都应该包含一个初始化表达式，如果没有则应推迟声明。try-catch例外。\n - 如果循环终止之后不再需要循环变量的内容，for循环优于while循环。\n\n```java\n// n的作用是:避免每次循环产生额外计算的开销\nfor (int i = 0 , n = getSize(); i < n; i++) {\n\tdoSomething(i);\n}\n```\n\n#### **46. for-each循环优于传统的for循环**\n\n三种情况无法使用for-each\n 1. 过滤：如果需要遍历集合，并删除选定的元素，就需要使用显示的迭代器，以便可以调用它的remove方法。\n 2. 转换：如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设定元素的值。\n 3. 平行迭代：如果需要并行的遍历多个集合，就需要显示的控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移。\n\n#### **47. 了解和使用类库**\n\n - 使用标准类库而不是专门的实现。\n - Collections Framework\n - java.util.concurrent包含高级并发工具来简化多线程的编程任务，还包含低级别的并发基本类型\n\n#### **48. 如果需要精确的答案， 请避免使用float和double**\n> 使用int或者long或者BigDecimal替代。\n\n#### **49. 基本类型优先于装箱基本类型**\n\n#### **50. 如果其他类型更适合， 则尽量避免使用字符串**\n\n - 字符串不合适代替其他的值类型。\n - 字符串不合适代替枚举类型。\n - 字符串不适合代替聚集类型。\n - 字符串也不适合代替能力表。\n\n#### **51. 当心字符串连接的性能**\n> 使用StringBuilder\n\n#### **52. 通过接口引用对象**\n> 如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明，如List。\n> 如果没哟合适的接口存在，完全可以用类而不是接口来引用对象，如值类String、BigInteger\n\n#### **53. 接口优先于反射机制**\n\n#### **54. 谨慎地使用本地方法**\n> 使用本地方法提高性能的做法不值得提倡\n\n#### **55. 谨慎地进行优化**\n\n - 努力避免那些限制性能的设计决策。\n - 为获得更好的性能而对API进行包装，这是一种非常不好的想法。\n\n#### **56. 遵守普遍接受的命名惯例**\n\n### -Chapter 9 异常\n\n#### **57. 只针对异常的情况才使用异常**\n\n#### **58. 对于可恢复的情况使用受检异常，对编程错误使用运行时异常**\n\n#### **59. 避免不必要地使用受检异常**\n\n#### **60. 优先使用标准的异常**\n\n#### **61. 抛出与抽象相对应的异常**\n> 底层的异常被传到高层的异常，高层的异常提供访问方法（Throwable.getCause）来获得底层的异常\n\n#### **62. 每个方法抛出的异常都要有文档**\n\n#### **63. 在细节消息中包含能捕获失败的信息**\n\n#### **64. 努力使失败保持原子性**\n\n#### **65. 不要忽略异常**\n\n### -Chapter 10 并发\n\n#### **66. 同步访问共享的可变数据**\n> 当多个线程共享可变数据的时候，每个读或者写数据的线程必须执行同步。\n\n#### **67. 避免过度同步**\n\n - 为了避免活性失败和安全性失败，在一个被同步的方法或者代码块中，永远不要放弃对客户端的控制。\n - 在同步区域内做尽可能少的工作。\n - 为了避免死锁和数据损坏，千万不要从同步区域内部调用外来方法。\n\n#### **68. executor和task优先于线程**\n\n#### **69. 并发工具优先于wait和notify**\n\n - 除非迫不得已，否则应该优先使用ConcurrentHashMap，而不是使用Collections.synchronizedMap或Hashtable。只要用并发Map替代老式的同步Map，就可以极大地提升应用程序的性能。更一般地，应该优先使用并发集合，而不是使用外部的同步集合。\n - 对于间歇式的定时，始终应该优先使用System.nanoTime，而不是System.currentTimeMills，前者更加准确也更加精确，它不受系统的实时始终的调整影响。\n - 使用应该使用wait循环模式来调用wait方法；永远不要在循环之外调用wait方法。循环会在等待之前和之后测试条件。\n\n```java\nprivate static final ConcurrentMap<String, String> map = ConcurrentHashMap<>();\n\npublic static String intern(String s) {\n\tString result = map.get(s);\n\tif (result == null) {\n\t\t// 应对并发情况\n\t\tresult = map.putIfAbsent(s, s);\n\t\tif (result == null) {\n\t\t\tresult = s;\n\t\t}\n\t}\n\treturn result;\n}\n```\n\n#### **70. 线程安全性的文档化**\n\n - “出现synchronized关键字就足以用文档说明线程安全性”的这种说法隐含了一个错误的观念，即认为线程安全性是一种“要么全有要么全无”的属性。\n\n线程安全性的几种级别：\n\n 1. 不可变的（immutable）：这个类的实例是不变的。所以，不需要外部的同步。这样的例子包括String、Long和BigInteger。\n 2. 无条件的线程安全（unconditionally thread-safe）：这个类的实例是可变的，但是这个类有着足够的内部同步，所以，它的实例可以被并发使用，无需任何外部同步。其例子包括Random和ConcurrentHashMap。\n 3. 有条件的线程安全（conditionally thread-safe）：除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。这样的例子包括Collections.synchronized包装返回的集合，它们的迭代器（iterator）要求外部同步。\n 4. 非线程安全（not thread-safe）：这个类的实例是可变的。为了并发地使用它们，客户必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如ArrayList和HashMap。\n 5. 线程对立的（thread-hostile）：这个类不能安全地被多个线程并发使用，即使所有的方法调用都被外部同步包围。线程对立的根源通常在于，没有同步地修改静态数据。没有人会有意编写一个线程对立的类；这种类是因为没有考虑到并发性儿产生的后果。幸运的是，在Java平台类库中，线程对立的类或者方法非常少。System.runFinalizersOnExit方法是线程对立的，但已经被废除了。\n\n#### **71. 慎用延迟初始化**\n\n - 在大多数情况下，正常初始化要优先于延迟初始化。如果域只在类的实例部分被访问，并且初始化这个域的开销很高，可能就值得进行延迟初始化。\n\n```java\n// 正常初始化\nprivate final FieldType field = computeFieldValue();\n\n// 延迟初始化，要使用同步访问方法\nprivate FieldType field;\nsynchronized FieldType getField() {\n\tif (field == null)\n\t\tfield = computeFieldValue();\n\treturn field;\n}\n```\n\n - 如果出于性能的考虑而需要对**静态域**使用延迟初始化，就是用lazy initialization holder class模式。这种模式保证了类要到用到的时候才会被初始化。\n\n```java\nprivate static class FieldHolder {\n\tstatic final FieldType field = computeFieldValue();\n}\nstatic Field getField() {\n\treturn FieldHolder.field;\n}\n```\n\n - 如果处于性能考虑而需要对**实例域**使用延迟初始化，就使用双重检查模式。这种模式避免了在域被初始化之后访问这个域时的锁定开销。\n\n```java\nprivate volatile FieldType field;\nFieldType getField() {\n\t// 局部变量result的作用是确保field只在已经被初始化的情况下读取一次,提升性能\n\tFieldType result = field;\n\tif (result == null) {\n\t\tsynchronized(this) {\n\t\t\tresult = field;\n\t\t\tif (result == null)\n\t\t\t\tfield = result = computeFieldValue();\n\t\t}\n\t}\n\treturn result;\n}\n```\n\n - 延迟初始化一个可以接受重复初始化的实例域，可使用单重检查模式。\n \n \n\n```java\nprivate volatile FieldType field;\nprivate FieldType getField() {\n\tFieldType result = field;\n\tif (result == null) \n\t\tfield = result = computeFieldValue();\n\treturn result;\n}\n```\n\n#### **72. 不要依赖于线程调度器**\n> 不要让程序的正确性依赖于线程调度器，否则结果得到的应用将既不健壮也不具有可移植性。作为推论，不要依赖Thread.yield或者线程优先级。\n\n#### **73. 避免使用线程组**\n\n### -Chapter 11 序列化\n\n#### **74. 谨慎地实现Serializable接口**\n> 为了继承而设计的类应该尽可能少地去实现Serializable接口，用户的接口也应该尽可能少地继承Serializable接口。\n> 如果一个类或者一个接口存在的目的主要是为了参与到某个框架中，该框架要求所有的参与者必须实现Serializable接口，这个时候实现或者扩展Serializable接口就很有意义。\n> 内部类不应该实现Serializable，内部类的默认序列化形式是定义不清楚的，然而静态成员类却可以实现Serializable。\n\n```java\npublic class Foo extends AbstractFoo implements Serializable {\n\tprivate void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n\t\ts.defaultReadObject();\n\t\t// Manually deserialize and initialize superclass state\n\t\tint x = s.readInt();\n\t\tint y = s.readInt();\n\t\tinitialize(x, y);\n\t}\n\n\tprivate void writeObject(ObjectOutputStream s) throws IOException {\n\t\ts.defaultWriteObject();\n\t\t// Manually serialize superclass state\n\t\ts.writeInt(getX());\n\t\ts.writeInt(getY());\n\t}\n\t\n\tpublic Foo(int x, int y) {\n\t\tsuper(x, y);\n\t}\n\t\n\tprivate static final long serialVersionUID = 185683560954L;\n}\n```\n\n#### **75. 考虑使用自动以序列化形式**\n\n```java\npublic final class StringList implements Serializable {\n\tprivate int size = 0;\n\tprivate Entry head = null;\n\tprivate static class Entry implements Serializable {\n\t\tString data;\n\t\tEntry next;\n\t\tEntry previous;\n\t}\n\t// ...Remainder omitted\n}\n```\n\n当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下4个缺点：\n\n 1. **它使这个类的导出API永远地束缚在该类的内部表示法上。**在上面的例子中，私有的StringList.Entry类变成了公有API的一部分。如果在将来额版本中，内部表示法发生了变化，StringList类仍将需要接受链表形式的输入，并产生链表形式的输出。这个类永远也摆脱不了维护链表项所需要的所有代码，即使它不再使用链表作为内部结构了，也仍然需要这些代码。\n 2. **它会消耗过多的空间。**在上面的例子中，序列化形式既表示了链表中的每个项，也表示了所有的链接关系，这是不必要的。这些链表项以及链表只不过是实现细节，不值得记录在序列化形式中。因为这样的序列化形式过于庞大，所以把它写到硬盘中，或者在网络上发送都将非常慢。\n 3. **它会消耗过多的时间。**序列化逻辑并不了解对象图的拓补关系，所以它必须要经过一个昂贵的图遍历（traversal）过程。在上面的例子中，沿着next引用进行遍历是非常简单的。\n 4. **它会引起栈溢出。**默认的序列化过程要对对象图执行一次递归遍历，即使对于中等规模的对象图，这样的操作也可能引起栈溢出。到底多少个元素会引发栈溢出，这要取决于JVM的具体实现以及Java启动时的命令行参数，（比如Heap Size的-Xms与-Xmx的值）有些实现可能根本不存在这样的问题。\n\n修订版本，transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉。\n\n```java\npublic final class StringList implements Serializable {\n\tprivate transient int size = 0;\n\tprivate transient Entry head = null;\n\tprivate static class Entry {\n\t\tString data;\n\t\tEntry next;\n\t\tEntry previous;\n\t}\n\t// 添加指定的string到这个集合\n\tpublic final void add(String s) {...}\n\n\t// 重写writeObject方法, 与物理表示法的细节脱离\n\tprivate void writeObject(ObjectOutputStream s) throws IOException {\n\t\ts.defaultWriteObject();\n\t\ts.writeInt(size);\n\t\tfor (Entry e = head; e != null; e = e.next) {\n\t\t\ts.writeObject(e.data);\n\t\t}\n\t}\n\n\t// 重写readObject方法,与write对应\n\tprivate void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n\t\ts.defaultReadObject();\n\t\tint numElements = s.readInt();\n\t\tfor (int i = 0; i < numElements; i++) {\n\t\t\tadd((String) s.readObject());\n\t\t}\n\t}\n\t...// Remainder omitted\n}\n```\n> 尽管StringList的所有域都是瞬时的(transient)，但wirteObject方法的首要任务仍是调用defaultWriteObject，readObject方法的首要任务则是调用defaultReadObject。如果所有的实例域都是瞬时的，从技术角度而言，不调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这样做。即使所有的实例域都是transient的，调用defaultWriteObject也会影响该类的序列化形式，从而极大地增强灵活性。这样得到的序列化形式允许在以后的发行版中增加非transient实例域，并且还能保持向前或者向后兼容性。如果某一个实例将在未来的版本中被序列化，然后在前一个版本中被反序列化，那么，后增加的域将被忽略掉。如果旧版本的readObject方法没有调用defaultReadObject，反序列化过程将失败，引发StreamCorrupted Exception异常。\n> 无论是否使用默认的序列化形式，当defaultWriteObject方法被调用的时候，每一个未被标记为transient的实例域都会被序列化。因此每一个可以被标记为transient的实例域都应该做上这样的标记。这包括那些冗余的域，即它们的值可以根据其他“基本数据类型”计算而得到的域，比如缓存起来的散列值。**在将一个域做成非transient的之前，请一定要确信它的值是该对象逻辑状态的一部分。**如果你正在使用一种自定义的序列化形式，大多数实例域，或者所有的实例域则都应该被标记为transient，就像上面例子中的StringList那样。\n> 如果正在使用默认的序列化形式， 并且把一个或者多个域标记为transient，则要记住，当一个实例被反序列化的时候，这些域将被初始化为它们的默认值。\n> 无论是否使用默认的序列化形式，如果在读取整个对象状态的任何其他方法上强制任何同步，则必须在对象序列化上强制这种同步。\n> 不管选择了哪种序列化形式，都要为自己编写的每个可序列化的类声明一个显示的序列化版本UID（serial version UID）。第一避免不兼容，第二减小额外计算的开销。\n\n```java\npirvate static final long serialVersionUID = randomLongValue;\n```\n> 在编写新类时，为randomLongValue选择什么值并不重要。通过在该类上运行serialver工具，就可以得到这样一个值，但是，凭空编造一个数值也是可以的。如果想修改一个没有序列版本UID的现有的类，并希望新的版本能够接受现有的序列化实例，就必须使用serialver工具为旧版本生成值。\n\n#### **76. 保护性地编写readObject方法**\n> 当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。\n\n指导方针：\n\n - 对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别。\n - 对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。\n - 如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口。\n - 无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。\n\n#### **77. 对于实例控制，枚举类型优先于readResolve**\n> readResolve特性允许你用readObject创建的实例代替另一个实例。对于一个正在被反序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化之后，新建对象上的readResolve方法就会被调用。然后该方法返回的对象引用将被返回，取代新建的对象。在这个特性的绝大多数用法中，指向新建对象的引用不需要再被保留，因此立即成为垃圾回收的对象。\n\n> 总而言之，应该尽可能地使用枚举dang来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控的类，就必须提供一个readResolve方法，并确保该类的所有实例域都为基本类型，或者时transient。\n\n#### **78. 考虑用序列化代理代替序列化实例**\n序列化代理模式相当简单：\n\n 1. 为可序列化的类设计一个私有的静态嵌套类，精确地表示外围类的实例的逻辑状态。这个嵌套类被称作序列化代理，它应该有一个单独的构造器，其参数类型就是那个外围类。这个构造器只从它的参数中复制数据：它不需要进行任何一致性检查或者保护性拷贝。从设计的角度来看，序列化代理的默认序列化形式是外围类最好的序列化形式。外围类及其序列代理都必须声明实现Serializable接口。\n\t \n\t```\n\tprivate static class SerializationProxy implements Serializable {\n\t\tprivate final Date start;\n\t\tprivate final Date end;\n\t\n\t\tSerializationProxy(Period p) {\n\t\t\tthis.start = p.start;\n\t\t\tthis.end = p.end;\n\t\t}\n\t\tprivate static final long serialVerionUID = 302480420480234L;\n\t}\n\t```\n\n 2.  接下来，将下面的writeReplace方法添加到外围类中。通过序列化代理，这个方法可以被逐字复制到任何类中：\n \n\t```\n\tprivate Object writeReplace() {\n\t\treturn new SerializationProxy(this);\n\t}\n\t```\n这个方法的存在导致序列化系统产生一个SerializationProxy实例,代替外围类的实例。换句话说，writeReplace方法在序列化之前，将外围类的实例转变成了它的序列化代理。所以序列化系统永远不会产生外围类的序列化实例，为了避免攻击者伪造，只要在外围类中添加这个readObject方法即可：\n\n\t```\n\tprivate void readObject(ObjectInputStream s) throws InvalidationException {\n\t\tthrow new InvalidationException(\"Proxy required\");\n\t}\n\t```\n\n 3. 最后，在SerializationProxy类中提供一个readResolve方法，它返回一个逻辑上相当于外围类的实例。这个方法使序列化系统在反序列化时将序列化代理转变回外围类的实例。\n这个readResolve方法仅仅利用它的公有API创建外围类的一个实例，这正是该模式的魅力之所在。它极大地消除了序列化机制中语言本身之外的特征，因为反序列化实例是利用与任何其他实例相同的构造器、静态工厂和方法而创建的。这样就不必单独确保被反序列化的实例一定要遵守类的约束条件。如果该类的静态工厂或者构造器建立了这些约束条件，并且它的实例方法在维持着这些约束条件，你就可以确信序列化也会维持这些约束条件。\n上述Period.SerializationProxy的readResolve方法：\n\n\t```\n\tprivate Object readResolve() {\n\t\treturn new Period(start, end);\n\t}\n\t```\n\n---\n- 两个局限性：它不能与可以被客户端扩展的类兼容，它也不能与对象图中包含循环的某些类兼容：如果企图从一个对象的序列化代理的readResolve方法内部调用这个对象的方法，就会得到一个ClassCastException异常，因为还没有这个对象，只有它的序列化代理。\n-  代价：比保护性拷贝进行的开销大。\n- 当必须在一个不能被客户端扩展的类（final）上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。","tags":["Java"],"categories":["读书笔记"]},{"title":"Android YuvImage直接旋转","url":"/2017/10/5fec38fe91ba/","content":"---\n操作相机的`Preview`可通过以下三种方式添加回调接口：\n<!--more--> \n```java\nCamera.setPreviewCallbackBuffer(PreviewCallback);\nCamera.setOneShotPreviewCallback(PreviewCallback);\nCamera.setPreviewCallback(PreviewCallback);\n```\n**PreviewCallback**接口里面只有一个回调方法:\n`void onPreviewFrame(byte[] data, Camera camera);`\n\n其中的`byte[] data`就是`Preview`的图像数据，格式为`YuvImage`，而这个图像天生是横着的，一般的旋转操作是:\nYuvImage的byte[] --> Bitmap的byte[] --> 生成Bitmap --> 旋转Bitmap\n---\n<!--more-->\n**示例代码**\n\n```java\npublic void onPreviewFrame(byte[] data, Camera camera) {\n        final int width = camera.getParameters().getPreviewSize().width;\n        final int height = camera.getParameters().getPreviewSize().height;\n        // 通过YuvImage得到Bitmap格式的byte[]\n        YuvImage yuvImage = new YuvImage(data, ImageFormat.NV21, width, height, null);\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        yuvImage.compressToJpeg(new Rect(0, 0, width, height), 100, out);\n        byte[] dataBmp = out.toByteArray();\n        // 生成Bitmap\n        Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, dataBmp.length);\n        // 旋转\n        Matrix matrix = new Matrix();\n        matrix.setRotate(90);\n        Bitmap bmp = Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix, false);\n        // 保存到本地\n        File file = new File(\"/storage/emulated/0/\" + System.currentTimeMillis() + \".jpg\");\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            bmp.compress(Bitmap.CompressFormat.JPEG, 100, fos);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n## 原理\n---\n实际上，可以直接旋转YuvImage。Camera返回的数据格式默认是`NV21`，即YUV420的YV12，每4个Y共用一组UV分量。换句话说就是假设一张宽为`width`高为`height`的图像，共`sum = width * height`个像素点，那么Y分量一共`sum`个，U分量一共`sum/4`,V分量一共`sum/4`，YUV同RGB类似，都是用来表示图像属性，YUV各占1个byte，所以存储该图像的byte[] 的长度为YUV的数量之和，3/2*sum。\n例如，一张4像素x4像素的图片，存储格式为\n![](https://i.loli.net/2021/07/06/kEtbGrWgdw7qY14.png)\n**每个像素点都有YUV3个分量**，一个方格代表1byte，Y分量顺序排列，之后VU分量交叉排列，Y1、Y2、Y5、Y6共用V1U1分量，也就是说第1个像素点为[Y1 V1 U1]，第2个像素点为[Y2 V1 U1]，第5个像素点[Y5 V1 U1]，第6个像素点[Y6 V1 U1]，同理颜色相同都共用。有了上面的基础再来说旋转，图像旋转就是改变数组中YUV各个分量的位置，变换之后要保证共用关系不能变，即Y1、Y2、Y5、Y6还要共用V1、U1分量，顺时针旋转90度后如下\n![](https://i.loli.net/2021/07/06/v1AquyOJP5bhQfL.png)\n由图可以看出，**简单说就是Y分量部分和VU分量部分分别旋转**\n有了以上的基础，再来总结一下顺时针旋转90后角标对应关系：\n旋转前的图：srcWidth、srcHeight\n旋转后的图：dstWidth、dstHeight（旋转前后宽高对调，即sW=dH、sH=dW）\n先看Y分量，假设旋转后的图中第i行，第j列的一个像素，它的Y分量为(i, j)，它在旋转(顺时针旋转90度)前的位置为(srcHeight-1-j, i)；\n再看VU分量，因为`NV21`格式每组UV分量有4个Y分量共用，所以只要随着4个中的一个改变一次就可以了，我选择让VU分量跟着左上角的Y分量一起变换（例如，V1U1跟着旋转后的Y5变换）即，当(i, j)为左上角的Y时，这个时候它对应旋转前的4个分量中左下角的Y（后Y5和前Y5），前Y5的VU分量，放到后Y5VU分量的位置即可，当进行到旋转后的图4个Y分量中的其他3个分量时不再进行VU分量的操作；\nY分量与其对应的VU分量的行角标对应关系为：目标VU行角标 = Y行角标 + 图像的高。\n## 实践（上面不懂不重要，代码可以直接用~）\n---\n\n```java\n  public void onPreviewFrame(final byte[] data, Camera camera) {\n\t\t// 将系统回调的数组拷贝一份,操作拷贝的数据\n        byte[] dataCopy = new byte[data.length];\n        System.arraycopy(srcData, 0, dataCopy , 0, data.length);\n        Camera.Size size = camera.getParameters().getPreviewSize();\n        final int srcWidth = size.width;\n        final int srcHeight = size.height;\n        final int dstWidth = size.height;\n        final int dstHeight = size.width;\n        // 1.5倍的总数,多出来的部分装VU分量\n        byte[] buf = new byte[dstWidth * dstHeight * 3 / 2];\n\n        for (int i = 0; i < dstHeight; i++) {\n            for (int j = 0; j < dstWidth; j++) {\n                // 新数组中摆放Y值 旋转后(i,j) --> 旋转前(srcHeight-1-j, i)\n                buf[i * dstWidth + j] = dataCopy[(srcHeight - 1 - j) * srcWidth + i];\n                // 确认是左上角的点\n                if (i % 2 == 0 && j % 2 == 0) {\n                    // 摆放V值 目标行号= 行号/2 + 高\n                    buf[(i / 2 + srcWidth) * dstWidth + j] = dataCopy[((srcHeight - 1 - j) / 2 + srcHeight) * srcWidth + j];\n                    // 摆放U值\n                    buf[(i / 2 + srcWidth) * dstWidth + j + 1] = dataCopy[((srcHeight - 1 - j) / 2 + srcHeight) * srcWidth + j + 1];\n                }\n            }\n        }\n        \n        YuvImage yuvImage = new YuvImage(buf, ImageFormat.NV21, dstWidth, dstHeight, null);\n\n        File file = new File(\"/storage/emulated/0/\" + System.currentTimeMillis() + \".jpg\");\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            yuvImage.compressToJpeg(new Rect(0, 0, dstWidth, dstHeight), 100, fos);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n}\n```","tags":["Android","Yuv"],"categories":["Android"]},{"title":"ScrollView在SlidingUpPanelLayout中下滑无效问题","url":"/2017/10/208c39b1bdad/","content":"\n当在`ScrollableView`(即, 可上下滑动的ViewGroup)中含有`ScrollView`时，向上滑动`ScrollableView`至其全部上移展示出来时，继续向上滑动时`ScrollView`会响应滑动事件向上滑动，但是此时抬起手后再向下滑动时，首先响应滑动事件的是`ScrollabldView`，这就导致`ScrollView`无法下滑，解决该问题一种简单有效的实践：\n<!--more--> \n```java\nSlidingUpPanelLayout.setScrollableView(ScrollView)\n```\n\n**用`ScrollView`替换整个滑动的ViewGroup**\n","tags":["Android","SlidingUpPanelLayout"],"categories":["Android"]},{"title":"手把手教你实现RecyclerView的下拉刷新和上拉加载更多","url":"/2017/10/a9bb97b2a678/","content":"---\n\n纵观多数App，下拉刷新和上拉加载更多是很常见的功能，但是谷歌官方只有一个SwipeRefreshLayout用来下拉刷新，上拉加载更多还要自己做。\n\n基于RecyclerView简单封装了这两个操作，下拉刷新支持LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager;上拉加载更多只支持前两者。\n\n<!--more-->\n----------\n\n\n#### 话不多说先上效果图 数据来自[**干货集中营**](http://gank.io/api)\n\n![](https://i.loli.net/2021/07/03/O6JtWNRBz7n1udD.gif)\n(下拉刷新）\n\n![](https://i.loli.net/2021/07/03/Rygwk9KZPBGaNnv.gif)\n（上拉加载更多 -- LinearLayoutManager）\n\n![](https://i.loli.net/2021/07/03/j7mqzU3PDXOYFpE.gif)\n（上拉加载更多 -- GridLayoutManager）\n\n\n----------\n\n\n### (一) 使用方式，很简单 如下：\n\n* **1. 下拉刷新 3步走**\n\n**1.1 布局文件**\n\t\n```xml\n// 用SwipeRefreshLayout包裹RecyclerView\n<android.support.v4.widget.SwipeRefreshLayout\n\t        android:id=\"@+id/gank_swipe_refresh_layout\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"match_parent\">\n\t\n<android.support.v7.widget.RecyclerView\n\t         android:id=\"@+id/gank_recycler_view\"\n\t            android:layout_width=\"match_parent\"\n\t            android:layout_height=\"match_parent\"\n\t            android:overScrollMode=\"never\"/>\n</android.support.v4.widget.SwipeRefreshLayout>\n```\n\t\n\n\n**1.2 给`SwipeRefreshLayout` 添加监听 增加触发刷新时的操作(比如重新请求数据)**\n\n```java\nSwipeRefreshLayout swipeRefreshLayout = findViewById();\nswipeRefreshLayout.setOnRefreshListener(new swipeRefreshLayout.OnRefreshListener() {\n            @Override\n            public void onRefresh() {\n\t            // do something, such as re-request from server or other\n            }\n        });\n```\n\n**1.3 刷新操作(重新请求数据)完成后要回调来停止隐藏刷新动画(中上方圆形悬浮进度条旋转动画)**\n\n```java\nswipeRefreshLayout.setRefreshing(false);\n```\n\t\n**至此下拉刷新完成**\n<br/>\n\n* **2.上拉加载3步走**\n\n**2.1 初始化`AdapterWrapper`和`SwipeToLoadHelper`**\n```java\n// adapter是你自己为RecyclerView写的Adapter\nRecyclerView.Adapter adapter = new YourOwnAdapter();\nAdapterWrapper adapterWrapper = new AdapterWrapper(adapter);\nRecyclerView recyclerView = findViewById();\n// 将RecyclerView和刚创建的adapterWrapper传入\nSwipeToLoadHelper helper = new SwipeToLoadHelper(recyclerView, adapterWrapper);\n```\n**2.2 设置加载动作触发后的监听**\n```java\nhelper.setLoadMoreListener(new SwipeToLoadHelper.LoadMoreListener() {\n            @Override\n            public void onLoad() {\n            // do something, such as request more data from server or other.\n            }\n        })\n```\n**2.3 加载更多内容完成后要回调方法停止动画**\n```java\nhelper.setLoadMoreFinish()\n```\n**至此上拉加载完成 (注意更新数据时要调用`AdapterWrapper.notifyDataSetChanged`)**\n\n---\n\n### (二) 简明扼要的实现思路(上拉加载操作)\n\n> `RecyclerView`的`itemView`的显示情况分为四种：\n> \n> 1. 第1个可见的（部分显示或者完全显示都算可见）\n> 2. 第1个可见的且是完整的（完全显示算作完整的）\n> 3. 最后1个可见的\n> 4. 最后1个可见的且是完整的\n\n* **1. 回弹效果**\n即手指抬起滑动停止，`上拉加载更多`部分显示时，将`上拉加载更多`滚动到不显示，使上面挨着它的`itemView`为最后1个可见且是最后1个完整可见。<br/>\n监听`RecyclerView`的滚动，当`RecyclerView`处于`SCROLL_STATE_IDLE` 状态时，获取最后1个完整可见的`itemView`：如果是倒数第2个`item`则计算该`item`的下边距到`RecyclerView`底部的距离`deltaY`，然后将`RecyclerView`向下滚动`deltaY`；如果是`上拉加载更多`则触发加载操作；其他情况不用处理。\n\n```java\n// 关键代码 rv : recyclerView\nint lcp = layoutManager.findLastCompletelyVisibleItemPosition();\nif (lcp == layoutManager.getItemCount() - 2) {\n\t// 倒数第2项\n\tint fcp = layoutManager.findFirstCompletelyVisibleItemPosition();\n    View child = layoutManager.findViewByPosition(lcp);\n    int deltaY = rv.getBottom() - rv.getPaddingBottom() - \n\t\t\t\t    child.getBottom();\n\t// fcp为0时说明列表滚动到了顶部, 不再滚动\n    if (deltaY > 0 && fcp != 0) {\n\t      rv.smoothScrollBy(0, -deltaY);\n    }\n} else if (lcp == layoutManager.getItemCount() - 1) {\n    // 最后一项完全显示, 触发操作, 执行加载更多操作\n    if (listener != null) {\n\t    listener.onLoad();\n    }\n}\n```\n<br/>\n\n* **2. 添加底部`加载更多`itemView**\n\n2.1 `AdapterWrapper`重写了`getItemCount`方法，保证得到`itemView`的数量包括`加载更多`。当是`LinearLayoutManager`类型时直接加1；当是`GridLayoutManager`类型时，如果需要则先将列表最后一行填满，再加1。比如：列表每行有3个`itemView`，最后一行只有1个，这时就需要先加2，再加1，来保证`加载更多`占据完整的一行。\n\n```java\n// 关键代码 其中的adapter为构造函数中传入的原生RecyclerView.Adapter\nif (adapterType == ADAPTER_TYPE_LINEAR) {\n\t// 线性布局\n\treturn adapter.getItemCount() + 1;\n} else {\n\t// 网格布局 spanCount为每行itemView的个数\n    int remain = adapter.getItemCount() % spanCount; // 余数\n    if (remain == 0) {\n\t    return adapter.getItemCount() + 1;\n    }\n    // 余数不为0时,先凑满再加1\n    return adapter.getItemCount() + 1 + (spanCount - remain);\n}\n```\n\n2.2 `AdapterWrapper`重写了`getItemViewType`方法，当是最后一个位置时返回`ITEM_TYPE_LOAD`\n\n```java\n// 关键代码\npublic int getItemViewType(int position) {\n    // 位置是最后一个时, wrapper进行拦截\n    if (osition == getItemCount() - 1) {\n        return ITEM_TYPE_LOAD;// 要避免和原生adapter返回值可能重复\n    }\n    // 其他情况交给原生adapter处理\n    return adapter.getItemViewType(position);\n}\n```\n\n2.3 `AdapterWrapper`重写了`onCreateViewHolder`方法，当类型为`ITEM_TYPE_LOAD`时返回`加载更多`的`ViewHolder`，其他情况交给原生的`adapter`处理。\n\n```java\n// 关键代码\npublic RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n    if (viewType == ITEM_TYPE_LOAD) {\n        return new LoadMoreHolder();\n    } else {\n        return adapter.onCreateViewHolder(parent, viewType);\n    }\n}\n```\n\n2.4 `AdapterWrapper`重写了`onBindViewHolder`，这里有三种可能的情况：1. 正常的数据项`itemView`，交给`adapter`处理；2. `GridView`的空白`itemView`，隐藏处理；3. 底部的`加载更多`，目前不需要做什么处理。\n\n```java\n// 关键代码\npublic void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n    if (position == getItemCount() - 1) {\n    } else if (position < adapter.getItemCount()){\n        adapter.onBindViewHolder(holder, position);\n    } else {\n        holder.itemView.setVisibility(View.INVISIBLE);\n    }\n }\n```\n----\n### (三) 额外的两个说明\n* `SwipeFreshLayout`有个`setEnable(boolean)`方法，设置为`false`的时候就下拉刷新功能就没有了，等同于普通的`RecyclerView`\n* 同样`SwipeToLoadHelper`有个`setSwipeToLoadEnabled(boolean)`方法，设置为`false`的时候上拉加载功能就没有了， 等同于普通的`RecyclerView`\n\n---\n#### **如有问题，欢迎指正~**\n\n附[项目仓库地址](https://github.com/oynix/wraprecyclerview)，如有需要请自取~\n","tags":["Android","RecyclerView","自定义控件"],"categories":["Android"]},{"title":"几分钟完成发布开源库到jCenter","url":"/2017/10/31c771f65733/","content":"---\n\n在AndroidStudio中导入开源库一般就是一句话的事：`compile 'xxx.xx.xx:xx'`。 实际上我们也可以通过这种方式来导入自己的开源库，方便自己的使用。AndroidStudio执行`compile 'xxx.xxx.xx:xx'` 会先到jCenter上查找该开源库，所以需要我们把自己的开源库库发布到jCenter上。无法直接在jCenter上发布开源库，要通过它的托管商--Bintray（Bintray托管着很多仓库，jCenter只是其中一个）来完成。\n\n把自己平时经常用到的一些代码写到一起上传到jCenter，以后不管做什么项目一句话就能导入，算来还是一个比较实用的功能。\n<!--more-->\n#### 总体步骤概览\n\n >  [1. 注册Bintray账号并创建仓库](#step1)\n    [2. 准备开源库](#step2)\n    [3. 修改gradle文件](#step3)\n    [4. 编译并上传至Bintray](#step4)\n    [5. linked to jCenter](#step5)\n\n\n----------\n<h3 id=\"step1\"> 1. 注册Bintray账号并创建仓库</h3>\n\n使用Bintray当然要先注册个账号，[注册地址](https://bintray.com/signup/oss)\n\n![注册界面](https://i.loli.net/2021/07/02/nDrYj29khgLP3HQ.png)\n我选的是`Sign up with Github`。\n注册登录之后应该是这个样子， 点击`Add New Repository`\n\n![](https://i.loli.net/2021/07/02/lSWt5zHh7qaBY1r.png)\n![](https://i.loli.net/2021/07/02/7gemVscRGIrH2MQ.png)\n\n* Name：仓库的名字，写了之后不能再改，记住该名字，后面上传时会用到；\n* Type：仓库类型，选择`Maven`；\n* License：开源协议，随便选一个就好；\n* Description：仓库描述，随便写；\n\n**点击`Create` 完成仓库创建，到此第一步完成。**\n\n\n----------\n<h3 id=\"step2\"> 2. 准备开源库</h3>\n\n备好你想要上传的开源库，有两种方式：\n1. AndroidStudio中new一个project，然后在project中new一个Module，类型选择`Android Library`.\n2. 直接修改当前Module的build.gradle（**注意区分project的build.gradle文件和Module的build.gradle文件，前者在project根目录下，后者在对应的Module目录下**）文件，将第一行的`apply plugin: 'com.android.application` 改为 `apply plugin: com.android.library` ，再把下面的`applicationId \"你的包名\"` 这一行删除(library是不允许有applicationId的).\n\n两种方式最终结果都是得到了一个`Android Library` 类型的Module，在Module里添加你想要上传的开源库代码（我随便弄了一个，里面有个我常用到的加载App Icon的方法）。\n\n**到此第二步准备开源库完成**\n\n\n----------\n<h3 id=\"step3\"> 3. 修改gradle文件</h3>\n\n**还是那句话，注意区分project的build.gradle文件和Module的build.gradle文件，前者在project根目录下，后者在对应的Module目录下**\n\n* 修改project的build.gradle文件，添加下面这两句话\n![](https://i.loli.net/2021/07/02/3xVtoCEBzNfD6KT.png)\n[*Maven Github地址*](https://github.com/dcendents/android-maven-gradle-plugin)：对应里面的说明选择使用的版本号\n[*Bintray Github地址*](https://github.com/bintray/gradle-bintray-plugin)：对应里面的说明选择使用的版本号\n\n* 修改Module的build.gradle文件（这步有点乱，认真看）\n需要配置3个信息：\n1. Bintray账号配置和Developer信息，告诉AndroidStudio传到哪及开发者介绍；\n2. Project信息，开源库的介绍；\n3. 上传配置，对以上3个信息的调用以及其他一些配置；\n\n为了看起来条理清晰，我把能独立的部分都独立到单独文件里了，便于阅读，以下分别说明。\n\n**1. Bintray账号信息和Developer信息**\n`AndroidStudio`创建项目时默认会在project根目录下创建`local.properties` 文件并添加到了`.gitignore` 文件中（如果没有请自行创建并添加至`.gitignore` 中），在其中添加以下内容：\n\n![](https://i.loli.net/2021/07/02/NevJYK8bCSkWUV5.png)\n\n * bintray.user：Bintray注册的用户名\n * bintray.apikey：Bintray的API key\n * developer.id：开源社区的昵称（一般指github，或是使用的其他开源社区）\n * developer.name：姓名\n * developer.email：邮箱地址\n\n*查看API key方法：*\n![](https://i.loli.net/2021/07/02/cPX6dYtHeijrZbl.png)\n![](https://i.loli.net/2021/07/02/78qtx2wumGjSy1d.png)\n\n\n**2. Project信息配置**\n\n在***开源库Module目录***下新建`project.properties`文件，添加以下内容：\n\n![](https://i.loli.net/2021/07/02/ho8iIzSP3tBxJK4.png)\n\n* project.name：开源库名字\n* project.groupId：项目组ID，写包名\n* project.artifaceId：项目ID，写Module名\n* project.packaging：打包方式，写aar\n* project.siteUrl：项目主页，没有就写github地址\n* project.gitUrl：项目仓库地址\n* javadoc.name：javadoc主页显示的名称，写项目名字就好\n\n**3. 上传配置**\n\n在***开源库Module目录***下新建`bintrayUpload.gradle`文件，添加以下内容：(内容较多，直接贴源码了，阅读可能不太美观）\n\n```groovy\napply plugin: 'com.github.dcendents.android-maven'\napply plugin: 'com.jfrog.bintray'\n\n// load properties\nProperties properties = new Properties()\n\nFile projectPropertiesFile = project.file(\"project.properties\")\nif(projectPropertiesFile.exists()){\n    properties.load(projectPropertiesFile.newDataInputStream())\n}\n\n// read properties\ndef projectName = properties.getProperty(\"project.name\")\ndef projectGroupId = properties.getProperty(\"project.groupId\")\ndef projectArtifactId = properties.getProperty(\"project.artifactId\")\ndef projectVersionName = android.defaultConfig.versionName\ndef projectPackaging = properties.getProperty(\"project.packaging\")\ndef projectSiteUrl = properties.getProperty(\"project.siteUrl\")\ndef projectGitUrl = properties.getProperty(\"project.gitUrl\")\ndef javadocName = properties.getProperty(\"javadoc.name\")\n\n\nFile localPropertiesFile = project.rootProject.file(\"local.properties\")\nif(localPropertiesFile.exists()){\n    properties.load(localPropertiesFile.newDataInputStream())\n}\ndef developerId = properties.getProperty(\"developer.id\")\ndef developerName = properties.getProperty(\"developer.name\")\ndef developerEmail = properties.getProperty(\"developer.email\")\n\ndef bintrayUser = properties.getProperty(\"bintray.user\")\ndef bintrayApikey = properties.getProperty(\"bintray.apikey\")\n\n\ngroup = projectGroupId\n\n// This generates POM.xml with proper parameters\ninstall {\n    repositories.mavenInstaller {\n        pom {\n            project {\n                name projectName\n                groupId projectGroupId\n                artifactId projectArtifactId\n                version projectVersionName\n                packaging projectPackaging\n                url projectSiteUrl\n                licenses {\n                    license {\n                        name 'The Apache Software License, Version 2.0'\n                        url 'http://www.apache.org/licenses/LICENSE-2.0.txt'\n                    }\n                }\n                developers {\n                    developer {\n                        id developerId\n                        name developerName\n                        email developerEmail\n                    }\n                }\n                scm {\n                    connection projectGitUrl\n                    developerConnection projectGitUrl\n                    url projectSiteUrl\n                }\n            }\n        }\n    }\n}\n\n// This generates sources.jar\ntask sourcesJar(type: Jar) {\n    from android.sourceSets.main.java.srcDirs\n    classifier = 'sources'\n}\n\ntask javadoc(type: Javadoc) {\n    source = android.sourceSets.main.java.srcDirs\n    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))\n}\n\n// This generates javadoc.jar\ntask javadocJar(type: Jar, dependsOn: javadoc) {\n    classifier = 'javadoc'\n    from javadoc.destinationDir\n}\n\nartifacts {\n    archives javadocJar\n    archives sourcesJar\n}\n\n// javadoc configuration\njavadoc {\n    options{\n        encoding \"UTF-8\"\n        charSet 'UTF-8'\n        author true\n        version projectVersionName\n        links \"http://docs.oracle.com/javase/7/docs/api\"\n        title javadocName\n    }\n}\n\n// bintray configuration\nbintray {\n    user = bintrayUser\n    key = bintrayApikey\n    configurations = ['archives']\n    pkg {\n        repo = \"maven\"\n        name = projectName\n        websiteUrl = projectSiteUrl\n        vcsUrl = projectGitUrl\n        licenses = [\"Apache-2.0\"]\n        publish = true\n    }\n}\n```\n\n上传开源库的配置基本都是这样，不用改动什么，值得注意的是`bintray` 节点的`repo` 指的是第一步中创建的Maven仓库的名字，这两个名字要一致；此外开源库的版本号默认取的是project的版本号`def projectVersionName = android.defaultConfig.versionName`，如果有需要也可把这两个属性抽取到`project.properties` 文件中，便于管理。\n\n最后一个操作，在***开源库Module***的`build.gradle` 文件末尾中添加如下代码`apply from: 'bintrayUpload.gradle'` 来调用配置文件。\n\n**至此第3步配置gradle文件完成。**\n\n\n----------\n<h3 id=\"step4\"> 4. 编译并上传至Bintray</h3>\n\n* 编译：打开AndroidStudio的Terminal窗口（一般在底部，没有的话点击`顶部工具栏`->`View`->`Tools Windows`-> `Terminal`），输入命令并回车：\n\n> gradlew install\n\n等待一段时间后提示`BUILD SUCCESSFUL`，表示成功。\n\n* 上传，同样在Terminal中输入以下命令并回车：\n\n> gradlew bintrayUpload\n\n\n等待一段时间后提示`BUILD SUCCESSFUL`，表示成功。\n\n**至此第4步编译并上传完成。**\n\n\n----------\n<h3 id=\"step5\"> 5. Linked to jCenter</h3>\n\n![](https://i.loli.net/2021/07/02/LZm2MYtP8XJ1RjU.png)\n\n![](https://i.loli.net/2021/07/02/HKzyexF9aZscOdW.png)\n\n![](https://i.loli.net/2021/07/02/CNPLzhVtXdxnRI8.png)\n\n![](https://i.loli.net/2021/07/02/Ed6kULb9QNpMDAa.png)\n\n**按照上面4步，发送include request之后等待Bintray团队审核，审核完成后会收到邮件和站内信。**\n\n![](https://i.loli.net/2021/07/02/bdaZXRcOkflTy96.png)\n\n**至此第5步Linked to jCenter完成。**\n\n\n----------\n\n### 如果遇到问题，请参考这两篇文章\n\n1. [Android 项目打包到 JCenter 的坑](http://www.jianshu.com/p/c721f9297b2f?utm_campaign=hugo&utm_medium=reader_share&utm_content=note)\n2. [Android 发布项目到 JCenter 遇到的各种坑](http://www.jianshu.com/p/c518a10fdaed)\n\n\n#### **如有问题，欢迎指正~**","tags":["Android","jCenter"],"categories":["Android"]},{"title":"Android Drawable 和 xml文件转化关系","url":"/2017/09/8b0716318a1c/","content":"---\nDrawable类既可以在代码中创建也可以在xml文件中设置，以下是各类型的对应关系。\n<!--more-->\n`<selector />`---------`StateListDrawable`  \n`<level-list />`---------`LevelListDrawable`  \n`<layer-list />`---------`LayerDrawable`  \n`<transition />`---------`TransitionDrawable`  \n`<color />`---------`ColorDrawable`  \n`<shape />`---------`GradientDrawable`  \n`<scale />`---------`ScaleDrawable`  \n`<clip />`---------`ClipDrawable`  \n`<rotate/>`---------`RotateDrawable`  \n`<animation-list />`---------`AnimationDrawable`  \n`<inset />`---------`InsetDrawable`  \n`<bitmap/>`---------`BitmapDrawable`  \n`<nine-patch />`---------`NinePatchDrawable`  \n`<stupid-tag />`---------`Resources.NotFoundException`  ","tags":["Android","Drawable"],"categories":["Android"]},{"title":"Android改变图片属性之饱和度","url":"/2017/09/992c82f9c39e/","content":"---\n简单实现改变图片饱和度\n<!--more-->\n```\n ImageView image = (ImageView) findViewById(R.id.image);\n ColorMatrix matrix = new ColorMatrix();\n matrix.setSaturation(0f);\n image.setColorFilter(new ColorMatrixColorFilter(matrix));\n```\n\n**通过设置Matrix的参数来实现.**","tags":["Android","图片饱和度"],"categories":["Android"]},{"title":"Android 自定义样式通知栏的坑RemoteServiceException","url":"/2017/07/373186e06a55/","content":"---\nAndroid 自定义样式通知栏的坑RemoteServiceException\n```\nAndroid.app.RemoteServiceException: Bad notification posted from packagecom.my.package:\n\n```\n\n是的，就是这个异常。\n\n<!--more-->\n----------\n没有使用系统提供的三个方法\n\n```\nsetContentText（）\nsetContentTitle（）\nsetSmallIcon（）\n```\n而用的是`RemoteViews`，然后就掉坑里了。\n\n**原因是这样的，请往下看~**\n\n1. 布局中的控件只有**7种**，除此之外，均会报错！\n```\nAnalogClock，Button，Chronometer，ImageButton，mageView，ProgressBar，TextView\n```\n\n2. 另外还有一个问题，就是控件长宽的设定，必须为`0dp`，`wrap_content`或者`match_parent`，除此之外，也均会报错！\n\n```\nif (layoutWidth != 0 && layoutWidth != ViewGroup.LayoutParams.MATCH_PARENT\n            && layoutWidth != ViewGroup.LayoutParams.WRAP_CONTENT) {\n        throw new IllegalArgumentException(\"Only supports 0, WRAP_CONTENT and MATCH_PARENT\");\n    }\n```\n**这就是原因，内部会检测。但不知为何，我接收到的都是文章开头提到的那个异常，让人苦恼。**\n","tags":["Android","RemoteServiceException"],"categories":["Android"]},{"title":"Android获取系统相册所有图片","url":"/2017/06/eccdf08dbb5b/","content":"---\n\n### 直接获取所有照片的信息，而不是打开照片选择页面\n<!--more-->\n```java\n  private ArrayList<CategoryFile> queryCategoryFilesSync(FileType type) {\n    ArrayList<CategoryFile> files = new ArrayList<>();\n    Uri uri = MediaStore.Images.Media.getContentUri(\"external\");\n    if (uri != null) {\n        String[] projection = new String[]{FileColumns._ID, // id\n                FileColumns.DATA, // 文件路径\n                FileColumns.SIZE, // 文件大小\n                FileColumns.DATE_MODIFIED}; // 修改日期\n        Cursor cursor = getContentResolver().query(uri, projection, null, null, null);\n        if (cursor != null) {\n            try {\n                if (cursor.moveToFirst()) {\n                    final int pathIdx = cursor\n                            .getColumnIndex(FileColumns.DATA);\n                    final int sizeIdx = cursor\n                            .getColumnIndex(FileColumns.SIZE);\n                    final int modifyIdx = cursor\n                            .getColumnIndex(FileColumns.DATE_MODIFIED);\n                    do {\n                        String path = cursor.getString(pathIdx);\n                        CategoryFile file = new CategoryFile();\n                        file.mType = type;\n                        file.mPath = path;\n                        file.mParent = FileUtil.getPathFromFilepath(file.mPath);\n                        file.mName = FileUtil.getNameFromFilepath(file.mPath);\n                        file.mSize = cursor.getLong(sizeIdx);\n                        file.mLastModifyTime = cursor.getLong(modifyIdx);\n                        files.add(file);\n                    } while (cursor.moveToNext());\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n    return files;\n }\n```\n\n其中`CategoryFile`为存储照片信息的Bean类\n### FileUtil类\n```java\npublic class FileUtil {\n\n    private static final char UNIX_SEPARATOR = '/';\n\n    public static String getPathFromFilepath(String filepath) {\n        if (!TextUtils.isEmpty(filepath)) {\n            int pos = filepath.lastIndexOf(UNIX_SEPARATOR);\n            if (pos != -1) {\n                return filepath.substring(0, pos);\n            }\n        }\n        return \"\";\n    }\n\n    public static String getNameFromFilepath(String filepath) {\n        if (!TextUtils.isEmpty(filepath)) {\n            int pos = filepath.lastIndexOf(UNIX_SEPARATOR);\n            if (pos != -1) {\n                return filepath.substring(pos + 1);\n            }\n        }\n        return \"\";\n    }\n}\n```","tags":["Android"],"categories":["Android"]},{"title":"正则表达式(Regular Expression)","url":"/2017/05/cbfcda6ce2f5/","content":"---\n\n***整理参考于** : http://www.runoob.com/regexp/regexp-tutorial.html*\n<!--more-->\n\n## **一. 简介**\n\n\n#### ^[0-9]+abc$\n - `^` 为匹配输入字符串的开始位置。\n - `[0-9]+` 匹配多个数字 `[0-9]` 匹配单个数字 `+` 匹配一个或者多个\n - `abc$`匹配字母 `abc` 并以 `abc` 结尾，`$` 为匹配输入字符串的结束位置。\n\n\n## **二. 语法**\n\n正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n例如：\n\n - runoo+b，可以匹配 runoob、runooob、runoooooob 等，**`+` 号代表前面的字符必须至少出现一次（1次或多次）**。\n - runoo*b，可以匹配 runob、runoob、runoooooob 等，**`*` 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）**。\n - colou?r 可以匹配 color 或者 colour，**`?` 问号代表前面的字符最多只可以出现一次（0次、或1次）**。\n\n\n## **三. 字符分类**\n\n### 1. 普通字符\n普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。\n\n\n### 2. 非打印字符\n非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：\n   字符 | 描述    \n  :: | \n\\cx\t|匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。\n\\f\t|匹配一个换页符。等价于 \\x0c 和 \\cL。\n\\n\t|匹配一个换行符。等价于 \\x0a 和 \\cJ。\n\\r\t|匹配一个回车符。等价于 \\x0d 和 \\cM。\n\\s\t|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。\n\\S\t|匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n\\t\t|匹配一个制表符。等价于 \\x09 和 \\cI。\n\\v\t|匹配一个垂直制表符。等价于 \\x0b 和 \\cK。\n\n\n### 3. 特殊字符\n所谓特殊字符，就是一些有特殊含义的字符，如上面说的 `runoo*b` 中的` *`，简单的说就是表示任何字符串的意思。如果要查找字符串中的` *` 符号，则需要对` *` 进行转义，即在其前加一个` \\: runo\\*ob` 匹配 `runo*ob`。\n许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符\"转义\"，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符：\n\n  特别字符 | 描述\n  :-----:|-----\n \\$ | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。\n( )\t|标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。\n\\*\t| 匹配前面的子表达式零次或多次。要匹配 `*` 字符，请使用 `\\*`。\n\\+\t|  匹配前面的子表达式一次或多次。要匹配 `+` 字符，请使用 `\\+`。\n\\.\t| 匹配除换行符 \\n 之外的任何单字符。要匹配 `.` ，请使用 `\\.` 。\n\\[\t| 标记一个中括号表达式的开始。要匹配 `[`，请使用 `\\[`。\n?\t| 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 `?` 字符，请使用 `\\?`。\n\\\t| 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， `'n'` 匹配字符 `'n'`。`'\\n'` 匹配换行符。序列 `'\\\\'` 匹配 `\"\\\"`，而 `'\\('` 则匹配 `\"(\"`。\n^\t| 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 `^` 字符本身，请使用 `\\^`。\n{\t| 标记限定符表达式的开始。要匹配 `{`，请使用 `\\{`。\n\\|\t| 指明两项之间的一个选择。要匹配 `|`，请使用 `\\|`。\n\n### 4. 限定符\n限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。\n正则表达式的限定符有：\n\n字符 | \t描述\n:-----:|-----\n\\*|\t匹配前面的子表达式零次或多次。例如，`zo*` 能匹配 `\"z\"` 以及 `\"zoo\"`。`*` 等价于`{0,}`。\n\\+|匹配前面的子表达式一次或多次。例如，`'zo+'` 能匹配 `\"zo\"` 以及 `\"zoo\"`，但不能匹配 `\"z\"`。`+` 等价于 `{1,}`。\n?|\t匹配前面的子表达式零次或一次。例如，`\"do(es)?\"` 可以匹配 `\"do\"` 或 `\"does\"` 中的`\"do\"` 。`?` 等价于 `{0,1}`。\n{n}\t|`n`是一个非负整数。匹配确定的 `n` 次。例如，`'o{2}'` 不能匹配 `\"Bob\"` 中的 `'o'`，但是能匹配 `\"food\"` 中的两个 `o`。\n{n,}|`n` 是一个非负整数。至少匹配`n` 次。例如，`'o{2,}'` 不能匹配 `\"Bob\"` 中的 `'o'`，但能匹配 `\"foooood\"` 中的所有 `o`。`'o{1,}'` 等价于 `'o+'`。`'o{0,}'` 则等价于 `'o*'`。\n{n,m}|`m` 和 `n` 均为非负整数，其中`n <= m`。最少匹配 `n` 次且最多匹配 `m` 次。例如，`\"o{1,3}\"` 将匹配 `\"fooooood\"` 中的前三个 `o`。`'o{0,1}'` 等价于 `'o?'`。请注意在逗号和两个数之间不能有空格。\n\n 由于章节编号在大的输入文档中会很可能超过九，所以您需要一种方式来处理两位或三位章节编号。限定符给您这种能力。下面的正则表达式匹配编号为任何位数的章节标题：\n`/Chapter [1-9][0-9]*/`\n\n请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。\n这里不使用 `+` 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用`？`字符，因为它将章节编号限制到只有两位数。您需要至少匹配 Chapter 和空格字符后面的一个数字。\n如果您知道章节编号被限制为只有 99 章，可以使用下面的表达式来至少指定一位但至多两位数字。\n`/Chapter [0-9]{1,2}/`\n\n上面的表达式的缺点是，大于 99 的章节编号仍只匹配开头两位数字。另一个缺点是 Chapter 0 也将匹配。只匹配两位数字的更好的表达式如下：\n`/Chapter [1-9][0-9]?/`\n\n或\n`/Chapter [1-9][0-9]{0,1}/`\n\n`*`、`+`和`?`限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。\n例如，您可能搜索 HTML 文档，以查找括在 H1 标记内的章节标题。该文本在您的文档中如下：\n>```<H1>Chapter 1 - 介绍正则表达式</H1>```\n\n**贪婪**：下面的表达式匹配从开始小于符号 (<) 到关闭 H1 标记的大于符号 (>) 之间的所有内容。\n`/<.*>/`\n\n**非贪婪**：如果您只需要匹配开始和介绍 H1 标记，下面的非贪婪表达式只匹配 `<H1>`。\n`/<.*?>/`\n\n如果只想匹配开始的 H1 标签，表达式则是：\n`/<\\w+?>/`\n\n通过在`*`、`+` 或 `?` 限定符之后放置 `?`，该表达式从\"贪心\"表达式转换为\"非贪心\"表达式或者最小匹配。\n\n### 5. 定位符\n定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。\n定位符用来描述字符串或单词的边界，`^` 和`$` 分别指字符串的开始与结束，`span class=\"marked\">\\b` 描述单词的前或后边界，`span class=\"marked\">\\B` 表示非单词边界。\n正则表达式的限定符有：\n\n字符 |\t描述\n:-----:|-----\n^\t|匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。\n\\$\t|匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。\n\\b\t|匹配一个字边界，即字与空格间的位置。\n\\B\t|非字边界匹配。\n\n**注意**：不能将限定符与定位点一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 `^*` 之类的表达式。\n若要匹配一行文本开始处的文本，请在正则表达式的开始使用 `^` 字符。不要将 `^` 的这种用法与中括号表达式内的用法混淆。\n若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 `$` 字符。\n若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：\n`/^Chapter [1-9][0-9]{0,1}/`\n\n真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。\n`/^Chapter [1-9][0-9]{0,1}$/`\n\n匹配字边界稍有不同，但向正则表达式添加了很重要的能力。字边界是单词和空格之间的位置。非字边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现字边界后面：\n`/\\bCha/`\n\n`\\b` 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在字边界的前面：\n`/ter\\b/`\n\n下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：\n`/\\Bapt/`\n\n字符串 apt 出现在单词 Chapter 中的非字边界处，但出现在单词 aptitude 中的字边界处。对于 \\B 非字边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。\n\n### 6. 选择\n用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。\n\n其中 `?:` 是非捕获元之一，还有两个非捕获元是 `?=` 和 `?!`，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。\n\n### 7. 反向引用\n对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 `\\n` 访问，其中 `n` 为一个标识特定缓冲区的一位或两位十进制数。\n可以使用非捕获元字符 `?:`、`?=` 或 `?!` 来重写捕获，忽略对相关匹配的保存。\n\n反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：\n`Is is the cost of of gasoline going up up?`\n\n上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。\n\n\n## **四. 元字符**\n\n下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：\n\n字符 |\t描述\n:-: | ----\n\\\t|将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 \"n\"。'\\n' 匹配一个换行符。序列 '\\\\' 匹配 \"\\\" 而 \"\\(\" 则匹配 \"(\"。\n^\t|配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。\n\\$\t|匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。\n\\*|匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。\n+|匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。\n?\t|匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 中的\"do\" 。? 等价于 {0,1}。\n{n}\t|n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。\n{n,}\t|n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。\n{n,m}\t|m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。\n?\t|当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \"oooo\"，'o+?' 将匹配单个 \"o\"，而 'o+' 将匹配所有 'o'。\n.\t|匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用像\"(.|\\n)\"的模式。\n(pattern)|匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\\(' 或 '\\)'。\n(?:pattern)|匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。\n(?=pattern)\t|正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 \"Windows 2000\" 中的 \"Windows\" ，但不能匹配 \"Windows 3.1\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。\n(?!pattern)\t|负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 \"Windows 3.1\" 中的 \"Windows\"，但不能匹配 \"Windows 2000\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。\nx\\|y|匹配 x 或 y。例如，'z|food' 能匹配 \"z\" 或 \"food\"。'(z|f)ood' 则匹配 \"zood\" 或 \"food\"。\n[xyz]\t|字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 \"plain\" 中的 'a'。\n[^xyz]\t|负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 \"plain\" 中的'p'、'l'、'i'、'n'。\n[a-z]\t|字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。\n[^a-z]\t|负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。\n\\b\t|匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。\n\\B\t|匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。\n\\cx\t|匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。\n\\d\t|匹配一个数字字符。等价于 [0-9]。\n\\D\t|匹配一个非数字字符。等价于 [^0-9]。\n\\f\t|匹配一个换页符。等价于 \\x0c 和 \\cL。\n\\n\t|匹配一个换行符。等价于 \\x0a 和 \\cJ。\n\\r\t|匹配一个回车符。等价于 \\x0d 和 \\cM。\n\\s\t|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。\n\\S\t|匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n\\t\t|匹配一个制表符。等价于 \\x09 和 \\cI。\n\\v\t|匹配一个垂直制表符。等价于 \\x0b 和 \\cK。\n\\w\t|匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。\n\\W\t|匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。\n\\xn\t|匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\\x41' 匹配 \"A\"。'\\x041' 则等价于 '\\x04' & \"1\"。正则表达式中可以使用 ASCII 编码。\n\\num|匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\\1' 匹配两个连续的相同字符。\n\\n\t|标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\n\\nm\t|标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。\n\\nml|如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。\n\\un\t|匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。\n\n## **五. 运算符优先级**\n\n正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。\n相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：\n\n运算符|\t描述\n:-| ---\n\\\t|转义符\n(), (?:), (?=), []\t|圆括号和方括号\n*, +, ?, {n}, {n,}, {n,m}\t|限定符\n^, $, \\任何元字符、任何字符\t|定位点和序列（即：位置和顺序）\n\\||替换，\"或\"操作字符具有高于替换运算符的优先级，使得\"m\\|food\"匹配\"m\"或\"food\"。若要匹配\"mood\"或\"food\"，请使用括号创建子表达式，从而产生\"(m\\|f)ood\"。\n\n\n## **六. 匹配规则**\n\n#### **1. 基本模式匹配**\n一切从最基本的开始。模式，是正规表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：\n`^once`\n\n这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串\"once upon a time\"匹配，与\"There once was a man from NewYork\"不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。\n`bucket$`\n\n这个模式与\"Who kept all of this cash in a bucket\"匹配，与\"buckets\"不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如：\n`^bucket$`\n\n只匹配字符串\"bucket\"。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式\n> once\n\n与字符串\n> There once was a man from NewYork\nWho kept all of his cash in a bucket.\n\n是匹配的。\n在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠(\\)打头。制表符的转义序列是：\\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：\n> ^\\t \n\n类似的，用\\n表示\"新行\"，\\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\\\\表示，句号.用\\.表示，以此类推。\n\n#### **2. 字符簇**\n字符簇\n在INTERNET的程序中，正规表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。\n所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：\n> [AaEeIiOoUu]\n\n这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：\n>[a-z] //匹配所有的小写字母 \n[A-Z] //匹配所有的大写字母 \n[a-zA-Z] //匹配所有的字母 \n[0-9] //匹配所有的数字 \n[0-9\\.\\-] //匹配所有的数字，句号和减号 \n[ \\f\\r\\t\\n] //匹配所有的白字符\n\n同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如\"z2\"、\"t6\"或\"g7\"，但不是\"ab2\"、\"r2d3\" 或\"b52\"的话，用这个模式：\n> ^[a-z][0-9]$\n\n尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。\n前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用^是，它表示\"非\"或\"排除\"的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：\n> ^[^0-9][0-9]$\n\n这个模式与\"&5\"、\"g7\"及\"-2\"是匹配的，但与\"12\"、\"66\"是不匹配的。下面是几个排除特定字符的例子：\n>[^a-z] //除了小写字母以外的所有字符 \n[^\\\\\\/\\^] //除了(\\)(/)(^)之外的所有字符 \n[^\\\"\\'] //除了双引号(\")和单引号(')之外的所有字符\n\n特殊字符\".\" (点，句号)在正则表达式中用来表示除了\"新行\"之外的所有字符。所以模式\"^.5$\"与任何两个字符的、以数字5结尾和以其他非\"新行\"字符开头的字符串匹配。模式\".\"可以匹配任何字符串，除了空串和只包括一个\"新行\"的字符串。\nPHP的正规表达式有一些内置的通用字符簇，列表如下：\n\n字符簇|\t描述\n-|-\n[[:alpha:]]\t|任何字母\n[[:digit:]]\t|任何数字\n[[:alnum:]]\t|任何字母和数字\n[[:space:]]\t|任何空白字符\n[[:upper:]]\t|任何大写字母\n[[:lower:]]\t|任何小写字母\n[[:punct:]]\t|任何标点符号\n[[:xdigit:]]\t|任何16进制的数字，相当于[0-9a-fA-F]\n\n#### **4. 确定重复出现**\n到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。\n\n字符簇\t|描述\n-|-\n^[a-zA-Z_]$\t|所有的字母和下划线\n^[[:alpha:]]{3}$|\t所有的3个字母的单词\n^a$\t|字母a\n^a{4}$|\taaaa\n^a{2,4}$\t|aa,aaa或aaaa\n^a{1,3}$\t|a,aa或aaa\n^a{2,}$\t|包含多于两个a的字符串\n^a{2,}\t|如：aardvark和aaab，但apple不行\na{2,}\t|如：baad和aaa，但Nantucket不行\n\\t{2}\t|两个制表符\n.{2}\t|所有的两个字符\n\n这些例子描述了花括号的三种不同的用法。一个数字 {x} 的意思**是前面的字符或字符簇只出现x次** ；一个数字加逗号** {x,}** 的意思是**前面的内容出现x或更多的次数** ；两个数字用逗号分隔的数字** {x,y}** 表示 **前面的内容至少出现x次，但不超过y次**。我们可以把模式扩展到更多的单词或数字：\n>^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母、数字或下划线的字符串 \n^[1-9][0-9]{0,}$        // 所有的正整数 \n^\\-{0,1}[0-9]{1,}$      // 所有的整数 \n^[-]?[0-9]+\\.?[0-9]+$   // 所有的浮点数\n\n最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 (**[-]?**) 开头 (^)、跟着1个或更多的数字(**[0-9]+**)、和一个小数点(\\.)再跟上1个或多个数字(**[0-9]+**)，并且后面没有其他任何东西(**$**)。下面你将知道能够使用的更为简单的方法。\n\n特殊字符** ?** 与 **{0,1}** 是相等的，它们都代表着： **0个或1个前面的内容** 或 **前面的内容是可选的** 。所以刚才的例子可以简化为：\n>^\\-?[0-9]{1,}\\.?[0-9]{1,}$\n\n特殊字符 ***** 与 **{0,}** 是相等的，它们都代表着 **0 个或多个前面的内容** 。最后，字符 **+** 与 **{1,}** 是相等的，表示 **1 个或多个前面的内容** ，所以上面的4个例子可以写成：\n>^[a-zA-Z0-9_]+\\$      // 所有包含一个以上的字母、数字或下划线的字符串 \n^[1-9][0-9]*\\$        // 所有的正整数 \n^\\-?[0-9]+\\$          // 所有的整数 \n^\\-?[0-9]+\\.?[0-9]*\\$ // 所有的浮点数\n\n当然这并不能从技术上降低正规表达式的复杂性，但可以使它们更容易阅读。\n\n## **七. 示例**\n\n#### **1. 简单表达式**\n正则表达式的最简单形式是在搜索字符串中匹配其本身的单个普通字符。例如，单字符模式，如 A，不论出现在搜索字符串中的何处，它总是匹配字母 A。下面是一些单字符正则表达式模式的示例：\n>/a/\n/7/\n/M/\n\n可以将许多单字符组合起来以形成大的表达式。例如，以下正则表达式组合了单字符表达式：a、7 和 M。\n> /a7M/\n\n请注意，没有串联运算符。只须在一个字符后面键入另一个字符。\n\n#### **2. 字符匹配**\n\n句点 (.) 匹配字符串中的各种打印或非打印字符，只有一个字符例外。这个例外就是换行符 (\\n)。下面的正则表达式匹配 aac、abc、acc、adc 等等，以及 a1c、a2c、a-c 和 a#c：\n> /a.c/\n\n若要匹配包含文件名的字符串，而句点 (.) 是输入字符串的组成部分，请在正则表达式中的句点前面加反斜扛 (\\) 字符。举例来说明，下面的正则表达式匹配 filename.ext：\n> /filename\\.ext/\n\n这些表达式只让您匹配\"任何\"单个字符。可能需要匹配列表中的特定字符组。例如，可能需要查找用数字表示的章节标题（Chapter 1、Chapter 2 等等）。\n\n#### **3. 中括号表达式**\n\n若要创建匹配字符组的一个列表，请在方括号（[ 和 ]）内放置一个或更多单个字符。当字符括在中括号内时，该列表称为\"中括号表达式\"。与在任何别的位置一样，普通字符在中括号内表示其本身，即，它在输入文本中匹配一次其本身。大多数特殊字符在中括号表达式内出现时失去它们的意义。不过也有一些例外，如：\n\n - 如果 ] 字符不是第一项，它结束一个列表。若要匹配列表中的 ] 字符，请将它放在第一位，紧跟在开始 [ 后面。\n - \\ 字符继续作为转义符。若要匹配 \\ 字符，请使用 \\\\\\。\n\n括在中括号表达式中的字符只匹配处于正则表达式中该位置的单个字符。以下正则表达式匹配 Chapter 1、Chapter 2、Chapter 3、Chapter 4 和 Chapter 5：\n>/Chapter [12345]/\n\n请注意，单词 Chapter 和后面的空格的位置相对于中括号内的字符是固定的。中括号表达式指定的只是匹配紧跟在单词 Chapter 和空格后面的单个字符位置的字符集。这是第九个字符位置。\n若要使用范围代替字符本身来表示匹配字符组，请使用连字符 (-) 将范围中的开始字符和结束字符分开。单个字符的字符值确定范围内的相对顺序。下面的正则表达式包含范围表达式，该范围表达式等效于上面显示的中括号中的列表。\n> /Chapter [1-5]/\n\n当以这种方式指定范围时，开始值和结束值两者都包括在范围内。注意，还有一点很重要，按 Unicode 排序顺序，开始值必须在结束值的前面。\n若要在中括号表达式中包括连字符，请采用下列方法之一：\n\n - 用反斜扛将它转义：\n>[\\-]\n \n - 将连字符放在中括号列表的开始或结尾。下面的表达式匹配所有小写字母和连字符：\n>[-a-z]\n[a-z-]\n \n - 创建一个范围，在该范围中，开始字符值小于连字符，而结束字符值等于或大于连字符。下面的两个正则表达式都满足这一要求：\n>[!--]\n[!-~]\n\n若要查找不在列表或范围内的所有字符，请将插入符号 (^) 放在列表的开头。如果插入字符出现在列表中的其他任何位置，则它匹配其本身。下面的正则表达式匹配1、2、3、4 或 5 之外的任何数字和字符：\n\n> /Chapter [^12345]/\n\n在上面的示例中，表达式在第九个位置匹配 1、2、3、4 或 5 之外的任何数字和字符。这样，例如，Chapter 7 就是一个匹配项，Chapter 9 也是一个匹配项。\n上面的表达式可以使用连字符 (-) 来表示：\n> /Chapter [^1-5]/\n\n中括号表达式的典型用途是指定任何大写或小写字母或任何数字的匹配。下面的表达式指定这样的匹配：\n> /[A-Za-z0-9]/\n\n#### **4. 替换和分组**\n\n替换使用 | 字符来允许在两个或多个替换选项之间进行选择。例如，可以扩展章节标题正则表达式，以返回比章标题范围更广的匹配项。但是，这并不象您可能认为的那样简单。替换匹配 | 字符任一侧最大的表达式。\n您可能认为，下面的表达式匹配出现在行首和行尾、后面跟一个或两个数字的 Chapter 或 Section：\n> /^Chapter|Section [1-9][0-9]{0,1}$/\n\n很遗憾，上面的正则表达式要么匹配行首的单词 Chapter，要么匹配行尾的单词 Section 及跟在其后的任何数字。如果输入字符串是 Chapter 22，那么上面的表达式只匹配单词 Chapter。如果输入字符串是 Section 22，那么该表达式匹配 Section 22。\n若要使正则表达式更易于控制，可以使用括号来限制替换的范围，即，确保它只应用于两个单词 Chapter 和 Section。但是，括号也用于创建子表达式，并可能捕获它们以供以后使用，这一点在有关反向引用的那一节讲述。通过在上面的正则表达式的适当位置添加括号，就可以使该正则表达式匹配 Chapter 1 或 Section 3。\n下面的正则表达式使用括号来组合 Chapter 和 Section，以便表达式正确地起作用：\n> /^(Chapter|Section) [1-9][0-9]{0,1}$/\n\n尽管这些表达式正常工作，但 Chapter|Section 周围的括号还将捕获两个匹配字中的任一个供以后使用。由于在上面的表达式中只有一组括号，因此，只有一个被捕获的\"子匹配项\"。\n\n在上面的示例中，您只需要使用括号来组合单词 Chapter 和 Section 之间的选择。若要防止匹配被保存以备将来使用，请在括号内正则表达式模式之前放置 ?:。下面的修改提供相同的能力而不保存子匹配项：\n> /^(?:Chapter|Section) [1-9][0-9]{0,1}$/\n\n除 ?: 元字符外，两个其他非捕获元字符创建被称为\"预测先行\"匹配的某些内容。正向预测先行使用 ?= 指定，它匹配处于括号中匹配正则表达式模式的起始点的搜索字符串。反向预测先行使用 ?! 指定，它匹配处于与正则表达式模式不匹配的字符串的起始点的搜索字符串。\n<br>\n例如，假设您有一个文档，该文档包含指向 Windows 3.1、Windows 95、Windows 98 和 Windows NT 的引用。再进一步假设，您需要更新该文档，将指向 Windows 95、Windows 98 和 Windows NT 的所有引用更改为 Windows 2000。下面的正则表达式（这是一个正向预测先行的示例）匹配 Windows 95、Windows 98 和 Windows NT：\n> /Windows(?=95 |98 |NT )/\n\n找到一处匹配后，紧接着就在匹配的文本（不包括预测先行中的字符）之后搜索下一处匹配。例如，如果上面的表达式匹配 Windows 98，将在 Windows 之后而不是在 98 之后继续搜索。\n\n#### **5. 其他示例**\n\n下面列出一些正则表达式示例：\n\n正则表达式\t|描述\n-| -\n/\\b([a-z]+) \\1\\b/gi\t|一个单词连续出现的位置。\n/(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/\t|将一个URL解析为协议、域、端口及相对路径。\n/^(?:Chapter\\|Section) [1-9][0-9]{0,1}\\$/\t|定位章节的位置。\n/[-a-z]/\t|a至z共26个字母再加一个-号。\n/ter\\b/\t|可匹配chapter，而不能匹配terminal。\n/\\Bapt/\t|可匹配chapter，而不能匹配aptitude。\n/Windows(?=95 \\|98 \\|NT )/\t|可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。\n/^\\s*$/\t|匹配空行。\n/\\d{2}-\\d{5}/\t|验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。\n/<\\s*(\\S+)(\\s[^>]*)?>[\\s\\S]*<\\s*\\/\\1\\s*>/\t|匹配 HTML 标记。","tags":["正则表达式"],"categories":["正则"]}]