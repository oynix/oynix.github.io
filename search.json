[{"title":"Android系统启动过程","url":"/2022/01/f6c3174008b0/","content":"从按下开机键，到手机完全启动，系统做了哪些事。\n\n<!--more-->\n\n> 摘录自「Android进阶解密」。\n\n### 系统架构简介\n说到系统架构，就离不开官方的那张图，这里就不贴了。Android系统架构分为五层，从上到下依次是\n- 应用层(System Apps)、\n- 应用框架层(Java API Framework)、\n- 系统运行库层(Android Runtime, Native C/C++ Libraries)、\n- 硬件抽象层(Hardware Abstraction Layer, HAL)、\n- Linux内核层(Linux Kernel)\n\n### 系统启动流程\n1. 启动电源以及系统\n当电源按下时，将引导芯片代码从预定义的地方（固化在ROM）开始执行。加载引导程序BootLoader到RAM，然后执行。\n\n2. 引导程序BootLoader\n引导程序BootLoader是在Android操作系统开始运行前的一个小程序，它的主要作用就是把系统OS拉起来并运行。\n\n3. Linux内核启动\n当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当内核完成西戎设置时，它首先在系统文件中寻找init.rc文件，并启动init进程。\n\n4. init进程启动\n初始化和启动属性服务，并且启动Zygote进程，也就是孵化进程\n\n5. Zygote进程启动\n创建Java虚拟机并为Java虚拟机注册JNI方法，创建服务器Socket，启动SystemServer进程。\n\n6. SystemServer进程启动\n启动Binder线程池和SystemServiceManager，并且启动各种系统服务。这其中包括WindowManagerService、PackageManagerService、CameraService、SensorService，以及ActivityManagerService等。\n\n7. Launcher启动\n被SystemServer进程启动的AMS会启动Launcher，Launcher启动后会将已安装应用的快捷图标显示到屏幕上。","tags":["读书笔记"],"categories":["Android"]},{"title":"Linux命令--cat","url":"/2021/12/4c4e081a5efb/","content":"\n连接多个文件并打印到标准输出\n\n<!--more-->\n\n### 三大功能\n- 显示文件内容，如果没有文件或者文件为-则读取标准输入。\n- 从键盘创建一个文件。\n- 将多个文件的内容进行连接并打印到标准输出。\n\n### 读取内容\n1. 读取到标准输出，也就是终端窗口\n```sh\n# 读取file1.txt文件\n$ cat file1.txt\n\n# 读取多个文件\n$ cat file1.txt file2.txt\n```\n\n2. 读取到其他输出流，如文件\n```sh\n# 单个文件\n$ cat f1.txt > sum.txt\n\n# 多个文件\n$ cat f1.txt f2.txt f3.txt > sum.txt\n```\n\n\n### 创建/追加\n1. 创建使用 `>`\n```sh\n$ cat > file1.txt << EOF\nline1\nline2\nEOF\n```\n\n2. 追加使用 `>>`\n```sh\n$ cat >> file1.txt << EOF\nline3\nline4\nEOF\n```\n3. EOF，end of file，结束标记，换成其他的也可以\n\n4. 结束标记和文件名的位置无所谓前后，这样也可以\n```sh\n$ cat << EOF >> file1.txt\nline3\nline4\nEOF\n```\n\n### 其他常用选项\n```sh\n# -n --number 加行号\n$ cat -n f1.txt\n\n# -b --number-noblank 加行号，但空白行不编号\n$ cat -b f1.txt\n\n# -s --squeeze-blank 当有两行以上的空白行，变成一行空白行\n$ cat -s f1.txt\n```","tags":["Linux"],"categories":["Linux"]},{"title":"iPhone数据备份到移动硬盘","url":"/2021/12/43f9db48ed86/","content":"\niPhone备份方式中，算是最省钱的方式了。\n\n<!--more-->\n\n### 前言\n首先明确的是，备份还是很有必要性的，在设备丢失，或是坏掉的时候，可以快速恢复数据而不影响使用。\n\niPhone里苹果官方推荐的是把数据备份到iCloud中，但是区区5GB的免费空间换了谁都不够用，除非花钱买。退一步的方式，就是把数据备份到电脑上，不用花钱，但是于我来讲，本就不够用的电脑存储已经是寸土寸金，没有太多空间分给手机备份。最省钱的方式，就是单独买块移动硬盘，现在的市场价，1TB的在300块钱上下，相比之下很划算了。\n\n### 分区\n也可以不分。\n\n在硬盘上分一块和手机大小相当的分区用来备份手机数据，单独一块出来的好处是，方便抹除数据，比手动删除不知道快了多少倍。\n\n### 制作替身\n能把数据备份到外接设备的原理就是，把默认的系统目标位置映射到移动硬盘上，就这么一个操作。系统默认的备份位置在\n```\n~/Library/Application\\ Support/MobileSync/Backup\n```\n把这个Backup目录删掉，然后在此制作一个同名的替身，映射到移动硬盘。在移动硬盘上创建同名目录即可：`MobileSync/Backup`，然后链接\n```\n$ ln -s /Volumes/{name_of_dish}/MobileSync/Backup ~/Library/Application\\ Support/MobileSync/Backup\n```\n操作完成之后，电脑里的MobileSync下就会出现一个替身Backup，指向外接硬盘的Backup。\n\n这一步操作可能需要给终端App增加访问系统全盘的权限，在系统偏好设置中、安全性与隐私的隐私里，不然可能无权限在MobileSync下创建替身\n\n### 备份\n老版本的MacOS还有个iTunes用来管理手机的数据，升级到最近的几个版本后就和Finder合并了，目前最新的是Monterey。插上手机，在Finder中就能看到，然后就可以备份了。\n","tags":["iPhone"],"categories":["MacOS"]},{"title":"Android之事件传递","url":"/2021/10/b897ec3baf06/","content":"\n触摸事件，主要有三种类型，ACTION_DOWN、ACTION_MOVE和ACTION_UP，分别指点击、移动和抬起。这篇文章主要来说一说一个事件产生之后，在控件间的传递。\n\n<!--more-->\n与其说是事件传递，不如说是事件序列的传递。一个事件序列，是由一个ACTION_DOWN和一个ACTION_UP组成，中间可能包含0个至多个ACTION_MOVE事件。手指按下时，会产生一个ACTION_DOWN事件，手指抬起时，会产生一个ACTION_UP事件，如果按下和抬起的位置偏移超过系统设定的阈值，便会产生一个或多个ACTION_MOVE事件，这便是一个事件序列。\n\n事件序列，是按照视图树由根到枝叶的顺序传递的，意思就是说，最外层的View或ViewGroup最先接收到事件，然后向内传递。其中事件流经的控件主要分为两种：ViewGroup和View。\n\n### ViewGroup\nViewGroup是View的子类，其中有3个和事件相关的方法：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent，分别是分发事件、拦截事件和处理事件。\n\n简单来说就是，系统通过dispatchTouchEvent方法将事件传入，在dispatchTouchEvent内根据onInterceptTouchEvent来判断是否拦截该事件，如果拦截了，则不再将其沿着视图树向内传递；如果拦截，则根据onTouchEvent方法来判读是否处理，如果处理了，则表示消费了该事件。\n\n### View\nView没有onInterceptTouchEvent，因为View无子View，是在视图树的最内层了，不需要拦截。当事件通过dispatchTouchEvent传入，根据onTouchEvent方法来判断是否消费。\n\n### 事件流转\n因为事件都是以事件序列的形式传递的，单独看某个事件意义不大，这里分析事件序列，先看ACTION_DOWN事件，这里的向内和向外都是针对视图树的结构而言的。\n```shell\n// 视图树\nDecorView\n|-FrameLayout\n|-TextView\n|-LinearLayout\n  |-ImageView\n  |-FrameLayout\n```\n\n1. 向内分发ACTION_DOWN\n- ViewGroup接收到事件后，会根据onInterceptTouchEvent方法来判断是否拦截，如果拦截，则根据onTouchEvent方法来判断是否消费事件。\n- View接收到事件后，根据onTouchEvent方法判断是否消费事件。\n- 如果ViewGroup没有拦截事件，则根据坐标，依次遍历该事件命中的子View/ViewGroup，重复上面这个过程\n- 当事件被拦截，或者传递到视图树最内层时，便不会继续向内传递，转而开始回传。\n\n2. 向外回传ACTION_DOWN\n- 事件回传，传递的是dispatchTouchEvent方法的返回值，true/false\n- 如果回传的false，父ViewGroup的onTouchEvent方法会被调用，可理解为本着事件不浪费的原则，既然子视图都没消费，那么就看看自己是否可以消费掉\n- 如果回传到视图根时，依然是false，表示没有子视图消费ACTION_DOWN事件，则该序列的后续事件不再向内传递，都由根视图处理\n\n3. 事件序列的后续事件\n- 系统本着一个事件序列只由一个视图处理的原则\n- 后续事件都将传递至消费掉ACTION_DOWN事件的ViewGroup/View，且在dispatchTouchEvent内直接调用onTouchEvent，不经过onInterceptTouchEvent方法，如果有的话\n- 当然，后续事件在传递过程中也可以被拦截和消费，但不建议这么做，比如一个按钮只接收了一个按下事件，则在逻辑上可能会不完整\n- 后续事件在回传时，即便是false，父ViewGroup的onTouchEvent也不会被调用，因这与第一点相悖\n\n### 根视图\n根据上一篇文章的介绍可以知道，DecorView是我们看到的视图的根，它继承自FrameLayout，是一个ViewGroup，所以它有3个和事件相关的方法。此外，Activity对应一个PhoneWindow，PhoneWindow对应一个DecorView，所以在事件序列产生的时候，最新接收到的是DecorView。\n\n根据源码，DecorView将事件转给了Window.Callback，这个Callback是Window在Activity中初始化时传入的，就是Activity本身，Activity实现了Callback接口，即，在DecorView中调用了Activity的dispatchTouchEvent。\n\nActivity的dispatchTouchEvent方法中，先将事件传给了Window的superDispatchTouchEvent方法，若没消费，再调用自己的onTouchEvent。而Window的superDispatchTouchEvent很简单，就是直接调用了DecorView的superDispatchTouchEvent，最终调用了ViewGroup的dispatchTouchEvent方法。\n\n总结下来就是，DecorView将事件转给了Activity，在Activity的dispatchTouchEvent方法中判断，若DecorView没有消费，则交给Activity的onTouchEvent。\n\n所以，从处理事件顺序来看，真实的事件流转顺序应该是：Activity -> DecorView -> ... -> DecorView -> Activity。\n\n```java\n// DecorView.java\n@Override\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n    final Window.Callback cb = mWindow.getCallback();\n    return cb != null && !mWindow.isDestroyed() && mFeatureId < 0\n            ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);\n}\n\n// Activity.java\nfinal void attach(Context context, ActivityThread aThread,\n            Instrumentation instr, IBinder token, int ident,\n            Application application, Intent intent, ActivityInfo info,\n            CharSequence title, Activity parent, String id,\n            NonConfigurationInstances lastNonConfigurationInstances,\n            Configuration config, String referrer, IVoiceInteractor voiceInteractor,\n            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) {\n\tmWindow = new PhoneWindow(this, window, activityConfigCallback);\n    mWindow.setWindowControllerCallback(mWindowControllerCallback);\n    mWindow.setCallback(this);\n}\n\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n    if (ev.getAction() == MotionEvent.ACTION_DOWN) {\n    \t// 在Activity中可以重写该方法，来监听用户的操作\n        onUserInteraction();\n    }\n    if (getWindow().superDispatchTouchEvent(ev)) {\n        return true;\n    }\n    return onTouchEvent(ev);\n}\n\n// PhoneWindow.java\npublic boolean superDispatchTouchEvent(MotionEvent event) {\n    return mDecor.superDispatchTouchEvent(event);\n}\n```\n\n### 总结\n1. 将事件传递分为向内分发和向外回传两个过程更便于理解，这里的向内和向外都是针对视图树的结构而言的。\n2. 向内分发过程中，事件一旦被拦截，或者传到了最内层，便会开始回传事件的消费结果，也就是入口dispatchTouchEvent方法的结果\n3. 当回传结果是false，且事件是序列事件的头事件ACTION_DOWN时，会调用父ViewGroup的onTouchEvent来尝试消费事件\n4. 系统本着一个事件序列只交给一个View/ViewGroup来处理的原则\n\n### 扩展之滑动冲突\n当在列表内部内嵌可滑动视图时，内部的可滑动视图常常监听不到滑动事件，这是因为列表作为内嵌视图的父ViewGroup会拦截滑动事件，所以内部自然感知不到。比较好的体验是，内部可滑动视图向上滑动到顶时，后续的滑动事件交给父列表处理，让父列表滑动来响应用户的滑动操作；当内部视图向下滑动到底时，后续的滑动事件也是交给父列表处理，让父列表滑动个来响应用户怼滑动操作。\n\n为了解决这个问题，就必须要让事件序列传到最内层，根据上面内容可以知道，要想让事件序列传到内部，那么ACTION_DOWN事件就要交给内部视图来处理。\n\n再看后续事件，作为内部视图的父视图，后续的每一个事件在传到内部视图之前，都会流经外部的列表，因此，就有两种方式来处理后续事件\n- 由父视图来判断当前事件是由自己消费，还是交给内部视图消费\n- 由内部试图来判断当前事件是由自己消费，还是让父视图消费\n\n第一种比较简单，在父视图内对ACTION_DOWN之外的后续事件判断，需要则拦截，不需要则通过；\n\n通过源码可以看到，在子视图中，是可以控制父视图是否可以拦截事件的，所以上述的第二种方式也是可行的。内部视图在收到ACTION_DOWN事件后，通过`parent.requestDisallowInterceptTouchEvent(true)`来禁止父视图拦截事件，当自己不再需要后续事件时，通过`parent.requestDisallowInterceptTouchEvent(false)`来让父视图拦截处理后面的滑动事件，来响应用户的操作即可。\n\n```java\n// ViewGroup.java\n// Check for interception.\n@Override\npublic boolean dispatchTouchEvent(MotionEvent ev) {\n\t....\n\t// Check for interception. 判断是否拦截\n    final boolean intercepted;\n    if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {\n    \t// 当设置了FLAG_DISALLOW_INTERCEPT时，则直接不拦截事件\n    \t// 没有设置FLAG_DISALLOW_INTERCEPT时，才会去调用onInterceptTouchEvent来判断\n    \t// FLAG_DISALLOW_INTERCEPT通过requestDisallowInterceptTouchEvent来设置\n        final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n        if (!disallowIntercept) {\n            intercepted = onInterceptTouchEvent(ev);\n            ev.setAction(action); // restore action in case it was changed\n        } else {\n            intercepted = false;\n        }\n    } else {\n    \t// 当不是ACTION_DOWN事件，且ACTION_DOWN没有被消费，则直接拦截，不再向内分发\n        // There are no touch targets and this action is not an initial down\n        // so this view group continues to intercept touches.\n        intercepted = true;\n    }\n}\n```","tags":["Android","TouchEvent"],"categories":["Android"]},{"title":"Activity、Window和DecorView的关系","url":"/2021/09/dab1a10731eb/","content":"\n在Android的视图框架体系，主要由这三者组成。\n\n### 前言\n我们在实际开发中，接触的最多的是Activity，至于Window和DecorView遇到的时候便会相对少一些。虽然不常用，但如果能厘清它们之间的关系，能帮助我们更好的理解Android系统的框架体系设计。\n\n<!--more-->\n\n### Window\n从字面上看，一个Window就是一个窗口，对应的类型有多种，按照层级分为3种：Activity的Window、子Window和系统Window。\n\nWindow是一个抽象类，它有且仅有一个实现类，即常说的PhoneWindow，所以，所用到的Window实例，实际上类型都是PhoneWindow。\n\n\n### DecorView\nDecorView继承自FrameLayout，扩展了一些自己的功能方法。默认情况下，DecorView会向自己内部添加一个LinearLayout为根节点的layout文件，这个LinearLayout有两个子View，一个是ActionBar，一个是ID为`@android:id/content`的FrameLayout，我们在Activity里调用setContentView时，就是把我们写的布局文件，作为子View添加到这个FrameLayout下\n```sh\nDecorView\n|--LinearLayout\n   |--ActionBar\n   |--FrameLayout\n```\n\n\n### 三者关系\nActivity中持有一个Window的实例，在Activity.onAttach中被初始化；Window中持有一个DecorView实例，DecorView就是我们所看到的视图的根视图\n```sh\nActivity\n|--PhoneWindow\n   |--DecorView\n      |--LinearView\n         |--ActionBar\n         |--FrameLayout\n```\n\n在这个视图框架中，Activity处在最外层的位置，表面上，我们的很多交互都是在和Activity进行，但Activity内部会调用Window，Window内部会调用DecorView，最终完成我们的调用。\n\n\n### 一个页面的显示过程\n众所周知，要在Activity里显示一个页面，通常是在onCreate回调里调用setContentView方法，下面来看一看从设置，到最终显示出来，都经过了哪些流程\n\n1. 首先，在Activity.setContentView里没有做什么事情，而是直接将调用转给了PhoneWindow\n```java\n// Activity.java\npublic void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n}\n\npublic Window getWindow() {\n    return mWindow;\n}\n```\n\n2. mWindow即为PhoneWindow的实例，它是在Activity.attach方法里初始化的，attach方法的调用是在ActivityThread创建Activity时调用，要早于onCreate，所以在onCreate被调用时，mWindow已经初始化\n```java\n// ActivityThread.java\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    // 1. 创建Activity\n    Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n    // 2. 调用Activity.attach\n    activity.attach(appContext, this, getInstrumentation(), r.token,\n                    r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                    r.embeddedID, r.lastNonConfigurationInstances, config,\n                    r.referrer, r.voiceInteractor, window, r.configCallback,\n                    r.assistToken);\n    // 3. 调用Activity.onCreate\n    mInstrumentation.callActivityOnCreate(activity, r.state);\n}\n\n// Activity.java\nfinal void attach(Context context, ActivityThread aThread,\n        Instrumentation instr, IBinder token, int ident,\n        Application application, Intent intent, ActivityInfo info,\n        CharSequence title, Activity parent, String id,\n        NonConfigurationInstances lastNonConfigurationInstances,\n        Configuration config, String referrer, IVoiceInteractor voiceInteractor,\n        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) {\n    // 用PhoneWindow初始化mWindow变量\n    mWindow = new PhoneWindow(this, window, activityConfigCallback);\n    mWindow.setWindowControllerCallback(mWindowControllerCallback);\n    mWindow.setCallback(this);\n    mWindow.setOnWindowDismissedCallback(this);\n    mWindow.getLayoutInflater().setPrivateFactory(this);\n}\n```\n\n3. 回到PhoneWindow，在Activity里调用setContentView后，会调用PhoneWindow的setContentView方法，根据上面的介绍可以知道，PhoneWindow中有类型为DecorView的变量，名字为mDecor，我们自己写的页面最终会最为子View添加到DecorView下的LinearLayout下的ID为`@android:id/content`的FrameLayout里面。\n\n在PhoneWindow里，这个FrameLayout用变量mContentParent保存，所以在PhoneWindow的setContentView里，会先检查mContentParent是都已经初始化，如果没有初始化，则去检查mDecor是否初始化，因为mContentParent是mDecor中的元素，有了mDecor才能初始化mContentParent。\n\n如果mContentParent存在，则会将我们设置的view添加为它的子view。\n\n在官方的设计里，根视图DecorView是由两部分组成的，一个是上面的ActionBar，一个是中间的内容区Content，即mContentParent，所以，我们setContentView是在设置中间内容区的内容。但有时我们不需要ActionBar，会在主题Theme里使用NO_ACTION_BAR的，也可能会有其他的设定，比如需要ToolBar等。\n\n系统中有一些默认的layout文件，在初始化mContentParent时，会根据我们设定的不同的Theme，以及不同的FEATURE，来选对应的layout文件，加载到mDecor中，一般来说这些布局文件中会有一个ID为`@android:id/content`的FrameLayout，也就是mContentParent。\n\n但是，在实际情况中，还会有一些复杂的情况，比如设置了转场动画等等，以及现在的AppCompatActivity，为了兼容新版SDK的一些功能设计，在DecorView的基础上添加了同样设计的SubDecorView，用SubDecorView来填充DecorView的mContentParent，我们通过setContentView设置的View最终会填充到SubDecorView的mContentParent中，具体这里就不做展开说明了。\n\n下面看看这个过程中对应的一些源码\n```java\n// PhoneWindow.java\npublic void setContentView(int layoutResID) {\n    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window\n    // decor, when theme attributes and the like are crystalized. Do not check the feature\n    // before this happens.\n    if (mContentParent == null) {\n        // 1. 如果为空，则去初始化DocerView，同时也会初始化mContentParent\n        installDecor();\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        mContentParent.removeAllViews();\n    }\n    // 如果有转场动画，则通过Scene来辅助，没有则将view添加到mContentParent中\n    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                getContext());\n        transitionTo(newScene);\n    } else {\n        mLayoutInflater.inflate(layoutResID, mContentParent);\n    }\n    mContentParent.requestApplyInsets();\n    final Callback cb = getCallback();\n    if (cb != null && !isDestroyed()) {\n        cb.onContentChanged();\n    }\n    mContentParentExplicitlySet = true;\n}\n\nprivate void installDecor() {\n    mForceDecorInstall = false;\n    if (mDecor == null) {\n        // 先生成DecorView\n        mDecor = generateDecor(-1);\n        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n        mDecor.setIsRootNamespace(true);\n        if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {\n            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);\n        }\n    } else {\n        mDecor.setWindow(this);\n    }\n    if (mContentParent == null) {\n        // 再从mDecor中找到mContentParent，这个方法下面单独说\n        mContentParent = generateLayout(mDecor);\n    }\n}\n\n// 创建DocorView\nprotected DecorView generateDecor(int featureId) {\n    ...\n    return new DecorView(context, featureId, this, getAttributes());\n}\n\n```\n\nmContentParent是在generateLayout方法中创建的，这个方法很长，足足写了三百多行。其中大致做了这几件事：\n\n第一步，获取WindowStyle，类型是TypedArray，这个和我们给Activity设置的Theme中的属性是相对应的，在这里通过R.styleable.Window_来读取，如果写过自定义控件的话，对这种读取属性的方式一定不陌生\n\n第二步，将其中设定的值取出，一部分直接设置给mDecor，如状态栏、导航栏；一部分赋值给PhoneWindow内的成员变量，如mFixedWidthMinor、mFixedWidthMajor；一部分通过setFlags设置给Window中类型为WindowManager.LayoutParams的变量mWindowAttributes，并刷新Window显示，如FLAG_FULLSCREEN，还有一部分直接赋值；一部分通过requestFeature设置给Window的变量mFeatures，如FEATURE_NO_TITLE，这个requestFeature就是我们为修改Activity一些特性，而在setContentView前调用的那个方法，可见系统也是通过这个方法，将我们在主题中设置的参数取出并应用\n\n第三步，根据设定的features，从系统中已经写好的layout布局文件中，找到一个合适的，这些文件可以这个目录下看到，`sdk/platforms/android-version/data/res/layout`\n\n第四步，加载布局文件，将其添加到mDecor中\n\n第五步，通过`@android:id/content`这个ID，找到ViewGroup，这便是mContentParent\n\n```java\nprotected ViewGroup generateLayout(DecorView decor) {\n    // Apply data from current theme.\n    // 第一步，获取包含主题属性的TypedArray\n    TypedArray a = getWindowStyle();\n\n    // 第二步，取值，并应用\n    if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) {\n        requestFeature(FEATURE_NO_TITLE);\n    } else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) {\n        // Don't allow an action bar if there is no title.\n        requestFeature(FEATURE_ACTION_BAR);\n    }\n    if (a.getBoolean(R.styleable.Window_windowTranslucentStatus,\n            false)) {\n        setFlags(FLAG_TRANSLUCENT_STATUS, FLAG_TRANSLUCENT_STATUS\n                & (~getForcedWindowFlags()));\n    }\n    ...\n\n    // 第三步，根据features，找layout文件\n    int layoutResource;\n    int features = getLocalFeatures();\n    if ((features & ((1 << FEATURE_LEFT_ICON) | (1 << FEATURE_RIGHT_ICON))) != 0) {\n        if (mIsFloating) {\n            TypedValue res = new TypedValue();\n            getContext().getTheme().resolveAttribute(\n                    R.attr.dialogTitleIconsDecorLayout, res, true);\n            layoutResource = res.resourceId;\n        } else {\n            layoutResource = R.layout.screen_title_icons;\n        }\n        removeFeature(FEATURE_ACTION_BAR);\n    }\n    ...\n\n    // 第四步，加载layout文件到mDecor\n    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);\n\n    ...\n    // 第五步，初始化mContentParent\n    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);\n    return contentParent;\n}\n\n```\n\n至此，PhoneWindow中的setContentView已经走完了，mDecor、mWindow也已经初始化，我们设置的View也添加到了mDecor的content中，但是还没有显示出来，具体让页面内容显示出来，是在resume阶段。\n\n4. setContentView说完，现在开始说resume。resume是在ActivityThread中的handleResumeActivity方法中回调的，handleResumeActivity里面大致做了这几件事：调用Activity的onResume回调方法、将Activity的Window中的DecorView添加到WindowManager，以及显示Activity的DecorView\n```java\n// ActivityThread.java\npublic void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,\n        String reason) {\n    // 调用Activity.onResume方法\n    final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);\n\n    // 得到DecorView\n    View decor = r.window.getDecorView();\n    decor.setVisibility(View.INVISIBLE);\n    ViewManager wm = a.getWindowManager();\n    WindowManager.LayoutParams l = r.window.getAttributes();\n    if (a.mVisibleFromClient) {\n    if (!a.mWindowAdded) {\n        a.mWindowAdded = true;\n        // 将decorView加到WindowManager\n        wm.addView(decor, l);\n    } else {\n        a.onWindowAttributesChanged(l);\n    }\n\n    // 调用Activity.makeVisible方法，让其显示，此时便看到了页面\n    if (r.activity.mVisibleFromClient) {\n        r.activity.makeVisible();\n    }\n}\n\n// Activity.java\nvoid makeVisible() {\n    if (!mWindowAdded) {\n        ViewManager wm = getWindowManager();\n        wm.addView(mDecor, getWindow().getAttributes());\n        mWindowAdded = true;\n    }\n    // 让DecorView可见\n    mDecor.setVisibility(View.VISIBLE);\n}\n```\n至此，页面进入可见状态。\n\n### 总结\n布局文件在调用setContentView后，会在PhoneWindow中初始化DecorView，找到DecorView中ID为`@android:id/content`的ViewGroup，然后将我们设置的View添加到其中，最终在RESUME阶段，会将DecorView添加到WindowManager中，并设置其可见。","tags":["Android"],"categories":["Android"]},{"title":"Android Context","url":"/2021/09/d4ee8f599683/","content":"曾经被问过一个问题：Android系统中的Context有几种？当时没怎么说清楚，现在再来聊聊这个问题。\n\n<!--more-->\n\nContext是个抽象类，它有两个直接子类：ContextImpl和ContextWrapper。ContextImpl实现了Context中的所有抽象方法，ContextWrapper也实现了Context的抽象方法，但它的实现方式是通过调用其持有的ContextImpl实例mBase的对应的方法，所以它叫做Wrapper，可以理解成ContextImpl的包装类。\n```shell\nContext\n|--ContextImpl\n|--ContextWrapper\n```\n\n而Application、Service都是ContextWrapper的直接子类。此外，ContextWrapper还有其他直接子类，如ContextThemeWrapper、ReceiverRestrictedContext，而Activity则是ContextThemeWrapper的直接子类，因为它需要主题。ReceiverRestrictedContext则是给BroadcastReceiver使用的，后面说。\n```shell\nContext\n|--ContextImpl\n|--ContextWrapper\n   |--Appliction\n   |--Service\n   |--ReceiverRestrictedContext\n   |--ContextThemeWrapper\n      |--Activity\n```\n\n这几个类的实例都是在ActivityThread中创建，其中的Context也是在这里面赋值的，分别来看一看\n\n### Activity\n创建Activity时，最终会走到ActivityThread.performLauncherActivity方法里\n```java\n// ActivityThread.java 省略了部分代码\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    // 创建ContextImpl\n    ContextImpl appContext = createBaseContextForActivity(r);\n    // 创建Activity\n    Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\n    // 创建Application\n    Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n    // 调用Activity.attach\n    activity.attach(appContext, this, getInstrumentation(), r.token,r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken);\n    // 调用Activity.onCreate\n    if (r.isPersistable()) {\n        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n    } else {\n        mInstrumentation.callActivityOnCreate(activity, r.state);\n    }\n}\n\nprivate ContextImpl createBaseContextForActivity(ActivityClientRecord r) {\n\tContextImpl appContext = ContextImpl.createActivityContext(this, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);\n\treturn appContext;\n}\n```\n可以看到，创建一个Activity的过程主要有3步：一是通过反射创建Activity实例，二是准备相关的参数，其中包含ContextImpl实例和Application实例，接着是attach，在这个方法里初始化Activity的成员变量，其中有一个Application类型的变量mApplication，传入的Application是为了初始化这个变量。\n\n### Service\n创建Service最终会走到ActivityThread.handleCreateService方法里\n```java\n// ActivityThread.java 省略了部分代码\nprivate void handleCreateService(CreateServiceData data) {\n\t// 创建ContextImpl\n\tContextImpl context = ContextImpl.createAppContext(this, packageInfo);\n\t// 创建Application\n\tApplication app = packageInfo.makeApplication(false, mInstrumentation);\n\t// 创建Service\n\tService service = packageInfo.getAppFactory().instantiateService(cl, data.info.name, data.intent);\n\t// 调用Service.attach\n\tservice.attach(context, this, data.info.name, data.token, app, ActivityManager.getService());\n\t// 调用Service.onCreate\n\tservice.onCreate();\n}\n```\n和Activity类似，不再赘述。\n\n### BroadcastReceiver\n创建BroadcastReceiver最终会走到ActivityThread.handleReceiver方法里\n```java\n// ActivityThread.java 省略了部分代码\nprivate void handleReceiver(ReceiverData data) {\n\t// 创建Application\n\tApplication app = packageInfo.makeApplication(false, mInstrumentation);\n\t// 创建ContextImpl\n\tContextImpl context = (ContextImpl) app.getBaseContext();\n\t// 创建BroadcastReceiver\n\tBroadcastReceiver receiver = packageInfo.getAppFactory().instantiateReceiver(cl, data.info.name, data.intent);\n\t// 调用BroadcastReceiver.onReceive\n\treceiver.onReceive(context.getReceiverRestrictedContext(), data.intent);\n}\n```\n可以看到，BroadcastReceiver没有直接使用创建的ContextImpl，而是通过context.getReceiverRestrictedContext()获取了ReceiverRestrictedContext，上面提过，它是ContextWrapper的直接子类，重写了其中的registerReceiver和bindService方法，方法里直接抛出异常，所以用BroadcastReceiver中的Context无法创建广播和服务\n```java\n// ContextImpl.java 只展示关键代码\nclass ReceiverRestrictedContext extends ContextWrapper {\n\t@Override\n    public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler) {\n        if (receiver == null) {\n            // Allow retrieving current sticky broadcast; this is safe since we\n            // aren't actually registering a receiver.\n            return super.registerReceiver(null, filter, broadcastPermission, scheduler);\n        } else {\n            throw new ReceiverCallNotAllowedException(\"BroadcastReceiver components are not allowed to register to receive intents\");\n        }\n    }\n\n    @Override\n    public boolean bindService(Intent service, ServiceConnection conn, int flags) {\n        throw new ReceiverCallNotAllowedException(\"BroadcastReceiver components are not allowed to bind to services\");\n    }\n}\n```\n\n### Application\n在创建上面3个的时候可以看到，Application都是通过packageInfo.makeApplication来创建的，packageInfo是个类型为LoadedApk类型的实例，具体看一看\n```java\n// LoadedApk.java 只展示了关键代码\npublic Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) {\n\tif (mApplication != null) {\n\t\treturn mApplication;\n     }\n     ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n     app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);\n     mApplication = app;\n     // 调用Application的onCreate方法\n     instrumentation.callApplicationOnCreate(app);\n}\n\n// Instrumentation.java \npublic Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException {\n    Application app = getFactory(context.getPackageName()).instantiateApplication(cl, className);\n    app.attach(context);\n    return app;\n}\n```\n先创建了ContextImpl的实例，然后在Instrumentation中通过反射创建了Application实例，接着将上一步创建的ContextImpl实例通过attach方法传入，最后调用Application.onCreate方法\n\n### ContentProvider\n四大组件说了三个，再说说最后一个ContentProvicer，虽然不是Context的子类，但也和Context相关。创建Provider在ActivityThread.installProvider方法中\n```java\n// ContextImpl.java 只展示关键代码\nprivate ContentProviderHolder installProvider(Context context, ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) {\n\tContext c = null;\n    ApplicationInfo ai = info.applicationInfo;\n    if (context.getPackageName().equals(ai.packageName)) {\n        c = context;\n    } else if (mInitialApplication != null && mInitialApplication.getPackageName().equals(ai.packageName)) {\n        c = mInitialApplication;\n    } else {\n        try {\n            c = context.createPackageContext(ai.packageName, Context.CONTEXT_INCLUDE_CODE);\n        } catch (PackageManager.NameNotFoundException e) { // Ignore }\n    }\n    // 创建ContentProvider\n\tContentProvider localProvider = packageInfo.getAppFactory().instantiateProvider(cl, info.name);\n\tlocalProvider.attachInfo(c, info);\n}\n```\n视情况而定，ContextImpl的来源有多种，但最后都是通过attachInfo方法传入ContentProvider。\n\n### 总结\n回到最初的问题，Context有几种呢，就普遍性而言有3种：Application、Activity和Service，如果严谨一点，算上ReceiverRestrictedContext的话，那么就是4种。","tags":["Android","Context"],"categories":["Android"]},{"title":"Android适配","url":"/2021/09/352f312b568b/","content":"\n为什么要适配呢？这篇文章来聊一聊。\n<!--more-->\n因为现在有着五花八门的Android手机厂商，生产出来的设备有着各种各样的分辨率。这一点不像Apple，设备类型就那么有限的几种。\n\n为了做到让一张设计稿，在不同的设备上看起来都差不多，或者说不会相差太多，这就是适配的目的。\n\n### 几个概念\n- 屏幕大小\n常见的有5.0英寸、6.1英寸等等，这个长度指的是屏幕对角线的长度，根据勾股定理便可以根据长和宽算出来。为什么要用对角线的长度来表示一个屏幕的大小呢，对角线相等的屏幕可以有多种长和宽。查了下，是历史遗留原因，因为最开始的时候都是用圆形显示管来显示的，所以用直径表示显示管的大小，也就是其内矩形的对角线。后来工艺发展，做成了矩形，但这种方式保留了下来\n\n- 屏幕分辨率\n常见的有720x1280、1080x1920、1440x2560，其中的数字指的是该方向的像素块的数量。比如720x1280的屏幕，在较短的方向有720个像素块，较长的方向有1280个像素块，不同的屏幕像素块的大小可能是不同的。比如两块屏幕都是1080x1920，但一块是5.0英寸另一块是5.9英寸，那5.0的像素块就要小一些。\n\n- px\npixel，像素\n\n- ppi\n全称pixel per inch，指每英寸上的像素数量，比如1080宽，物理长度为3.375英寸，那么每英寸上的像素数量就是1080/3.75=320个，一般针对的是描述屏幕\n\n- dpi\n和ppi类似，全称是dots per inch，指每英寸上墨点的数量，针对的是打印到纸上，比如160dpi，意思就是打印出一条1英寸长的线时，这条线上会有160个墨点。在 Android 里，这两个值是相等的，在屏幕上显示一张图片时，一个像素块便相当于一个墨点，但是在打印机上打印时这两个不一定相等。\n\n因为不同屏幕有着不同的分辨率，所以我们不能在代码中以像素为单位设置图片的大小，比如一个ImageView设置成540px宽，有的屏幕上是2英寸，有的屏幕上却是3英寸，这样的效果是不可行的，因此，这里引出了新概念：\n\n- dip\n全称是density independent pixel，密度独立像素，简称dp。这是一个基于像素、和屏幕密度相关的长度单位。规定：在密度是160的屏幕上，1dp=1px，所以密度是320的屏幕上，1dp=2px，总之，密度越高的屏幕上，1dp代表的像素越多。\n\n- density\n密度，等于dpi/160，意思就是在这块屏幕上，1dp等于多少px\n\n在Android中，用dp代替px的好处是什么呢？例如，设计稿是1080x1920，屏幕密度是320，所以density等于2。上面一张160px宽的图片，即160/2=80dp。\n在dpi为320的屏幕上，也就是density等于2，它等于160像素，即0.5英寸；\n在dpi为160的屏幕上，也就是density等于1，它等于80像素，即0.5英寸。\n虽然屏幕密度不同，但这张图占用的物理宽度都是0.5英寸，给人视觉上的感觉是一样的。\n\n### 适配是在适配什么\n首先明确一点是，不管用什么单位，Android在最终绘制到屏幕时，都会转化成像素。原本这样就可以了，不同的屏幕我可以显示出同样的物理宽度，但由于手机厂商之多、生产的屏幕之多，所以还有着特殊的情况。\n\n比如，同样是1080x1920的屏幕，一块的dpi是480，density为480/160=3，物理宽度为1080/480=2.25英寸；另一块的dpi是360，density为360/160=2.25，物理宽度为1080/360=3英寸\n\n1080x1920、dpi为480的设计稿上，有个产品列表，介绍图片宽度为360dp，在第一块屏幕上刚好占满屏幕宽度，但是在第二块屏幕上只占用了360x2.25=810px，宽度上剩下了一大块空白，1080-810=270px。\n\n本质上，dip就是为了在大屏幕上显示更多的内容。这里的「大」是什么意思呢？可以看上面的例子，同样的1080像素的宽度，前者的物理宽度是2.25英寸，而后者是3英寸，明显后者比前者更大，所以在显示同样dp的图片时，后者留了一大片空白，因为可以显示更多的内容。\n\n但是这种显示效果就不可接受的，而说了半天的适配，就是适配这样的情况，同样像素宽度的屏幕，物理尺寸却不同，让一站图片在不同的屏幕都显示相同的比例。什么意思呢，就是说，设计稿里这张图占据了全部的宽度，那么在所有的屏幕上都要占据全部的宽度，如果在设计稿中占据了一半的宽度，那么在所有的屏幕上也要占据一半的宽度。\n\n因此，适配就是为了让UI元素在不同设备屏幕上，所占比例是相同的。\n\n可以看出，这样的适配只能满足一个方向，宽或者高。按照宽的比例调整就无法估计高，反之同理。若设备的宽高比与设计稿的宽高比相同，此时可兼顾两者。\n\n现在主要下面这几种适配方案。\n\n### 方案：修改density\n这套方案，是基于dp。\n\n因在绘制时使用的都是px，系统在将dp转化成px时，用的是TypedValue中的方法，最后输出都是px。\n```java\npublic static float applyDimension(int unit, float value, DisplayMetrics metrics) {\n        switch (unit) {\n        case COMPLEX_UNIT_PX: // pixel，像素\n            return value;\n        case COMPLEX_UNIT_DIP: // dp转px\n            return value * metrics.density;\n        case COMPLEX_UNIT_SP: // scaled dp 可缩放dp\n            return value * metrics.scaledDensity;\n        case COMPLEX_UNIT_PT: // point，1point = 1/72英寸\n            return value * metrics.xdpi * (1.0f/72);\n        case COMPLEX_UNIT_IN: // inch 英寸\n            return value * metrics.xdpi;\n        case COMPLEX_UNIT_MM: // millimeter 毫米\n            return value * metrics.xdpi * (1.0f/25.4f);\n        }\n        return 0;\n   }\n```\n直观的来看，同样是360dp宽的图片，在两个屏幕上所占比例不同的原因是，两个屏幕的宽度不同，一个是1080px/density=360dp，另个是1080px/density=480dp。\n\n这种方案逻辑是，动态修改屏幕的dp宽度，让屏幕的宽度等于设计稿的宽度。同时，屏幕的dp宽度是基于像素宽度和density计算出来的，而屏幕的像素宽度无法修改，所以要修改的就是density，这个值就是存储在DisplayMetrics中的一个变量，从上面的代码中可以看到，系统在将dp转化成px时，使用的是这个变量，所以修改这个变量就可以修改系统最终计算出来的px值。公式为：`动态density = 屏幕像素宽度/设计稿的dp宽度`\n\n修改的时机是，在系统使用之前，也就是在`setContentView`之前。\n\n```kotlin\nfun setCustomDensity(activity: Activity, application: Application, designWidthDp: Int) {\n        val appDisplayMetrics = application.resources.displayMetrics\n        val targetDensity = 1.0f * appDisplayMetrics.widthPixels / designWidthDp\n        val targetDensityDpi = (targetDensity * 160).toInt()\n        appDisplayMetrics.density = targetDensity\n        appDisplayMetrics.densityDpi = targetDensityDpi\n        val activityDisplayMetrics = activity.resources.displayMetrics\n        activityDisplayMetrics.density = targetDensity\n        activityDisplayMetrics.densityDpi = targetDensityDpi\n    }\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n        setCustomDensity(this, application, 420)\n        super.onCreate(savedInstanceState)\n    }\n```\n\n这是字节给出的方案，成本极低，但是没有代码，Github上有人实现了一套，可以参考，[点击跳转](https://github.com/JessYanCoding/AndroidAutoSize)。\n\n### 方案：smallest width\n这套方案的原理是，手动指定每个像素所代表的dp数量。\n\n举个例子，假设设计稿是1080x1920\n\n在宽度为360dp的屏幕上，将宽度分为1080份，每份代表360/1080=0.33dp，然后生成这样一份文件：\n```xml\n<resources>\n    <dimen name=\"DIMEN_1PX\">0.33dp</dimen>\n    <dimen name=\"DIMEN_2PX\">0.66dp</dimen>\n    ...\n    <dimen name=\"DIMEN_1079PX\">359.67dp</dimen>\n    <dimen name=\"DIMEN_1080PX\">360dp</dimen>\n</resources>\n```\n在宽度为380dp的屏幕上，将宽度分为1080份，每份代表380/1080=0.35dp；\n在宽度为400dp的屏幕上，将宽度分为1080份，每份代表400/1080=0.37dp；\n...\n要针对当前的主流宽度屏幕各生成一份这样的文件，放到对应的目录下\n```shell\nvalues\nvalues-sw360dp\nvalues-sw380dp\nvalues-sw400dp\nvalues-sw420dp\n```\n在写布局文件时，控件的尺寸就用设计稿上的px尺寸，比如，设计稿上宽度为100px，那么在布局文件里就写`@dimen/DIMEN_100PX`，\n\n在360dp的屏幕上，就会读取到33dp，占比33/360=0.09；\n在380dp的屏幕上，就会读取到35dp，占比35/380=0.09；\n在400dp的屏幕上，就会读取到37dp，占比37/400=0.09；\n\n虽然在精度上有一些损失，但可忽略，实现了适配的需求。这种方案需要精准命中目标设备的宽度，所以需要我们准备足够多的这样的文件。\n\n### 方案：指定宽高\n这套方案的原理是，手动指定每个像素所代表的像素。\n\n这句话看着是不是有些别扭？一个像素不就是一个像素么，怎么还能代表其他像素呢？接着往下看\n\n上面的方案是按照屏幕宽度命中设备，这个方案是按照屏幕的像素宽度命中设备。\n\n还是那个例子，假设设计稿是1080x1920\n\n在720x1280的屏幕上，把宽分成1080份，每份代表720/1080=0.67px；把高分成1920份，每份代表0.67px；\n```xml\n<resources>\n    <dimen name=\"X1\">0.67px</dimen>\n    <dimen name=\"X2\">1.33px</dimen>\n    ...\n    <dimen name=\"X1079\">719.26px</dimen>\n    <dimen name=\"X1080\">720px</dimen>\n\n    <dimen name=\"Y1\">0.67px</dimen>\n    <dimen name=\"Y2\">1.33px</dimen>\n    ...\n    <dimen name=\"Y1079\">1279.33px</dimen>\n    <dimen name=\"Y1080\">1280px</dimen>\n</resources>\n```\n其中的X代表横向，Y代表竖向。\n\n在1080x1920的屏幕上，把宽分成1080份，每份代表1080/1080=1px；把高分成1920份，每份代表1920/1920=1px；\n在1440x2560的屏幕上，把宽分成1080份，每份代表1440/1080=1.33px；把高分成1920份，每份代表2560/1920=1.33px；\n\n将这些文件分别放到对应的目录下\n```shell\nvalues\nvalues-1280x720\nvalues-1920x1080\nvalues-2560x1440\n```\n在写布局文件时，控件的尺寸就用设计稿上的px尺寸，比如，设计稿上宽度为100px，高度为200px，那么在布局文件里就写`@dimen/X100`、`@dimen/Y200`，\n\n在1280x720的屏幕上，就会读取到，宽度67px，占比67/720=0.09，高度133px，占比133/1280=0.1；\n在1920x1080的屏幕上，就会读取到，宽度100px，占比100/1080=0.09，高度200px，占比200/1920=0.1；\n在2560x1440的屏幕上，就会读取到，宽度133px，占比133/1440=0.09，高度266px，占比266/2560=0.1；\n\n同上面一样，会有一些些精度上的损失，但基本上还是满足了适配的需求。这套方案也需要精准命中目标设备屏幕的像素宽高，因为同时指定了宽和高，所以相比上面只指定宽度的方案，需要准备更多的dimen文件，而现在市场的屏幕五花八门，很难保证准备的文件可以囊括所有的情况。\n\n### 总结\n抛开需求谈适配就是在扯淡，所以如果说哪个方案最合适，还是要看具体的需求。相比之下，第一套方案操作简单，且成本低，不用额外添加适配文件，不会进一步增加包体大小。","tags":["Android","屏幕适配"],"categories":["Android"]},{"title":"Android Fragment","url":"/2021/09/5536a870cb20/","content":"\n原文地址：[https://juejin.cn/post/7006970844542926855#heading-13](https://juejin.cn/post/7006970844542926855#heading-13)\n\n<!--more-->\n\n原作者的slogan是，喜欢写又臭又长的文章。这篇文章确实长的很，洋洋洒洒上万字，就这字数就过滤掉了很大一部分人，但是我喜欢。写的很好，里面内容有旧也有新，担心哪天点开这链接弹出来个404，所以摘抄点出来。\n\n### 生命周期\nFragment中有两个生命周期，一个自身的生命周期，另一个是其所包含的View的生命周期，其中的View是可以多次被创建和销毁的，所以在使用ViewModel时，要将数据与View的生命周期相关联。\n![](https://i.loli.net/2021/09/19/YHsuRZOc6TSxVJA.png)\n\n### 回退栈\n增加/移除/替换Fragment都是基于事务进行的，当提交事务时，将事务添加到了回退栈，那么在将事务从回退栈中弹出时，FragmentManager就会reverse its operation，反向执行事务的操作，也就是恢复成该事务执行之前的状态。按下返回键，如果回退栈不为空，则回退栈就会弹出事务来响应返回按钮事件。当然，也可以不将事务加到回退栈中。相关接口：\n```kotlin\nFragmentTransaction.addToBackStack\nFragmentTransaction.popBackStack\nFragmentTransaction.disallowAddToBackStack\n```\n\n### registerForActivityResult\n`startActivityForResult`和`onActivityResult`都已经废弃，`registerForActivityResult`是官方推荐的从Activity获取数据的方式，新方式变得灵活了不少，如下：\n- 创建`ActivityResultContract<I, O>`的实例，声明输入/输出数据，需要实现里面的抽象方法。`createIntent`方法用来获取跳转的Intent，`parseResult`用来处理返回的数据\n- 创建`ActivityResultCallback<O>`接口实例，用来处理返回的数据，里面只有一个方法`onActivityResult`\n- 最后调用ComponentActivity中方法`registerForActivityResult(contract, callback)`把前两步创建的参数传入即可\n\n### Fragment Result\n在FragmentManager有这样一组方法，可以进行数据通信：\n```java\npublic final void setFragmentResultListener(String requestKey, LifecycleOwner lifecycleOwner, FragmentResultListener listener)\n\npublic final void setFragmentResult(String requestKey, Bundle result)\n```\n简单说，就是在观察者模式的基础上，加上了生命周期的管理，不管是Activity还是Fragment，只要能获取到同一个FragmentManager就可以通信。需要注意的是，里面保存key和listener用的是`Map<String, FragmentResultListener>`，所以一个key只能有一个listener，后面的会把前面的覆盖。\n\n### Fragment中监听返回按键\n```kotlin\nclass PlaceholderFragment(private val sectionNumber: Int) :\n    Fragment(R.layout.fragment_placeholder) {\n\n    private val onBackPressedCallback = object : OnBackPressedCallback(true) {\n        override fun handleOnBackPressed() {\n            //TODO       \n        }\n    }\n\n    override fun onAttach(context: Context) {\n        super.onAttach(context)\n        requireActivity().onBackPressedDispatcher.addCallback(this, onBackPressedCallback)\n    }\n}\n```\n\n### 其他用途\n- Fragment可设置内部的UI View，也可以不设置。当不设置时，可用其来监听生命周期，其中LifeCycle、Glide用的便是这种方式。\n- 也可以用作方法代理，请求权限，可将请求与处理放到一起处理，而不是像`registerForActivityResult`分开处理。FragmentTransaction的`add`方法都有多个重载方法，支持只添加一个Fragment，若此Fragment无View，则对用户来说是无感的，但对于我们来讲可以在其中处理一些业务。","tags":["Android","Fragment"],"categories":["Android"]},{"title":"Android之检查知否开了代理","url":"/2021/09/044f31f510db/","content":"\n最近有个新需求，用户如果开启了代理，就不让进入，在此记录一下检查方式。\n\n<!--more-->\n简单说，就是通过`ConnectivityManager`获取到设备当前的所有网络连接，如果其中包含`TRANSPORT_VPN`类型的连接，则认为开启了代理。\n\n代码如下\n```kotlin\nfun checkProxyOpen(ctx: Context): Boolean {\n     val manager = ctx.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager\n     manager.allNetworks.toList().forEach { network ->\n         val cap = manager.getNetworkCapabilities(network)\n         val vpnTransport = cap?.hasTransport(NetworkCapabilities.TRANSPORT_VPN) ?: false\n         if (vpnTransport) {\n             return true\n         }\n     }\n     return false\n}\n```","tags":["Android","Proxy"],"categories":["Android"]},{"title":"多apk导出与安装","url":"/2021/09/b14c888939d1/","content":"\n在aab盛行的年代，一个应用已经不单单对应一个apk文件了，经常是两个，或是多个。\n\n<!--more-->\n在设备上安装一个应用后，安装时的apk文件都是会存储在手机里的。不知道做没做过这样的需求，就是反编译别人apk，看看里面都有些什么，图片资源也好，库文件也罢。\n\n### adb导出apk\n\n```shell\n# 如果不知道完整的包名，就先这样过滤出目标包名\n$ adb shell pm list package | grep key-word\n\n# 获取apk文件路径\n$ adb shell pm path target.pakcage.name\n\n# 经过上一步，会得到一个或多个apk文件的路径，导出到本地\n$ adb pull xxxx.apk ~/xxx.apk\n```\n拿到apk文件了，就可以做想做的事了，比如用jadx反编译。\n\n另外，这个文件的位置，通过package manager也可以得到，代码如下：\n```java\nPackageManager pm = getPackageManager();\nApplicationInfo info = pm.getApplicationInfo(\"package_name\", 0);\nString path = info.sourceDir; // 这个path就是上面pm path的结果\n```\n\n### adb安装多apk\n安装单个apk\n```shell\n$ adb install xxx.apk\n```\n安装多个apk\n```shell\n$ adb install-multiple 1.apk 2.apk 3.apk\n```\n\n### 题外话\n终端窗口直接执行adb命令，会显示出命令介绍，不难发现它有三个安装命令，\n```shell\n$ adb\napp installation (see also `adb shell cmd package help`):\n install [-lrtsdg] [--instant] PACKAGE\n     push a single package to the device and install it\n install-multiple [-lrtsdpg] [--instant] PACKAGE...\n     push multiple APKs to the device for a single package and install them\n install-multi-package [-lrtsdpg] [--instant] PACKAGE...\n```\n除了install和install-multiple，还有个install-multi-package命令。\n\ninstall和install-multiple都是安装单应用的，一个对应单apk，一个是多apk。而install-multi-package命令是安装多应用，意思就是一次同时安装多个应用。你可能会想，怎么会需要一次安装多个应用呢，平常不都是单个开发的吗？\n\n有些需求吧，直到你遇到前你都不会相信：原来还真的会有这样的需求啊～\n\n我是真的遇到了，所以顺便提一提。另外还有，不是所有版本的设备都支持这个命令，在不支持的设备上执行后就会报错，不用深究，换个测试机就可以。","tags":["Android"],"categories":["Android"]},{"title":"Android之drawable和mipmap的区别","url":"/2021/09/86f0cc8aed5a/","content":"\nAndroid项目里，res中有两种放资源图片的目录，一个是drawable，另一个是mipmap。\n\n<!--more-->\n\n使用Android Stuido创建新项目时，默认会把app icon放到mipmap里，每个分辨率里各放一份，从hdpi到xxxhdpi，1倍图到4倍图。\n\n但是开发过程中，资源图一般都是放到drawable中，我们常用的是3倍图目录，drawable-xxhdpi，习惯了这样做却没深究为什么这样做。\n\n既然已经创建了mipmap目录，为什么不直接使用，而非要用手动创建的drawable目录呢？\n\n突然想到这个问题，就查了一下，原来这两个目录除了名字，还是有其他区别的：\nmipmap目录在安装到设备后，各个分辨率的资源会全部保留，而drawable下的资源只会选择一份合适的，其他的不保留。\n\n特意验证了一下：\n- 创建一个新项目，把一张图在drawable-xxhdpi（3倍）和drawable-xhdpi（2倍）中各放一份\n- 安装到一个屏幕密度440，也就是2.75倍的设备上（160为1倍）\n- adb导出apk包，jadx反编译\n- 发现只有3倍目录下有这张图，2倍目录下没有\n- 验证正确","tags":["Android"],"categories":["Android"]},{"title":"AAB介绍以及bundletool的使用","url":"/2021/09/4d7cb573fdf1/","content":"\n自2021年8月开始，GooglePlay商店要求开发者使用AAB来发布新应用。自打2018年5月谷歌官方推出AAB，已经过去了3个年头。\n\n<!--more-->\n\n### 介绍\nAAB，即Android App Bundle，可以把它理解成是新一代的APK。相比于APK，它的优点是可以进一步减小安装包的大小。\n\n举个例子，如果项目了引用了native库，那么一般都会有多个so库文件，每个库文件对应一种abi架构。\n\n当使用apk安装时，需要把所有so文件打到apk文件里，移动端下载该apk文件来安装程序；\n\n当使用aab安装时，会根据移动端的架构选择出对应的库文件，以及其他资源和代码，打到apk文件里，移动端下载该apk文件来安装程序，这样就不需要下载其他用不上的库文件，下载的文件小，省时间又省流量，用户体验好，所有官方主推这种格式。\n\n可以看到，中间有个过程，根据请求安装的客户端来生成对应的apk安装包，这件事就是Goolge Play商店在做。目前，不是所有的应用商店都支持了这个操作，只能在支持的应用商店上使用aab分发应用，不支持的依然要用apk格式的文件。\n\n### 分割维度\n根据官方文档介绍，[点击查看](https://developer.android.com/guide/app-bundle/configure-base#disable_config_apks)，支持3个维度的分割：语言、分辨率和架构\n```groovy\nandroid {\n    // When building Android App Bundles, the splits block is ignored.\n    splits {...}\n\n    // Instead, use the bundle block to control which types of configuration APKs\n    // you want your app bundle to support.\n    bundle {\n        language {\n            // Specifies that the app bundle should not support\n            // configuration APKs for language resources. These\n            // resources are instead packaged with each base and\n            // feature APK.\n            enableSplit = false\n        }\n        density {\n            // This property is set to true by default.\n            enableSplit = true\n        }\n        abi {\n            // This property is set to true by default.\n            enableSplit = true\n        }\n    }\n}\n```\n\n### 生成aab文件\nGradle任务中，有配置好的task，bundleDebug、bundleRelease，执行对应的task就可以生成aab文件。\n\n严格来讲，aab文件并不是安装包，在生成的时候并不知道目标设备的信息，所以只能算是一堆零件，可以按需组装。\n\n### bundletool\n[谷歌官方介绍](https://developer.android.com/studio/command-line/bundletool) [官方项目地址](https://github.com/google/bundletool)\n这是个专门用来操作aab文件的工具，可在项目里直接下载jar包使用，也可以通过`brew install bundletool`安装。\n\n这个工具可以通过aab文件生成apks、将apks安装到手机，还有几个不常用的功能，可以看项目里的介绍。\n\n1. 生成设备规范的JSON文件\n```shell\n$ bundletool get-device-spec --output=/tmp/device-spec.json\n```\n这个命令可以生成当前连接设备的规范文件，也就是参数信息文件。也可以手动创建，格式如下：\n```json\n{\n  \"supportedAbis\": [\"arm64-v8a\", \"armeabi-v7a\"],\n  \"supportedLocales\": [\"en\", \"fr\"],\n  \"screenDensity\": 640,\n  \"sdkVersion\": 27\n}\n```\n\n2. 生成apks\n```shell\n$ bundletool build-apks --bundle=/MyApp/my_app.aab --output=/MyApp/my_app.apks\n```\n此外还可以通过`ks`,`ks-pass`,`ks-key-alias`,`key-pass`四个参数来指定签名，如果不指定则使用缺省的签名文件\n这个apks是针对所有设备，加上`--connected-device`数可生成只针对当前连接的设备，多个设备时使用`--device-id=serial-id`，也可以使用`--device-spec=xxx.json`通过JSON文件来限定。\n为什么是apks呢，因为这真的就是多个apk。把.apks改成.zip后解压缩，就会看到里面有很多apk文件，包括基本的apk，以及按维度分割的apk。\n\n3. 安装apks到设备\n```shell\n$ bundletool install-apks --apks=xxx.apks\n```\n可以再检查一下都安装了哪几个apk文件：\n```shell\n$ adb shell pm path your.app.package.name\npackage:/data/app/your.app.package.name-_cJc4OrWZxYQCwC4AaWAtw==/base.apk\npackage:/data/app/your.app.package.name-_cJc4OrWZxYQCwC4AaWAtw==/split_config.arm64_v8a.apk\n```\n可以看到，安装了一个基本的base.apk，以及一个对应abi的apk。想查询设备上其他app时，可以通过这个命令来查询包名：\n```shell\n$ adb shell pm list package | grep key-word\n```\n\n4. 其他命令\n- 抽取apks的子集\n```shell\nbundletool extract-apks\n--apks=/MyApp/my_existing_APK_set.apks\n--output-dir=/MyApp/my_pixel2_APK_set.apks\n--device-spec=/MyApp/bundletool/pixel2.json\n```\n- 获取下载的大小\n```shell\nbundletool get-size total --apks=/MyApp/my_app.apks\n```\n\n### 总结\n国内一般都是无线网来下载、安装，但老外们使用流量的却不在少数，所以如果能减少安装包的大小，对于提高CVR还是有一定帮助的。\n\n","tags":["Android","bundletool"],"categories":["Android"]},{"title":"Android混淆配置","url":"/2021/09/54483afe4c94/","content":"\n记录一下混淆配置。\n\n<!--more-->\n\n混淆，其实就是给项目里的类、变量、方法等，换个名字，以此来降低可读性，同时还可以使包体变小。\n\n### 单模块项目\n这个相对简单，只需要配置build.gradle文件\n```groovy\nandroid {\n    buildTypes {\n        release {\n            minifyEnabled true // 打开混淆开关，只有为true的时候才会混淆\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n            // 还可以再加两个配置来进一步减小包体\n            zipAlignEnabled true // 对齐\n            shrinkResources true // 移除\n        }\n    }\n}\n```\n- 只有打开minifyEnabled开关才会混淆\n- proguardFiles用来指定混淆配置文件，参数里的文件都会生效\n- proguard-android-optimize.txt在: ～/Android/sdk/tools/proguard/目录下\n- 除了上面这个文件，还有其他几个官方写好的默认配置\n- proguard-rule.pro在build.gradle同目录下，自己额外的混淆配置写在这个文件里\n\n### 多模块项目\n所有混淆配置写在一起，便于修改和管理，但是当不再依赖其中某个模块而将其移除后，这时混淆文件中对应的配置就是冗余的。\n\n所以，一般都是各自模块的混淆配置写在所在的模块里。主模块开启混淆，就会给所有模块混淆。\n\n主模块的配置依然同上，子模块的配置如下：\n```groovy\nandroid {\n    buildTypes {\n        release {\n            consumerProguardFiles 'proguard-rules.pro'\n        }\n    }\n}\n```\n如果不关心编译类型的话，可以直接写在默认配置块，使用AndroidStudio创建项目时，它已经帮忙写上了，用consumer-rules.pro文件名来区分\n```groovy\nandroid {\n    defaultConfig {\n        consumerProguardFiles \"consumer-rules.pro\"\n    }\n}\n```\n- 注意这里使用的是consumerProguardFiles\n- proguardFiles配置在子模块里是不生效的\n- getDefaultProguardFile只能在proguardFiles里使用\n\n### 输出文件\n- dump.txt 说明apk中所有类文件的内部结构\n- mapping.txt 原始于混淆后的类、方法和字段名称的对应关系\n- seeds.txt 未进行的混淆的类和成员\n- usage.txt 从apk移除的代码\n\n### 总结\n打开官方写好的配置文件，可以看到里面已经包含了用到的基本配置。所以不管是主模块还是子模块的proguard-rule.pro里，只需要写上自己额外需要的配置，如gson数据类，以及引入的第三方依赖所要求的反混淆配置，即可。","tags":["Android"],"categories":["Android"]},{"title":"Android 9发送http请求","url":"/2021/09/3b8c4beeb864/","content":"\n目前的http请求有两种，一种是明文的http请求，一种是加了密的https请求。官方出于安全考虑，Android 9及以后的版本，系统默认禁掉了http请求。但有些需求，偏偏需要我们发送http请求，这个时候就需要额外加个配置。\n\n<!--more-->\n\n在res目录下，新建个名叫xml的目录，在里面新建个xml文件，名字随意合法即可，但一般都是叫`network_security_config.xml`，让人一看到名字就知道这文件的作用。文件内添加http访问请求的配置，如下：\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <base-config cleartextTrafficPermitted=\"true\" />\n</network-security-config>\n```\n\n然后再把这个配置，应用到application，在AndroidManifest.xml中，修改application标签，添加一行，如下：\n```xml\n <!-- 其他内容省略 -->\n <application\n        android:networkSecurityConfig=\"@xml/network_security_config\"> \n</application>\n```\n\n创建个配置文件，然后应用到application，这样就可以发送http请求了。","tags":["Android","Http"],"categories":["Android"]},{"title":"Java之反射","url":"/2021/09/48858ef75b98/","content":"\n反射，是Java的一种高级特性。就我而言，实际开发中很少遇到用反射的需求，但这并不能否定反射的重要地位，这篇文章来简单说一说。\n\n<!--more-->\n\n\n### 前言\n在Java里，有一个类，名字叫`Class`，这个名字总是容易给人一种这是个特殊的类。其实，和其他类一样，这也是个普通的类，在`java.lang`包下，lang就是language的简写，里面都是和Java语言本身相关的东西。这个类里面包含了一个类的所有信息：\n```java\n// 省略了一些代码\npackage java.lang\n\npublic final class Class<T> {\n\n\t// 这里只列举了一部分\n\tString name; // 类名\n\tClassLoader classLoader; // 类加载器\n\tString packageName; // 包名\n\tClass<?>[] interfaces; // 所实现的接口\n\tConstructor<?>[] contructors; // 构造方法\n\tField[] fields; // 字段\n\tMethod[] methods; // 方法\n\tint modifiers; // 类修饰符\n\n    private Class(ClassLoader loader, Class<?> arrayComponentType) {\n        this.classLoader = loader;\n        this.componentType = arrayComponentType;\n    }\n}\n```\n\n在JVM首次调用到一个类的时候，会先将这个类加载到JVM里，这个过程就是在为这个类创建Class实例，且JVM只会为每个类创建一个Class实例，如果存在则在直接使用。可以看到，Class只有一个构造方法，而且是私有的，只有JVM可以调用。\n\n那么，怎么获取到JVM创建的Class实例呢？一共有3种方式：\n```java\n// 方式1：通过类的静态变量class\nClass clz = String.class;\n\n// 方式2：通过实例的方法\nString str = \"str\";\nClass clz = str.getClass();\n\n// 方式3：通过Class的静态方法Class.forName\n// Class.forName有3个重载方法，可以传入不同的限定名称\nClass clz = Class.forName(\"java.lang.String\");\n```\n\n通过类的Class实例，我们可以创建类的实例，调用类的所有成员变量、和成员方法，包括私有的。\n\n### 方法概览\n通过反射，一般有三个目的：获取构造方法Constructor来创建实例、获取方法Method来调用，以及获取字段Field来set/get值。除此之外，还可以获取其他信息，如注解，来完成额外的操作，这些在这先不讨论。\n\n||构造方法|字段|方法|\n|--|--|--|--|\n|单个public|getConstructor()|getField()|getMethod()|\n|所有public|getConstructors()|getFields()|getMethods()|\n|类里任一|getDeclaredConstructor()|getDeclaredField()|getDeclaredMethod()|\n|类里所有|getDeclaredConstructors()|getDeclaredFields()|getDeclaredMethods()|\n\n- 不加s是获取单个，加s是获取所有\n- 不加declared的，是获取public的，protected都不行，必须public，可以是自己的，也可以是继承的\n- 加declared的，是获取类里面自己声明的，只能是写在类里的成员，不能是继承的，公开的、私有的都可以获取\n\n### 示例类\n创建了一个示例接口和一个示例类，很简单，看一眼就可以跳过。\n```java\n// Person接口\npublic interface Person {\n    String getName();\n    void sayHi(String toWho);\n}\n\n// Student实现类\npublic class Student implements Person {\n\n    // 一个私有变量  一个公开变量\n    private int sex;\n    public int score;\n\n    // 一个无参数构造方法 一个有参数的构造方法\n    public Student() {\n        this.score = 0;\n        this.sex = 1;\n    }\n\n    public Student(int score, int sex) {\n        this.score = score;\n        this.sex = sex;\n    }\n\n    // 私有构造方法\n    private Student(int score) {\n        this.score = score;\n        this.sex = 2;\n    }\n\n    // 继承过来的方法\n    @Override\n    public String getName() { return \"student\"; }\n\n    @Override\n    public void sayHi(String toWho) {\n        System.out.println(\"student say hi to :\" + toWho);\n    }\n\n    // 一个私有方法\n    private void setSex(int sex) { this.sex = sex; }\n\n    public int getSex() { return sex; }\n}\n\n```\n\n### 通过反射获取构造方法\n- 获取无参构造方法\n```java\n// 获取Class实例\nClass<Student> clz = Student.class;\n\nConstructor<Student> cst = clz.getConstructor();\nSystem.out.println(cst.newInstance().score); // 缺省值 0\n```\n- 获取有参数的构造方法\n```java\nClass<Student> clz = Student.class;\n\nConstructor<Student> cst = clz.getConstructor(int.class, int.class);\nSystem.out.println(cst.newInstance(80, 1).score); // 传入值 80\n```\n- 获取私有的构造方法\n```java\nClass<Student> clz = Student.class;\n\n// 这里必须用加declared的，因为带一个参数的构造方法是私有的\nConstructor<Student> ctr3 = clz.getDeclaredConstructor(int.class);\nctr3.setAccessible(true); // 使用私有的成员前，需要先设置为可访问\nSystem.out.println(ctr3.newInstance(55).score);\n```\n\n### 通过反射获取字段\n字段，Field，即类里面声明的成员变量。像上面，通过Class实例获取到类的构造函数，可以用其创建类的实例，那获取到字段有什么用呢？用字段可以获取其对应的值，所以，就需要一个类的实例，有了实例，才能获取。\n- 获取公开字段\n```java\nClass<Student> clz = Student.class;\n\nField score = clz.getField(\"score\"); // 通过字段名字获取\n// 使用字段，需要一个Student实例\nStudent student = new Student(60, 1);\n//  这句话的意思就是，获取student实例中score字段的值\nSystem.out.println(score.get(student)); // 60\n```\n- 获取私有字段\n```java\nClass<Student> clz = Student.class;\nStudent student = new Student(60, 1);\n\nField sex = clz.getDeclaredField(\"sex\"); // 这里必须加declared 通过字段名字获取\nsex.setAccessible(true); // 设置可访问\nsex.set(student, 10); // 先设置为10\nSystem.out.println(sex.get(student)); // 10\n```\n\n### 通过反射获取方法\n字段可通过名字获取，但方法不可只通过名字，因为会存在方法重载，即几个方法名字一样，但参数类型或者数量不同，所以要获取方法，就需要指定方法名称，同时和方法的参数的类型列表。和字段相同的是，方法在调用的时候，也需要一个实例，有了实例，才能在这个实例上调用其方法。\n- 获取公开方法\n```java\nClass<Student> clz = Student.class;\nStudent student = new Student(60, 1);\n\nMethod sayHi = clz.getMethod(\"sayHi\", String.class); // 指明方法名，和参数类型\nsayHi.invoke(student, \"Teacher\"); // student say hi to :Teacher\n```\n- 获取私有方法\n```java\nClass<Student> clz = Student.class;\nStudent student = new Student(60, 1);\n\nMethod setSex = clz.getDeclaredMethod(\"setSex\", int.class); // 指明方法名，和参数类型\nsetSex.setAccessible(true); // setSex是私有的，先设置为可访问\nsetSex.invoke(student, 100); // 调用，设置sex的值\nSystem.out.println(student.getSex()); // 100\n```\n\n### 总结\n通过上面的例子，可以看出：反射都是基于类的Class实例，通过里面的成员，来进行一些操作的。先获取到Class实例，再获取对应的成员变量，比如字段、方法等，然后再利用这些成员，采取一些操作来达成目的。\n\n没有太多代码，就不创建项目了，附上所有代码：\n<script src=\"https://gist.github.com/oynix/414b7208de0e3d0b59b2aaa3879b82de.js\"></script>","tags":["Java","反射"],"categories":["Java"]},{"title":"使用HtmlCompat改变字体样式","url":"/2021/09/995b1034fc8d/","content":"\n这篇文章说一说Android中的`HtmlCompat`使用。\n\n众所周知的是，要想做出各种炫酷多变样式的字体，使用Html+CSS最方便。一来是标签语法简单，二来是它支持设定很多属性。`HtmlCompat`这个类，就是帮助我们在Android中使用Html+CSS语法的工具。\n\n<!--more-->\n\n### 介绍\n`HtmlCompat`是`Html`的包装类，其中只有两个方法：一个是`fromHtml`，另个是`toHtml`。\n\n其实，所有带有Compat的类基本都是包装类。在Android SDK升级的过程中，到了某个版本某些类可能有了大改动，比如多了重载方法，这个版本以前的SDK，调用老方法；这个版本之后的调用新方法。而包装类的出现是为了方便调用者，我们只管调用包装类中的方法，而包装类里面会根据版本做出判断，去调用对应的方法。\n\n- fromHtml\n故名思义，这个方法就是把Html语法转换成要最终的样式，这个常用，这次主要说一说它\n\n- toHtml\n与`fromHtml`相反，很少用，还没有遇到过这样的需求，就不说了\n\n### 使用\n```java\npublic static Spanned fromHtml(@NonNull String source, @FromHtmlFlags int flags) {\n    if (Build.VERSION.SDK_INT >= 24) {\n        return Html.fromHtml(source, flags);\n    }\n    return Html.fromHtml(source);\n}\n```\n- param: source\n即Html文本，如\"\\<b\\>Hello\\<\\/b\\> World!\"，标签b会将Hello加粗显示\n\n- param: flags\n一看便知，这个是SDK 24新加的参数，它的作用是添加一些额外的操作，它现在有9个可选的常量值，每个值都有介绍，比如：`<p>`标签会从新的一行开始、`<h>`标签会从新的一行开始，等等。一般不需要，传0即可\n\n### 支持的标签\n官方文档写的很简单，这是地址：[文档](https://developer.android.com/reference/kotlin/androidx/core/text/HtmlCompat?hl=en)。我是从源码中看的，`Html.java`文件中，有个`handleStartTag`方法，它支持以下的标签解析：\n> br, p, ul, li, div, span, strong, b, em, cite, dfn, i, big, small, font, blockquote, tt, a, u, del, s, strike, sup, sub, h, img\n\n\n### 常用效果\n- 加粗\nb和strong都是加粗，效果是一样的，在解析的时候同等方式处理\n```kotlin\nprivate fun genBold() = HtmlCompat.fromHtml(\n    \"加粗效果：<b>加粗</b> or <strong>加粗2</strong>\", 0\n)\n```\n- 倾斜\n有多个标签都是倾斜：em、cite、dfn、i，它们的效果是一样的\n```kotlin\nprivate fun genItalic() = HtmlCompat.fromHtml(\n    \"倾斜效果: <i>倾斜</i> <em>倾斜</em> <cite>倾斜</cite>\", 0\n)\n```\n- 下划线\n```kotlin\nprivate fun genUnderline() = HtmlCompat.fromHtml(\n    \"下划线：<u>下划线</u>\", 0\n)\n```\n- 删除线\n```kotlin\nprivate fun genDelLine() = HtmlCompat.fromHtml(\n    \"删除线：<del>删除线</del>\", 0\n)\n```\n- 上角标\n```kotlin\nprivate fun genSup() = HtmlCompat.fromHtml(\n    \"上角标：2<sup>3</sup>\", 0\n)\n```\n- 下角标\n```kotlin\nprivate fun genSub() = HtmlCompat.fromHtml(\n    \"下角标：a<sup>4</sup>\", 0\n)\n```\n- 字体样式 \n这里的font只支持两个属性，看过源码才知道，之前还一直研究为什么别的属性不生效。\n一个是color，一个是face。color用来改变字体颜色，face用来改变字体的样式，face用的少，color用的多。\nface有四个可选值：normal默认，sans无衬线字体，serif有衬线字体，monospace等宽字体。\n```kotlin\nprivate fun genFont() = HtmlCompat.fromHtml(\n    \"字体样式：<font color='#873748' face='monospace'>字体颜色</font>,\" +\n            \"<font face='sans'>字体Face sans</font>\", 0\n)\n```\n\n### 自定义标签\n系统提供的标签就是这么多，如果需要一些其他的效果，如改变字体大小，可以自定义标签。`HtmlCompat.fromHtml`有个重载方法，是用来支持自定义标签的：\n```java\npublic static Spanned fromHtml(@NonNull String source, @FromHtmlFlags int flags,\n            @Nullable ImageGetter imageGetter, @Nullable TagHandler tagHandler) {\n        if (Build.VERSION.SDK_INT >= 24) {\n            return Html.fromHtml(source, flags, imageGetter, tagHandler);\n        }\n        return Html.fromHtml(source, imageGetter, tagHandler);\n    }\n```\nsource和flags同上，如果使用了img标签，就要提供ImageGetter参数来获取图片，没用则传入null；如果使用了自定义标签，则需提供tagHandler来解析自定义的标签。\n\n说一说自定义字体。\n\n需要先创建一个类，实现TagHandler接口，接口里就一个方法，`handleTag`，是用来解析标签的，在这里添加逻辑\n```kotlin\n// size是字号\nclass SizeLabel(private val size: Int) : Html.TagHandler {\n\t// 记录开始的角标和结束的角标\n    private var startIndex = 0\n    private var stopIndex = 0\n\n    // 这个方法会被调用两次，开始标签调用一次，opening=true，结束标签调用一次，opening=false\n    // output就是实时解析出来的内容\n    override fun handleTag(opening: Boolean, tag: String, output: Editable, xmlReader: XMLReader?) {\n    \t// tag就是标签的名字，这个名字不可与系统支持的重复，因为自定义的标签是放在判断的最后一个else里处理的\n        if (tag.lowercase(Locale.getDefault()) == \"size\") {\n            if (opening) {\n                startIndex = output.length\n            } else {\n                stopIndex = output.length\n                output.setSpan(\n                    AbsoluteSizeSpan(size),\n                    startIndex,\n                    stopIndex,\n                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE\n                )\n            }\n        }\n    }\n\n}\n```\n使用的方式与上类似，如下：\n```kotlin\nprivate fun genSizeLabel() = HtmlCompat.fromHtml(\n    \"自定义标签size：<size>加大字号</size>\", 0, null, SizeLabel(50)\n)\n```\n\n\n### 总结\n总的来说，方式简单，用起来也很简单，可以满足一些基本的奇特UI需求。除了使用Html的方式，还有一些其他的方式，如在`strings.xml`文件中定义，也可以实现一些特殊的效果。\n\n还可以使用`Span`来实现，这个的功能相当的多，在`android.text.style`这个包下都是它的实现类，每个类都可以实现一种UI效果，下次用到的时候再来仔细说一说。\n\n附上示例的Github地址：[https://github.com/oynix/htmlcompat-sample](https://github.com/oynix/htmlcompat-sample)","tags":["Android"],"categories":["Android"]},{"title":"Hexo+Github快速搭建个人博客","url":"/2021/09/33313fbab399/","content":"现在搭建个人博客的方式越来越多，而且过程也越来越简单。大体的思路，都是先生成静态网页，然后部署到一个依托网站。\n\n这篇文介绍的是用Hexo生成静态网站，然后部署到Github。\n\n<!--more-->\n\n### 介绍Node和npm\nHexo是用Node写的，所以要安装它所依赖的环境后才能用，先贴一下廖雪峰关于Node和npm关系的介绍\n> npm是什么东东？npm其实是Node.js的包管理工具（package manager）。\n>\n>为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。\n>\n>更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。\n\n### 安装Node和npm\n开始我用`brew`装了半天，中间总有个包不成功。最后发现直接从Node官网下载安装包最省事，一步到位。[https://nodejs.org/en/](https://nodejs.org/en/)。\n\n安装完之后检查一下，如果能显示出版本号，就可以了：\n```sh\n$ node -v\nv14.17.6\n\n$ npm -v\n6.14.15\n```\n\n### 安装hexo-cli\n这个工具是帮助我们初始化个人站的，一行命令就可以生成一个空站点\n```sh\n# For Mac\n$ sudo npm install hexo-cli -g\n\n# For Windows\n$ npm install hexo-cli -g\n```\n\n装完之后，验证一下是否成功，显示如下内容则表示成功了\n```sh\n$ hexo\nUsage: hexo <command>\n\nCommands:\n  help     Get help on a command.\n  init     Create a new Hexo folder.\n  version  Display version information.\n```\n\n### 初始化个人站\n一行命令即可：\n```sh\n# blog就是网站目录的名字，可随意起，合法即可\n$ hexo init blog\nINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git\nINFO  Install dependencies\nadded 242 packages from 207 contributors and audited 243 packages in 13.774s\n\n15 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n\nINFO  Start blogging with Hexo!\n```\n\n然后，进到blog目录，可以看到，这就是个Node项目。`package.json`里面是项目所需要的依赖，接下来安装依赖\n```sh\n# 切换到项目根目录\n$ cd blog\n\n$ npm install\nadded 1 package from 5 contributors and audited 243 packages in 2.29s\n\n15 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n\n```\n执行一下hexo命令，如下显示则说明成功:\n```sh\n$ hexo\nINFO  Validating config\nUsage: hexo <command>\n\nCommands:\n  clean     Remove generated files and cache.\n  config    Get or set configurations.\n  deploy    Deploy your website.\n  generate  Generate static files.\n  help      Get help on a command.\n  init      Create a new Hexo folder.\n  list      List the information of the site\n  migrate   Migrate your site from other system to Hexo.\n  new       Create a new post.\n  publish   Moves a draft post from _drafts to _posts folder.\n  render    Render files with renderer plugins.\n  server    Start the server.\n  version   Display version information.\n```\n\n### 生成静态网站\n看上面的命令介绍，其中这几个最常用：\n- `generate`：就是用来生成静态网站的，一般简写成`g`\n- `server`：是在本地运行，也就是把静态网站依托在本机上，一般简写成`s`\n- `deploy`：是把静态站部署到远程，一般简写成`d`\n- `new`：用来生成一片空文章\n- `init`：用来生成一个空页面\n- `claan`：是删除生成的静态网站\n\n```sh\n# 生成\n$ hexo g\n\n# 运行\n$ hexo s\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\n```\n看提示可以知道，hexo正在运行，在浏览器中访问本地的4000端口，就可以看到了\n\n### 部署之Github Token\n所谓部署，就是把生成的静态网站的所有文件，推送到远程的Github仓库。所以，Hexo就需要推送的权限。我用的是https协议，还没试过git协议。https的方式就是把带有推送权限的token放到仓库链接里即可。\n\nGithub Token：Github首页 -> 右上角个人头像 -> Settings -> Developer settings -> Personal access token -> Generate new token -> 把repo的大权限勾上\n\n默认的过期时间Expiration是30天，可以选长一点，不然过期之后还要更新token。最后就得到了一个以`ghp_`开头、总长度为40的字符串的token。\n\n### 部署之远程仓库\n在Github上新建个仓库，用来放静态网站的文件。仓库的名字有要求，一般是这样的：`*.github.io`，\n星号可以替换成你自己想要的单词。然后，这整个就是仓库的名字，比如我的仓库地址就是：\n> `https://github.com/oynix/oynix.github.io.git`\n\n\n- 如果，这个星号使用的是Github账号的名字，那么最终的网站地址就是：\n> `https://oynix.github.io/`\n- 如果，这个星号使用的是其他的名字，比如blog，那么最终的网站地址就是：\n> `https://oynix.github.io/blog.github.io/`\n\n换句话说，如果想要用最短URL，那么就用Github账号的名字；如果要用到path了，可以给仓库起个短点名字，如就叫blog，那么最终的网站地址就是:\n> `https://oynix.github.io/blog/`\n\n当然，如果买了自己的域名，那么这些都不重要。\n\n我本也想买个域名的，一年几十块钱。但国内的环境吧，各种验证、实名、审核等等，将我冷冰冰的劝退了，以至于我觉得github这个就挺好的。\n\n\n### 部署之hexo-deployer-git插件\n因为要把代码部署到Github，所有需要先安装这个插件。hexo也支持部署到其他地方，各自都有对应的插件。\n```sh\n# 根目录下执行\n$ npm install hexo-deployer-git --save\n+ hexo-deployer-git@3.0.0\nadded 1 package from 1 contributor and audited 244 packages in 2.394s\n\n15 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n```\n\n### 部署之配置\n根目录下有个文件，`_config.yml`，这个是用来配置网站的一些属性的，使用的yaml格式，里面的注释里写了很详细的介绍，大部分应该都可以看得懂。\n\n其中，`deploy`是用来配置选项的：\n```yaml\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: ''\n```\n把前两步生成的token和仓库地址，写进去就可以，github的规则是把token加在前面然后用@连接\n```yaml\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: https://{your_github_person_access_token}@github.com/{yourname}/{repo_name}.git\n  branch: master\n\n```\n\n\n### 部署\n`generate`之后，会在根目录生成一个名字是`.deploy_git`的目录，这个目录默认是隐藏的，里面就是生成的静态网站，将会被推送到远程。\n```sh\n# 根目录下执行\n$ hexo g\n$ hexo d\nINFO  Validating config\nINFO  Deploying: git\nINFO  Setting up Git deployment...\n.... 省略 ....\n```\n然后，就可以在远程仓库看到所有的网站文件了\n\n\n### 启用Github Pages\n打开Github，进入刚刚创建的仓库，进入Settings，点进Pages，Branch选master，save一下。\n\n然后，上面就会出现网站地址了：`Your site is published at https://oynix.github.io/`\n\n首次部署，需要等1分钟左右才能访问，不然看到的就是404。\n\n\n### 总结\n总的来说，分为3大步：搭建环境、生成静态网站以及推送到远程。按流程来，还是很顺利的。\n\n其中，有个主题还没说，hexo支持很多主题，每个主题都可以配置很多选项，如字体的颜色大小、字间距、行间距、多字体，等等。搭配上这些，就可以让页面在视觉上更加美观、舒服，等有时间再单独写一写这些。","tags":["Hexo","Github"],"categories":["自建博客"]},{"title":"数据结构之排序算法","url":"/2021/08/de342dd74fb7/","content":"[原文链接](https://www.cnblogs.com/onepixel/articles/7674659.html)\n\n在实际应用中常常用到排序算法，这篇文来总结一下常用的。上面是原文链接，文章里介绍很详细，还有动图示例，形象易懂。\n\n重复的内容不再赘述，看原文就好，这里写一写我常用到的。\n<!--more-->\n\n### 冒泡排序\n这个记的最深刻，也是最常用的，因为一遇到排序问题，首先想到的就是冒泡。原理很简单，一句话总结就是，每次将未排序部分的极值移动到尾端。如果是升序排列，那么每次寻找的就是最大值，反之则是最小值。这个过程，就像是在冒泡。\n```kotlin\nval arr = intArrayOf(3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48)\n\nfun bubble() {\n    for (i in arr.indices) {\n    \t// 每趟循环到倒数第二个即可，因为比较的时候是j和j+1\n        for (j in 0 until (arr.size - i - 1)) {\n            if (arr[j] > arr[j + 1]) {\n                val temp = arr[j]\n                arr[j] = arr[j + 1]\n                arr[j + 1] = temp\n            }\n        }\n    }\n    println(arr.localString())\n}\n\n// 输出\n[2,3,4,5,15,19,26,27,36,38,44,46,47,48,50]\n```\n\n### 选择排序\n这个和冒泡排序很像，第一次从所有元素中找到极值放到第一位，第二次从剩下的元素中找到极值放到第二位，以此类推。\n```kotlin\n// 选择排序\nfun select () {\n    var temp = 0 // 临时变量\n    var pointer = 0 // 用来标记当前在找的位置\n    while (pointer < arr.size - 1) {\n        temp = arr[pointer]\n        // 通过for循环，找到本趟的极值\n        for (i in pointer until arr.size) {\n            if (arr[i] < temp) {\n                temp = temp xor arr[i]\n                arr[i] = temp xor arr[i]\n                temp = temp xor arr[i]\n            }\n        }\n        // 本趟结束，把极值赋值给当前位置\n        arr[pointer++] = temp\n    }\n}\n```\n\n### 快速排序\n- 这是个有趣的排序算法，使用递归\n- 选择一个基准值，一般选左端，或者右端\n- 目标是把比基准值小的放到左边，大的放到右边\n- 如果选择左端则从右端指针开始判断，反之从左端指针开始\n- 这里假设选择左端为基准值，所以从右端指针开始扫描\n- 用临时变量存储基准值，此时可认为左指针指向的位置是空\n- 如果右指针比基准值小，则将右指针的值填充到左指针，此时认为右指针位置是空\n- 此时用左指针扫描\n- 遇到比基准值大的时候，将左指针的值填充到右指针，此时认为左指针位置为空\n- 此时用右指针扫描\n- 直到两个指针相遇，将临时变量的基准值填充到任一指针\n- 然后将基准值左右两部分，分别递归\n```kotlin\nfun quick(low: Int,high: Int, array: IntArray) {\n    if (low >= high) return\n    var left = low\n    var right = high\n    val temp = array[left]\n    var reverse = true\n    while (left < right) {\n        if (reverse) {\n            // 从右指针扫描\n            // 当值比基准值小时，右指针的值填充到左指针，此时认为右指针为空\n            if (array[right] < temp) {\n                array[left] = array[right]\n                reverse = !reverse // 掉头\n            } else {\n                right-- // 右指针左移动\n            }\n        } else {\n            // 从左指针扫描\n            // 当值比基准值大时，左指针填充到右指针，此时认为左指针为空\n            if (array[left] > temp) {\n                array[right] = array[left]\n                reverse = !reverse // 调用\n            } else {\n                left++ // 左指针右移动\n            }\n        }\n    }\n    // 一趟结束后，指针相遇，把基准值放到指针所在位置\n    // 此时左侧都比基准值小，右侧都比基准值大\n    array[left] = temp\n    // 分别递归左侧和右侧\n    quick(low, left - 1, array)\n    quick(left + 1, high, array)\n}\n```\n\n### 插入排序\n- 将序列分为两部分，左侧是已经排好顺序的，右侧是未排的\n- 每次从未排序列中取一个数字，将其插入到已排好部分\n- 循环至排序完成\n```kotlin\nfun insert(array: IntArray) {\n    var border = 0 // 左侧已排序部分的边界\n    while (border < array.size - 1) {\n        // 每次取右侧未排序部分的第一个数字，将其插入到左侧的目标位置\n        for (i in border downTo 0) {\n            if (array[i + 1] < array[i]) {\n                // 异或操作交换值，不用额外的临时变量\n                array[i] = array[i] xor array[i + 1]\n                array[i + 1] = array[i] xor array[i + 1]\n                array[i] = array[i] xor array[i + 1]\n            } else {\n                break\n            }\n        }\n        border++\n    }\n}\n```\n\n\n[https://github.com/oynix/SortAlgorithmSample](https://github.com/oynix/SortAlgorithmSample)","tags":["数据结构","排序算法"],"categories":["算法"]},{"title":"Android基础之Handler","url":"/2021/08/aeb0be134986/","content":"\n说到Android的基础，就一定绕不开Handler，以及相关的Looper、Message、MessageQueue等。这篇文就说说它们之间的联系，来加深印象。\n\n太基础的就不说了，那样要说的东西就太多太多了，多少会显得冗杂。\n\n<!--more-->\n\n### 前言\n众所周知，一个application启动后，会启动一个线程作为主线程，也就是ActivityThread，所有更新UI的操作都要放到这个线程里进行。除去这个主线程，其他线程均为子线程，在子线程里更新UI会报错：CalledFromWrongThreadException。这是因为在ViewRootImpl中做了检查，只要当前线程不是主线程，就会抛出异常。\n\n那么，Android为什么这么做呢？\n\n可以假想一下，如果不这么设计，允许所有线程更新UI，那么在并发量多的时候：一个TextView，同一时刻，有10个线程想要更新其显示的内容，这就会发生混乱。\n\n如果想要解决这个问题，首先想到的应该就是加个同步锁synchronized，你们都可以更新UI，但是要排队，一个一个来。混乱的问题解决，但是性能很差，同步锁这个东西，不到万不得已的时候我都不会用。\n\n最后，就有了现在的这种模式，单独出一个线程，也就是主线程，用于更新UI，其他线程若想更新UI，那么就向主线程发送一个消息，发送之后继续自己的任务，等到合适的时机，主线程就会根据发来的消息，做出相应的处理。\n\n这就是Android的消息驱动模型。\n\n### 团队组成\n以前我只是知道个大概，为了写清楚这篇文，就去看了对应的源文件。搭配着AndroidStudio，源文件的可读性还是很不错的，如果有时间都可以去看看。\n\n- Handler\n用来发消息，即Message；同时，Handler也要提供Message的处理方式，也就是需要做哪些操作。\n- Looper\n如同名字一样，是一个循环器。它负责循环读取消息队列，MessageQueue中的消息，如果其中有新的未处理的消息，则就将其取出，并处理。\n- Message\n消息中包含了一个操作需要的一些信息，后面细说。\n- MessageQueue\n消息队列，所有的消息都将会发送到这里\n\n这么说有些抽象，理解起来可能有些困难，打个比方：你去银行存款，到了银行需要先排号，然后等着喊号，排号期间，你可以做些别的事情，比如聊天、打游戏或者看视频，等到轮到你的时候，你就会去柜台，拿出自己装在兜里的钱，然后存到自己的账户上。\n\n这个过程中，你就是一个Handler，排号就相当于发送了一个Message，所有排队中的号就相当于一个MessageQueue，而银行的叫号系统就如同一个Looper。\n\n可以同时有多个Handler，一个Handler也可以发送多个Message。\n\n\n### Looper\n- 线程里本没有Looper，需要手动创建，调用静态方法Looper.prepare()。\n- 一个线程只允许创建一个Looper，Looper里面使用了一个类型为`ThreadLocal<Looper>`静态变量`sThreadLocal`，保存了所有线程的Looper\n- 一个线程创建多个Looper时会报错：RuntimeException(\"Only one Looper may be created per thread\")\n- 主线程的Looper不需要手动创建，因为ActivityThread在main方法，也就是程序的入口，自动创建\n- Looper里面持有了一个MessageQueue，在构造方法里面将其初始化\n- 调用Looper中的loop方法之后，Looper便会循环从MessageQueue中取消息，没有消息时便会等待\n```java\n// 只列出了源码中的部分重要代码\npublic class Looper {\n    static ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>()\n    static Looper sMainLooper;\n    final MessageQueue mQueue;\n\n    // 构造方法中出实例化MessageQueue\n    private Looper(boolean quitAllowed) {\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n\n    // 通过prepare创建Looper，并添加到sThreadLocal中\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n\n    public static Looper myLooper() {\n        return sThreadLocal.get(); // 获取当前线程的Looper\n    }\n\n    public static void loop() {\n        final Looper me = myLooper();\n        final MessageQueue queue = me.mQueue;\n        for (;;) {\n            Message msg = queue.next(); // 取出消息\n            msg.target.dispatchMessage(msg); // 掉用Handler的方法来处理消息\n        }\n    }\n}\n\n```\n\n\n### Handler\n- 在创建Handler时，会从Looper的静态变量`sThreadLocal`中获取当前线程的Looper，获取不到则报错`RuntimeException(\"Can't create handler inside thread that has not called Looper.prepare()\");`\n- 除会自动创建Looper的主线程，其他线程需要手动调用Loopr.prepare()进行创建，调用Looper.loop()开始循环取消息\n- 现在推荐的创建Handler的方式，是通过Looper.mainLooper()获取主线程的Looper，然后将其作为构造参数传到Handler的构造方法里\n- 所以，可以同时存在多个Handler发消息更新UI，因为使用的都是同一个Looper，即mainLooper\n- 可以通过Handler发送Message，也可以发送Runnable，在加入到MessageQueue前，Runnable也会被封装成Message，最后Looper统一处理Message\n```java\n// 只列出了源码中的部分重要代码\npublic class Handler {\n    Looper mLooper;\n    MessageQueue mQueue;\n    Handler.Callback mCallback;\n\n    public Handler(Callback callback, boolean async) {\n        mLooper = Looper.myLooper() // 获取当前线程的Looper\n        if (mLooper == null) {\n            throw new RuntimeException(\"Can't create handler inside thread that has not called Looper.prepare()\");\n        }\n        mQueue = mLoopr.mQueue;\n        mCallback = callback;\n    }\n\n    public Handler(Looper looper, Callback callback, boolean async) {\n        mLooper = looper;\n        mQueue = looper.mQueue;\n        mCallback = callback;\n    }\n\n    // 在Looper中调用，用来分发消息\n    public void dispatchMessage(Message message) {\n        if (msg.callback != null) {\n            handleCallback(msg); // 是Runnable的时候走到这里\n        } else { // 是Message的时候走的这里\n            if (mCallback != null) { \n                // 这个mCallback就是构造方法里传入的，\n                // 如果不重写handleMessage方法，也可以传入一个Callback来处理Message\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg); // 如果没传入Callback，则调用handleMessage\n        }\n    }\n\n    // 用来处理Runnable\n    private static void handleCallback(Message message) {\n        message.callback.run();\n    }\n\n    // 用来处理Message\n    public void handleMessage(@NonNull Message msg) {\n    }\n}\n```\n\n\n### Message\n- Message是个链表结构，其中有个Message类型的成员变量，叫`next`，靠这个变量来建立起链表结构\n- Message中持有Handler的引用，叫做`target`，在Handler发送消息时，会把Handler赋值给Message的`target`变量\n- 在Looper从MessageQueue中取出Message时，便会调用其`target`的dispatchMessage方法来让Handler处理Message\n- Message一般不手动创建，而是通过`Message.obtain()`方法，如果Message池子里有可用的实例则会重用，没有则会返回一个new Message\n- 当使用Handler.post Runnable时，会将Runnable封装成Message，将Runnable赋值给其中的callback变量\n```java\n// 只列出了源码中的部分重要代码\npublic class Message {\n    Message next; // 链表，指向下一个Message\n    Handler target; // 发送和处理Message的Handler\n    Runnable callback; // 发送的Runnable\n\n    // obtain有很多重载方法\n    public static Message obtain() { /*省略*/ }\n}\n```\n\n### MessageQueue\n- 这就是个消息队列，持有队列头消息的引用\n- 对队列的操作都封装在这个类中，比如增加消息到链表\n- 因为可通过Handler消息发送延迟消息，所以队列中的消息是根据执行时间排队的\n\n\n### ThreadLocal\n总觉得说一说这个ThreadLocal才算完整。ThreadLocal是用来存储数据的，带有一个范型的参数，也就是需要存储的数据类型，它能够将数据与线程相互关联，保证在同一个线程取到的数据是同一个。通过get方法获取值，通过set方法设置值。\n实现原理就是，每个线程里维护了一个名字为`threadLocals`，类型是`ThreadLocal.ThreadLocalMap`的变量，这种类型就是一个定制的Map\n```java\npublic class ThreadLocal<T> {\n\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t); // 先获取到Thread里的map\n        if (map != null) // 然后将值set进去\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t); // 先获取到Thread里的map\n        if (map != null) { // 然后从里面get值\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n}\n\n// 使用\nThreadLocal tl = new ThreadLocal<String>();\ntl.set(\"something\");\nString value = tl.get()\n\n```\n\n\n### Handler使用\n当使用Handler发送Runnable时，直接使用Handler.post()方法即可，这个方法有很多重载方法，例如：可发送延迟的消息，也可以发送在某个具体时间执行的消息，等等。\n当使用Handler发送Message时，一般通过sendMessage方法发消息，然后重写它的handleMessage方法，来处理对应的消息，同样这个发送方法也有几个重载方法，查看对应的API文档即可：\n```kotlin\nclass HandlerTest : AppCompatActivity() {\n\n    // 创建一个Handler\n    val handler = object : Handler(Looper.getMainLooper()) {\n        override fun handleMessage(msg: Message) {\n            when (msg.what) {\n            1 -> { textView.text = \"message 1\" }\n            2 -> { textView.text = \"message 2\" }\n            }\n        }\n    }\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        object : Thread() {\n            override fun run() {\n                // 在子线程调用，如从网络获取到数据后\n                val message = Message.obtain()\n                message.what = 1\n                handler.sendMessage(message)\n            }\n        }.start()\n    }\n}\n```\n一般用法就是这样，但是这样编译器会提示一个可能会导致内存溢出的警告，因为在Handler的构造方法里做了检查：\n```java\npublic Handler(@Nullable Callback callback, boolean async) {\n    if (FIND_POTENTIAL_LEAKS) {\n        final Class<? extends Handler> klass = getClass();\n        // 在这里，如果当前类是匿名类，或者是成员类，或者是局部类，并且不是静态类，那么就会发出警告\n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                klass.getCanonicalName());\n        }\n    }\n    // 省略了一些代码\n}\n```\n\n### 什么是内存泄漏\n简单说，就是当一个实例该被GC回收的时候，却无法被回收，这块无法被回收的内存，就是泄漏的内存。什么意思呢，举个例子，当从一个Activity返回的时候，Activity的实例从任务栈弹出，这个时候这个实例就该被GC回收掉，但是，如果这时还被其他实例引用的话，GC是不会对它回收的。\n\n\n### 为何造成内存泄漏\n我们来捋一捋，作为Activity的匿名内部类，Handler会持有外部类的引用，这是Java的机制；而Handler会被Message中的target变量引用，Message会被MessageQueue引用，MessageQueue会被Looper引用，而Looper的生命周期是和当前Thread的生命一样长，如果是主线程的话，那么这个Looper就会贯穿应用全程，因为Activity的实例间接被主线程引用，对于有引用的内存，虚拟机宁愿报错OOM，也不会让GC回收。\n\n\n### 如何解决泄漏\n原因既然清楚了，那么就好解决了，只要避免Handler引用外部类，这里就是Activity，那么就不会泄漏了。一般的方案，就是使用静态内部类，静态内部类对外部类是没有引用的，这也是Java的机制；或者将Handler独立出去，单独放到一个类文件中，使其不再是内部类，这样便不会在引用外部类。\n\n\n### 总结\nAndroid通过主线程的消息队列来更新UI，而Handler是这个消息驱动模型中的一员，负责发消息和处理消息，同时这个模型中还有其他几个成员：Message，消息；MessageQueue，消息队列；Looper，从队列去消息的循环器。\n","tags":["Android"],"categories":["Android"]},{"title":"Android基础之singleTask","url":"/2021/08/83315178a002/","content":"\n时间做的久了，基础的知识忘的越来越多，正所谓：基础不牢，地动山摇。最近有需要，所以在慢慢重来，今天说一说Activity的几种启动模式。\n\n<!--more-->\n\n### 前言\n\n启动模式有4种：`standard`、`singleTop`、`singleTask`和`singleInstance`，这次主要说一说`singleTask`，相比于其他，这个算是比较复杂一些的。\n\n利用`adb`提供的命令`adb shell dumpsys activity activities`可以查看设备当前的activity栈信息。此外，`adb shell dumpsys`可以查看各种信息，直接输入就会列出它所支持的所有服务。\n\n下面贴了一段我用的测试设备的activity信息，乍一看上去内容有些冗杂，其实是因为里面包含了很详细的信息和关系，从头按行读，读懂的话不是问题。从这些数据中，可以对`Process`、`Task`之间的关系有个大致了解。\n\n为了不影响阅读体验，我把它折叠起来了。\n\n<details style='background-color:#f9f2f4'>\n<summary><font color='#c7254e' size='3px'> view detail</font></summary>\n```shell\n$ adb shell dumpsys activity activities\nACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)\nDisplay #0 (activities from top to bottom):\n\n  Stack #7: type=standard mode=fullscreen\n  isSleeping=false\n  mBounds=Rect(0, 0 - 0, 0)\n    Task id #25\n    mBounds=Rect(0, 0 - 0, 0)\n    mMinWidth=-1\n    mMinHeight=-1\n    mLastNonFullscreenBounds=null\n    * TaskRecord{3e1780c #25 A=com.oynix.launch.mode.sample U=0 StackId=7 sz=2}\n      userId=0 effectiveUid=u0a208 mCallingUid=2000 mUserSetupComplete=true mCallingPackage=null\n      affinity=com.oynix.launch.mode.sample\n      intent={act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.oynix.launch.mode.sample/.MainActivity}\n      realActivity=com.oynix.launch.mode.sample/.MainActivity\n      autoRemoveRecents=false isPersistable=true numFullscreen=2 activityType=1\n      rootWasReset=false mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE\n      Activities=[ActivityRecord{a1dcebd u0 com.oynix.launch.mode.sample/.MainActivity t25}, ActivityRecord{907f0e u0 com.oynix.launch.mode.sample/.AActivity t25}]\n      askedCompatMode=false inRecents=true isAvailable=true\n      mRootProcess=ProcessRecord{26080b8d0 21734:com.oynix.launch.mode.sample/u0a208}\n      stackId=7\n      hasBeenVisible=true mResizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION mSupportsPictureInPicture=false isResizeable=true lastActiveTime=6697777 (inactive for 3s)\n      isLaunchedPairApp=false\n      mOverrideConfig={0.0 ?mcc?mnc ?localeList ?layoutDir ?swdp ?wdp ?hdp ?density ?lsize ?long ?ldr ?wideColorGamut ?orien ?uimode ?night ?touch ?keyb/?/? ?nav/? winConfig={ mBounds=Rect(0, 0 - 0, 0) mAppBounds=null mWindowingMode=undefined mActivityType=undefined} mkbd/? desktop/?showBtnShape = -1  themeSeq=0 0 0  ?dc}\n      dexBoundsPolicy:\n       mLastNonFullBoundsDisplayId=-1\n      * Hist #1: ActivityRecord{907f0e u0 com.oynix.launch.mode.sample/.AActivity t25}\n          packageName=com.oynix.launch.mode.sample processName=com.oynix.launch.mode.sample\n          launchedFromUid=10208 launchedFromPackage=com.oynix.launch.mode.sample userId=0\n          app=ProcessRecord{26080b8d0 21734:com.oynix.launch.mode.sample/u0a208}\n          Intent { cmp=com.oynix.launch.mode.sample/.AActivity }\n          frontOfTask=false task=TaskRecord{3e1780c #25 A=com.oynix.launch.mode.sample U=0 StackId=7 sz=2}\n          taskAffinity=com.oynix.launch.mode.sample\n          realActivity=com.oynix.launch.mode.sample/.AActivity\n          baseDir=/data/app/com.oynix.launch.mode.sample-3DMFUnGXrp7XpBKiFV3-Tg==/base.apk\n          dataDir=/data/user/0/com.oynix.launch.mode.sample\n          stateNotNeeded=false componentSpecified=true mActivityType=standard\n          compat={480dpi} labelRes=0x7f0e001b icon=0x7f0c0000 theme=0x7f0f01a1\n          mLastReportedConfigurations:\n           mGlobalConfig={0.9 ?mcc?mnc [zh_CN_#Hans] ldltr sw360dp w360dp h668dp 480dpi nrml long port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 0, 0) mAppBounds=Rect(0, 0 - 1080, 2076) mWindowingMode=fullscreen mActivityType=undefined} s.9 mkbd/h desktop/dshowBtnShape = 0  themeSeq=0 0 0  ?dc}\n           mOverrideConfig={0.9 ?mcc?mnc [zh_CN_#Hans] ldltr sw360dp w360dp h668dp 480dpi nrml long port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 1080, 2076) mAppBounds=Rect(0, 0 - 1080, 2076) mWindowingMode=fullscreen mActivityType=standard} s.9 mkbd/h desktop/dshowBtnShape = 0  themeSeq=0 0 0  ?dc}\n          CurrentConfiguration={0.9 ?mcc?mnc [zh_CN_#Hans] ldltr sw360dp w360dp h668dp 480dpi nrml long port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 1080, 2076) mAppBounds=Rect(0, 0 - 1080, 2076) mWindowingMode=fullscreen mActivityType=standard} s.9 mkbd/h desktop/dshowBtnShape = 0  themeSeq=0 0 0  ?dc}\n          taskDescription: label=\"null\" icon=null iconResource=0 iconFilename=null primaryColor=ff6200ee\n           backgroundColor=ffffffff\n           statusBarColor=ff3700b3\n           navigationBarColor=fff2f2f2\n          launchFailed=false launchCount=1 lastLaunchTime=-5s311ms\n          haveState=false icicle=null\n          state=RESUMED stopped=false delayedResume=false finishing=false\n          keysPaused=false inHistory=true visible=true sleeping=false idle=true mStartingWindowState=STARTING_WINDOW_NOT_SHOWN\n          fullscreen=true noDisplay=false immersive=false launchMode=0\n          frozenBeforeDestroy=false forceNewConfig=false\n          mActivityType=standard\n          vrActivityType=0\n          waitingVisible=false nowVisible=true lastVisibleTime=-4s856ms\n          resizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION\n          mLastReportedMultiWindowMode=false mLastReportedPictureInPictureMode=false\n          mUseDeviceDefaultTheme=false\n      * Hist #0: ActivityRecord{a1dcebd u0 com.oynix.launch.mode.sample/.MainActivity t25}\n          packageName=com.oynix.launch.mode.sample processName=com.oynix.launch.mode.sample\n          launchedFromUid=2000 launchedFromPackage=null userId=0\n          app=ProcessRecord{26080b8d0 21734:com.oynix.launch.mode.sample/u0a208}\n          Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10000000 cmp=com.oynix.launch.mode.sample/.MainActivity }\n          frontOfTask=true task=TaskRecord{3e1780c #25 A=com.oynix.launch.mode.sample U=0 StackId=7 sz=2}\n          taskAffinity=com.oynix.launch.mode.sample\n          realActivity=com.oynix.launch.mode.sample/.MainActivity\n          baseDir=/data/app/com.oynix.launch.mode.sample-3DMFUnGXrp7XpBKiFV3-Tg==/base.apk\n          dataDir=/data/user/0/com.oynix.launch.mode.sample\n          stateNotNeeded=false componentSpecified=true mActivityType=standard\n          compat={480dpi} labelRes=0x7f0e001b icon=0x7f0c0000 theme=0x7f0f01a1\n          mLastReportedConfigurations:\n           mGlobalConfig={0.9 ?mcc?mnc [zh_CN_#Hans] ldltr sw360dp w360dp h668dp 480dpi nrml long port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 0, 0) mAppBounds=Rect(0, 0 - 1080, 2076) mWindowingMode=fullscreen mActivityType=undefined} s.9 mkbd/h desktop/dshowBtnShape = 0  themeSeq=0 0 0  ?dc}\n           mOverrideConfig={0.9 ?mcc?mnc [zh_CN_#Hans] ldltr sw360dp w360dp h668dp 480dpi nrml long port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 1080, 2076) mAppBounds=Rect(0, 0 - 1080, 2076) mWindowingMode=fullscreen mActivityType=standard} s.9 mkbd/h desktop/dshowBtnShape = 0  themeSeq=0 0 0  ?dc}\n          CurrentConfiguration={0.9 ?mcc?mnc [zh_CN_#Hans] ldltr sw360dp w360dp h668dp 480dpi nrml long port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 1080, 2076) mAppBounds=Rect(0, 0 - 1080, 2076) mWindowingMode=fullscreen mActivityType=standard} s.9 mkbd/h desktop/dshowBtnShape = 0  themeSeq=0 0 0  ?dc}\n          taskDescription: label=\"null\" icon=null iconResource=0 iconFilename=null primaryColor=ff6200ee\n           backgroundColor=ffffffff\n           statusBarColor=ff3700b3\n           navigationBarColor=fff2f2f2\n          launchFailed=false launchCount=0 lastLaunchTime=-24s316ms\n          haveState=true icicle=Bundle[mParcelledData.dataSize=2448]\n          state=STOPPED stopped=true delayedResume=false finishing=false\n          keysPaused=false inHistory=true visible=false sleeping=false idle=true mStartingWindowState=STARTING_WINDOW_REMOVED\n          fullscreen=true noDisplay=false immersive=false launchMode=0\n          frozenBeforeDestroy=false forceNewConfig=false\n          mActivityType=standard\n          vrActivityType=0\n          waitingVisible=false nowVisible=false lastVisibleTime=-6s410ms\n          resizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION\n          mLastReportedMultiWindowMode=false mLastReportedPictureInPictureMode=false\n          mUseDeviceDefaultTheme=false\n\n    Running activities (most recent first):\n      TaskRecord{3e1780c #25 A=com.oynix.launch.mode.sample U=0 StackId=7 sz=2}\n        Run #1: ActivityRecord{907f0e u0 com.oynix.launch.mode.sample/.AActivity t25}\n        Run #0: ActivityRecord{a1dcebd u0 com.oynix.launch.mode.sample/.MainActivity t25}\n\n    mResumedActivity: ActivityRecord{907f0e u0 com.oynix.launch.mode.sample/.AActivity t25}\n    mLastPausedActivity: ActivityRecord{a1dcebd u0 com.oynix.launch.mode.sample/.MainActivity t25}\n\n  Stack #0: type=home mode=fullscreen\n  isSleeping=false\n  mBounds=Rect(0, 0 - 0, 0)\n\n    Task id #18\n    mBounds=Rect(0, 0 - 0, 0)\n    mMinWidth=-1\n    mMinHeight=-1\n    mLastNonFullscreenBounds=null\n    * TaskRecord{13181bb #18 I=com.sec.android.app.launcher/com.android.launcher3.infra.activity.Launcher U=0 StackId=0 sz=1}\n      userId=0 effectiveUid=u0a96 mCallingUid=1000 mUserSetupComplete=true mCallingPackage=android\n      intent={act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10800100 cmp=com.sec.android.app.launcher/com.android.launcher3.infra.activity.Launcher}\n      origActivity=com.sec.android.app.launcher/.activities.LauncherActivity\n      realActivity=com.sec.android.app.launcher/com.android.launcher3.infra.activity.Launcher\n      autoRemoveRecents=false isPersistable=false numFullscreen=1 activityType=2\n      rootWasReset=false mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE\n      Activities=[ActivityRecord{ad01979 u0 com.sec.android.app.launcher/.activities.LauncherActivity t18}]\n      askedCompatMode=false inRecents=true isAvailable=true\n      stackId=0\n      hasBeenVisible=true mResizeMode=RESIZE_MODE_RESIZEABLE mSupportsPictureInPicture=false isResizeable=true lastActiveTime=6676345 (inactive for 24s)\n      isLaunchedPairApp=false\n      mOverrideConfig={0.0 ?mcc?mnc ?localeList ?layoutDir ?swdp ?wdp ?hdp ?density ?lsize ?long ?ldr ?wideColorGamut ?orien ?uimode ?night ?touch ?keyb/?/? ?nav/? winConfig={ mBounds=Rect(0, 0 - 0, 0) mAppBounds=null mWindowingMode=undefined mActivityType=undefined} mkbd/? desktop/?showBtnShape = -1  themeSeq=0 0 0  ?dc}\n      dexBoundsPolicy:\n       mLastNonFullBoundsDisplayId=-1\n      * Hist #0: ActivityRecord{ad01979 u0 com.sec.android.app.launcher/.activities.LauncherActivity t18}\n          packageName=com.sec.android.app.launcher processName=com.sec.android.app.launcher\n          launchedFromUid=0 launchedFromPackage=null userId=0\n          app=ProcessRecord{95a823d0 5418:com.sec.android.app.launcher/u0a96}\n          Intent { act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10800100 cmp=com.sec.android.app.launcher/.activities.LauncherActivity }\n          frontOfTask=true task=TaskRecord{13181bb #18 I=com.sec.android.app.launcher/com.android.launcher3.infra.activity.Launcher U=0 StackId=0 sz=1}\n          taskAffinity=null\n          realActivity=com.sec.android.app.launcher/com.android.launcher3.infra.activity.Launcher\n          baseDir=/system/priv-app/TouchWizHome_2017/TouchWizHome_2017.apk\n          dataDir=/data/user/0/com.sec.android.app.launcher\n          stateNotNeeded=true componentSpecified=false mActivityType=home\n          compat={480dpi} labelRes=0x7f090042 icon=0x7f020127 theme=0x7f0e019c\n          mLastReportedConfigurations:\n           mGlobalConfig={0.9 ?mcc?mnc [zh_CN_#Hans] ldltr sw360dp w360dp h668dp 480dpi nrml long port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 0, 0) mAppBounds=Rect(0, 0 - 1080, 2076) mWindowingMode=fullscreen mActivityType=undefined} s.9 mkbd/h desktop/dshowBtnShape = 0  themeSeq=0 0 0  ?dc}\n           mOverrideConfig={0.9 ?mcc?mnc [zh_CN_#Hans] ldltr sw360dp w360dp h668dp 480dpi nrml long port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 1080, 2076) mAppBounds=Rect(0, 0 - 1080, 2076) mWindowingMode=fullscreen mActivityType=home} s.9 mkbd/h desktop/dshowBtnShape = 0  themeSeq=0 0 0  ?dc}\n          CurrentConfiguration={0.9 ?mcc?mnc [zh_CN_#Hans] ldltr sw360dp w360dp h668dp 480dpi nrml long port finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 1080, 2076) mAppBounds=Rect(0, 0 - 1080, 2076) mWindowingMode=fullscreen mActivityType=home} s.9 mkbd/h desktop/dshowBtnShape = 0  themeSeq=0 0 0  ?dc}\n          OverrideConfiguration={0.0 ?mcc?mnc ?localeList ?layoutDir ?swdp ?wdp ?hdp ?density ?lsize ?long ?ldr ?wideColorGamut ?orien ?uimode ?night ?touch ?keyb/?/? ?nav/? winConfig={ mBounds=Rect(0, 0 - 0, 0) mAppBounds=null mWindowingMode=undefined mActivityType=home} mkbd/? desktop/?showBtnShape = -1  themeSeq=0 0 0  ?dc}\n          taskDescription: label=\"null\" icon=null iconResource=0 iconFilename=null primaryColor=ff0074d4\n           backgroundColor=fffafafa\n           statusBarColor=0\n           navigationBarColor=0\n          launchFailed=false launchCount=0 lastLaunchTime=-1h51m21s986ms\n          haveState=true icicle=Bundle[mParcelledData.dataSize=14056]\n          state=STOPPED stopped=true delayedResume=false finishing=false\n          keysPaused=false inHistory=true visible=false sleeping=false idle=true mStartingWindowState=STARTING_WINDOW_NOT_SHOWN\n          fullscreen=true noDisplay=false immersive=false launchMode=2\n          frozenBeforeDestroy=false forceNewConfig=false\n          mActivityType=home\n          vrActivityType=0\n          waitingVisible=false nowVisible=false lastVisibleTime=-1m33s752ms\n          connections=[ConnectionRecord{108b50e u0 CR com.samsung.android.app.spage/.service.overlay.PageOverlayService:@e38ef09}]\n          resizeMode=RESIZE_MODE_RESIZEABLE\n          mLastReportedMultiWindowMode=false mLastReportedPictureInPictureMode=false\n          mUseDeviceDefaultTheme=true\n\n    Running activities (most recent first):\n      TaskRecord{13181bb #18 I=com.sec.android.app.launcher/com.android.launcher3.infra.activity.Launcher U=0 StackId=0 sz=1}\n        Run #0: ActivityRecord{ad01979 u0 com.sec.android.app.launcher/.activities.LauncherActivity t18}\n\n    mLastPausedActivity: ActivityRecord{ad01979 u0 com.sec.android.app.launcher/.activities.LauncherActivity t18}\n\n  ResumedActivity: ActivityRecord{907f0e u0 com.oynix.launch.mode.sample/.AActivity t25}\n  mFocusedStack=ActivityStack{9f0e91 stackId=7 type=standard mode=fullscreen visible=true translucent=false, 1 tasks} mLastFocusedStack=ActivityStack{9f0e91 stackId=7 type=standard mode=fullscreen visible=true translucent=false, 1 tasks}\n  mCurTaskIdForUser={0=25}\n  mUserStackInFront={}\n  displayId=0 stacks=2\n   mHomeStack=ActivityStack{364f85f stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks}\n   mDefaultMinSizeOfResizeableTask=660\n  isHomeRecentsComponent=true  mDefaultMinSizeOfResizeableTask=660  KeyguardController:\n    mKeyguardShowing=false\n    mAodShowing=false\n    mKeyguardGoingAway=true\n    mOccluded=false\n    mDismissingKeyguardActivity=null\n    mDismissalRequested=false\n    mVisibilityTransactionDepth=0\n    mDexOccluded=false\n    mDexDisplaySleepToken=null\n  LockTaskController\n    mLockTaskModeState=NONE\n    mLockTaskModeTasks=\n    mLockTaskPackages (userId:packages)=\n      u0:[]\n```\n</details>\n\n### 几个概念\n在此之前，做一些准备工作，有几个名词需要先解释。\n- Process 进程\n如果没有特殊的配置，启动一个`application`就会启动一个进程，进程名称默认为包名。进程之间相互独立，内存互不共享。一个进程内可以有多个线程，这些线程的内存是共享的，所以一个变量可以同时被多个线程访问，从而导致的线程不安全问题。\n在`AndroidManifest.xml`文件中声明四大组件时，如果设置了`android:process`属性，这个就不会运行在`applicaton`的所在的进程，而是另起一个新的进程。进程的名字就是`android:process`属性的值。\n\n- Task 任务\n可以简单的把Task理解成一个存放Activity的栈，一个Activity必须依附于一个Task，启动Activity就是将Activity实例压入栈顶，销毁Activity就是将Activity实例出栈的过程。Activity虽然依附于Task，但并不是随便一个Task就可以，每个Task都有一个`name`，Activity就是根据这个名字找到自己的归宿。意思就是说，会同时存在多个Task，从上面`dumpsys`的结果也可以看出这一点，其中的`TaskRecord`便是一个Task实例。Task的名字是可以重复的，这与其中包含的Activity的模式有关，下面再说。\n\n- android:taskAffinity\n这是`AndroidManifest.xml`文件中，`activity`标签的一个属性，字符串类型。`affinity`，直译过来就是密切关系、类同的意思，在这里就是指定Task的名字。`application`也有这个属性，当`activity`不设置这个属性时，默认会使用`application`这个属性的值；如果`application`也没有设置这个属性的值，那就默认使用包名。所以，不设置这个属性时，activity启动后都会依附在一个名字为包名的Task中，从`dumpsys`结果也可以看出来。\n\n\n### 模式：standard\n这个是默认的模式，不主动设置的Activity，都是这个模式。这个模式很好理解，只要设置成这个模式，它从生到死都会存在包名为名称的Task中，即便是设置了`taskAffinify`也不会生效。每次启动，都会创建新的实例压入Task的栈顶。\n\n### 模式：singleTop\n从名字来看，就是单独的顶部。意思就是，在Task栈顶只会有一个实例。启动时，如果发现栈顶就是这个activity的实例，那么就会通过重用这个实例，这个时候会掉用Activity中的`onNewIntent`方法。这个模式也对`taskAffinify`属性无效，只会存在于包名的Task中。常用于内容详情，如新闻详情，单独占一个页面，浏览完详情，底部会显示几个其他新闻的链接，点击之后，会再次启动新闻详情，自己跳自己，这样不管跳转了多少次，按一次返回，就可以回到新闻列表页面。\n\n### 模式：singleTask\n如果上面解释的几个概念都能明白，那这个属性就很好说了。顾名思义，在Task中只会存在一个实例。这个模式下，`taskAnffinity`属性会生效，如果不设置，那就是包名。启动Activity时，首先会按照`taskAnffinity`查找对应的Task，如果没找到，那么就新建一个，然后将Activity实例压入栈；如果找到了该名字的Task，那么会在该Task中查找Activity的实例，若找到，如果不在Task栈顶，那么就将上面的Activity实例全部出栈，使其位于栈顶；如果栈中无此Activity的实例，则新建实例并压入栈。\n\n### 模式：singleInstance\n这个也很好理解，凡是以这个模式启动的Activity，都会自己独占一个Task。如果不存在则创建新Task然后实例压入栈，如果存在则`onNewIntent`复用其中的Activity实例。如果不设置`taskAffinity`，那么Task的名字就是包名，这时，就会有两个名字都是包名的Task，所以Task的名字是可能会相同的。这里强调一下独占这个词，如果一个以`singleTask`启动的Activity，找到了它目标名字的Task，但是这个Task里包含`singleInstance`启动的Activity实例，那么它会将实例压入该栈吗？不会的，因为是独占，所以不允许其他实例。\n\n### 总结\n其中3个都很好理解，`standard`是默认模式，只要启动就会创建新实例并压入默认Task；`singleTop`是栈顶存在就复用，不存在就创建；`singleInstance`是独占一个Task；`singleTask`是先找到目标名字、且没有被独占的Task，找不到则新建，Task中若存在实例则通过弹出上面的实例使其处于栈顶并`onNewIntent`复用，已在栈顶则直接复用，若Task栈中不存在实例，则创建并压入栈。\n\n如果能自己把每个模式验证，那么理解的就会深刻些。我便是跑了一个Application，写了几个简单的Activity，通过不断调整`AndroidManifest.xml`中Activity的`launchMode`和`taskAnffinity`，然后配合`adb shell dumpsys activity activities`命令，从头到尾走了一遍。\n\n附上Git地址：[https://github.com/oynix/launch-mode-sample](https://github.com/oynix/launch-mode-sample)\n","tags":["Android"],"categories":["Android"]},{"title":"Kotlin之let、apply、also、with","url":"/2021/08/517bb194f5b9/","content":"\n自从前两年的I/O大会上，Google官方宣布Kotlin-first后，越来越多的Android由Kotlin转向了Kotlin。而使用Kotlin常常要碰上标题中的这几个函数，它们之间有着相似的地方，但也有各自的不同。放在一起，横向对比，便于记忆，在此做个记录。\n\n<!--more-->\n\n### 分类\n这几个函数均来自kotlin-stdlib库中的Standard.kt文件，同样在这个文件中还有另外几个函数，一块说一说。\n\n按照类型可以分为两类，一类是顶层函数，一类是扩展函数。\n\n这几个函数的参数中，基本都有一个代码块参数block，`T.() -> R`表示block的参数是T.this，`(T) -> R`表示block的参数是T，也就是it。\n\n### 顶层函数有：\n```kotlin\npublic inline fun TODO(): Nothing \n\npublic inline fun TODO(reason: String): Nothing \n\npublic inline fun repeat(times: Int, action: (Int) -> Unit) \n\npublic inline fun <R> run(block: () -> R): R \n\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R \n```\n其中，`TODO`是用来标记尚未实现的空方法，`repeat`用来重复执行传入的action，这两个就不多说了，我们来对比一下`with`和`run`\n\n|名称|block参数|返回值|\n|-|-|-|\n|run|无|block()|\n|with|T.this|block()|\n\n### 扩展函数有：\n```kotlin\npublic inline fun <T, R> T.run(block: T.() -> R): R \n\npublic inline fun <T> T.apply(block: T.() -> Unit): T \n\npublic inline fun <T, R> T.let(block: (T) -> R): R\n\npublic inline fun <T> T.also(block: (T) -> Unit): T\n\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T?\n\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T?\n```\n其中，`takeIf`表示传入的predicate为true时，返回T，false返回null，而`takeUnless`恰恰相反，false时返回T，true时返回null。\n\n然后，我们来一块看一下剩下的4个函数。其实根据block的传入参数，和返回值的对比，区别就很清晰了。\n传入参数有两种：T.this 和 T\n返回值有两种：T 和 block()\n两种传入参数和两种返回值，两两组合，就有了这4个函数\n\n|名称|block参数|返回值|\n|-|-|-|\n|run|T.this|block()|\n|apply|T.this|T|\n|let|T|block()|\n|also|T|T|\n\n通过表格对比，就更加清晰了\n\n### 应用\n从传入参数来看，传T.this和T是类似的，传入T.this时，调用T的方法通过this.调用；传入T时，调用T的方法通过it.调用。\n如果你不关心扩展函数的返回值，那么随便你用哪个，本质上的区别并不大。\n如果关心扩展函数的返回值，当需要修改T中的一些成员的时候，考虑使用`apply`和`also`；当需要通过T来得到一个结果的时候，考虑使用`run`和`let`。\n\n### 总结\n这些个函数，都是Kotlin为了方便开发者写代码而设计的，如果你一个都不用，这完全没有问题。如果要用的话，就要清楚它们之间的区别和联系。\n\n","tags":["Kotlin"],"categories":["Kotlin"]},{"title":"Room的使用","url":"/2021/08/6960a7d25570/","content":"Room是一个数据库，基于SQLite的抽象层，也可以直接使用SQLite，但强烈建议使用Room。\n\n官方文档：[Android Room](https://developer.android.com/training/data-storage/room)\n\n<!--more-->\n\n### 导入依赖\n```groovy\ndependencies {\n    // ..... 其他依赖 .....\n\n    // Room\n    def room_version = \"2.3.0\"\n\n    implementation \"androidx.room:room-runtime:$room_version\"\n    annotationProcessor \"androidx.room:room-compiler:$room_version\"\n\n    // To use Kotlin annotation processing tool (kapt)\n    kapt \"androidx.room:room-compiler:$room_version\"\n}\n```\n\n### 创建表。\nRoom里的表，需要用@Entry注解标注，这里用个简单的学生表\n```kotlin\n// table_name就是表的名字，indecies是可选项，用来生成表的索引\n@Entity(tableName = \"student\", indices = [Index(value = [\"num\"], unique = true)])\ndata class Student(\n    @PrimaryKey val id: Int,\n    val num: Int,\n    val name: String,\n    val age: Int\n)\n```\n\n### 创建数据表访问类。\n这里我们只需要声明接口，并加以@Dao注解标注，具体实现交给Room来做，\n```kotlin\n// 这里只定义CRUD，增删改查，也可根据需要定义其他接口，如查询分数大于某个数值的所有学生\n@Dao\ninterface StudentDao {\n    @Insert\n    fun insert(student: Student): Long\n\n    @Delete\n    fun delete(student: Student): Int\n\n    @Update\n    fun update(student: Student): Int\n\n    @Query(\"SELECT * FROM student WHERE num = :num\")\n    fun query(num: Int): Student?\n}\n```\n\n### 表有了，访问方式也有了，下面创建数据库。\n```kotlin\n// 继承自RoomDatabase，其中已经实现了绝大数功能，我们只需要额外声明几个接口，用来提供Dao数据类\n// 方法的具体实现交给Room来做\n@Database(entities = [Student::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun studentDao(): StudentDao\n}\n```\n\n### 万事俱备，现在可以用了。在Activity里调用下试试看\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // 通过Room提供的Builder创建数据库的实例\n        // 第一个参数是个context，第二个参数是数据库的Class，第三个参数是数据库文件的名字\n        val db = Room.databaseBuilder(this, AppDatabase::class.java, \"app.db\").build()\n\n        // 获得一个Dao\n        val dao = db.studentDao()\n\n        // 添加一条记录\n        dao.insert(Student(1, 1, \"john\", 98))\n    }\n```\n\n### 添加完成，运行一下。\n然后你会发现，崩溃了。。。日志如下：\n```shell\njava.lang.RuntimeException: Unable to start activity ComponentInfo{com.oynix.room.sample/com.oynix.room.sample.MainActivity}: java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.\n```\n这句话的意思是说，不能在main thread，也就是主线程访问数据库，因为这样有可能会把页面卡住一段很长的时间。这样的检测机制算是合理的，毕竟这属于IO操作，而IO操作都应该放到单独的线程去跑。\n但是也可以去掉这种检测，在创建数据库的时候额外传入个配置：\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val db = Room.databaseBuilder(this, AppDatabase::class.java, \"app.db\")\n            .allowMainThreadQueries() // 允许在主线程操作\n            .build()\n        val dao = db.studentDao()\n        dao.insert(Student(1, 1, \"john\", 98))\n    }\n```\n这个时候再运行一下，就会发现顺利执行\n\n### 数据库文件\n这个时候，在Android Studio的Device File Explorer中，可以在data/data/{包名}/database目录下发现3个文件，app.db、app.db-shm和app.db-wal，其中.db是数据库文件，另外两个是临时文件。\n把这三个文件导出到电脑桌面，然后用能打开db文件的软件将app.db打开，如SQLite Professional、SQLite Studio等，会看到我们创建的student表，以及表中刚刚插入的那条数据。\n\n### 增加一张表\n这个时候，业务发生调整，我们需要增加一张教师表，如下\n```kotlin\n@Entity(tableName = \"teacher\", indices = [Index(value = [\"num\"], unique = true)])\ndata class Teacher(\n    @PrimaryKey val id: Int,\n    val num: Int, // 教师编号\n    val name: String,\n    val course: String\n)\n\n@Dao\ninterface TeacherDao {\n    @Insert\n    fun insert(teacher: Teacher): Long\n\n    @Delete\n    fun delete(teacher: Teacher): Int\n\n    @Update\n    fun update(teacher: Teacher): Int\n\n    @Query(\"SELECT * FROM teacher WHERE num = :num\")\n    fun query(num: Int): Teacher?\n}\n```\n同时，也要修改数据库类，增加新的教师表实体\n```kotlin\n\n@Database(entities = [Student::class, Teacher::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun studentDao(): StudentDao\n    abstract fun teacherDao(): TeacherDao\n}\n```\n增加一条教师的记录。张老师，他很厉害，会教数学\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val db = Room.databaseBuilder(this, AppDatabase::class.java, \"app.db\")\n            .allowMainThreadQueries()\n            .build()\n        // John，学号：1\n        val dao = db.studentDao()\n        dao.insert(Student(1, 1, \"John\", 14))\n        \n        // 张老师，教数学\n        val teacherDao = db.teacherDao()\n        teacherDao.insert(Teacher(1, 1001, \"Miss Zhang\", \"Math\"))\n    }\n```\n再一运行，发现又报错了。。。\n```shell\njava.lang.RuntimeException: Unable to start activity ComponentInfo{com.oynix.room.sample/com.oynix.room.sample.MainActivity}: java.lang.IllegalStateException: Room cannot verify the data integrity. Looks like you've changed schema but forgot to update the version number. You can simply fix this by increasing the version number.\n```\n这句话的意思是说，数据库的schema，也就是结构发生了改变，但是版本号没有更新，Room不知道怎么处理这些schema的修改，然后就报了个错。\n\n### 数据库升级\n就像刚刚那样，在版本的迭代更新中，常常会有修改数据库结构的情况。在Room中，数据库是通过version号，来管理数据库版本的，每做一次修改，version都要增加，一般增加1，你每次加2也没人能拿你怎么样。我们在创建数据库的同时，还要告诉Room版本更新做了哪些操作，这些需要通过addMigrations来添加。\n只修改schema，而不增加version，程序会崩溃。\n只增加version，而不提供Migration，程序会删除并重建数据库\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val db = Room.databaseBuilder(this, AppDatabase::class.java, \"app.db\")\n            .allowMainThreadQueries()\n            .addMigrations(object : Migration(1, 2){\n                override fun migrate(database: SupportSQLiteDatabase) {\n                    database.execSQL(\"CREATE TABLE IF NOT EXISTS `teacher` (`id` INTEGER NOT NULL, `num` INTEGER NOT NULL, `name` TEXT NOT NULL, `course` TEXT NOT NULL, PRIMARY KEY(`id`))\")\n                    database.execSQL(\"CREATE UNIQUE INDEX IF NOT EXISTS `index_teacher_num` ON `teacher` (`num`)\")\n                }\n            })\n            .build()\n        // 这里要注掉，因为表里已经有了一个id为1的记录了\n        // val dao = db.studentDao()\n        // dao.insert(Student(1, 1, \"John\", 14))\n\n        val teacherDao = db.teacherDao()\n        teacherDao.insert(Teacher(1, 1001, \"Miss Zhang\", \"Math\"))\n    }\n```\n如上，从1到2后，我们新加了一个teacher表，并在表上加了一个索引，那么这么写就可以了。\n如果说，不想写这么长的SQL语句怎么办？也好办，全局搜AppDatabase_Impl.java文件，这里面就是Room已经写好的。\n再次运行，发现没有再崩溃，打开app.db，里面多了一张表，表里有一条刚加的张老师的记录。\n\n### addMigrations\n这里要单独说一说这个方法，程序运行后，如果本地数据库版本和代码里的版本不一致，这个时候这个方法才会派上用场，如果一致则无用。\n先帖下文档里的说明：\n```kotlin\n/**\nAdds a migration to the builder.\nEach Migration has a start and end versions and Room runs these migrations to bring the database to the latest version.\nIf a migration item is missing between current version and the latest version, Room will clear the database and recreate so even if you have no changes between 2 versions, you should still provide a Migration object to the builder.\nA migration can handle more than 1 version (e.g. if you have a faster path to choose when going version 3 to 5 without going to version 4). If Room opens a database at version 3 and latest version is >= 5, Room will use the migration object that can migrate from 3 to 5 instead of 3 to 4 and 4 to 5.\nParams:\nmigrations – The migration object that can modify the database and to the necessary changes.\nReturns:\nThis RoomDatabase.Builder instance.\n*/\n@NonNull\npublic Builder<T> addMigrations(@NonNull Migration... migrations)\n```\n它接收可变参数，即可同时接收多个Migration。每个Migration都有个startVersion，以及一个endVersion，Room将会运行这些Migration，将本地数据库的版本一步步升级到代码里的最新版本。如果缺失当前版本到最新版本的Migration，Room将会清空数据库并重建。所以，即便在两个版本之间没有变化，仍然需要提供一个Migration给builder。\n一个Migration可以处理多个版本，例如，当前是版本3，最新是版本5，你提供了3到4的Migration、4到5的Migration以及3到5的Migration，那么Room就会选择更快的Migration，即3到5，而不是由3到4再到5。\n\n### 数据加密\n虽然Android高版本在数据安全这一块已经提升了很多，未root的手机基本看不到其他应用独立存储空间里的内容，但为了以防万一，可以进一步将数据库文件，也就是app.db，进行加密。\n当前有很多种实现思路，如每次写之前，将数据加密，读之后，将数据解密，等。\n这里介绍个第三方加密库，使用很方便，当然也有缺点，就是包体会变大，因为用到了native库，增大6M左右\n- 引入依赖\n```groovy\n // room cypher maven\nmaven { url \"https://s3.amazonaws.com/repo.commonsware.com\" }\n\n// room cypher\nimplementation \"com.commonsware.cwac:saferoom.x:1.2.1\"\n```\n- 增加Factory，openHeloperFactory，\n```kotlin\n override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        val db = Room.databaseBuilder(this, AppDatabase::class.java, \"app.db\")\n            .allowMainThreadQueries()\n            .openHelperFactory(SafeHelperFactory(\"your_database_password\".toCharArray()))\n            .addMigrations(object : Migration(1, 2){\n                override fun migrate(database: SupportSQLiteDatabase) {\n                    database.execSQL(\"CREATE TABLE IF NOT EXISTS `teacher` (`id` INTEGER NOT NULL, `num` INTEGER NOT NULL, `name` TEXT NOT NULL, `course` TEXT NOT NULL, PRIMARY KEY(`id`))\")\n                    database.execSQL(\"CREATE UNIQUE INDEX IF NOT EXISTS `index_teacher_num` ON `teacher` (`num`)\")\n                }\n            })\n            .build()\n//        val dao = db.studentDao()\n//        dao.insert(Student(1, 1, \"John\", 14))\n\n//        val teacherDao = db.teacherDao()\n//        teacherDao.insert(Teacher(1, 1001, \"Miss Zhang\", \"Math\"))\n    }\n```\n- 加密之后，再导出来的app.db就无法打开了\n\n### 总结\n以上，Room的简单使用就这些了，相比于SQLite，简单、方便了不少，本地化数据可以多考虑使用。\n另外还有些更高级的用法，比如和ViewModel的结合、和Hilt的结合、异步操作数据流，等等，这里就就不做说明了。\n\n附上Github地址：[https://github.com/oynix/RoomSample](https://github.com/oynix/RoomSample)","tags":["Android","Kotlin","Room"],"categories":["Android"]},{"title":"管理 MacOS 上的 Python 环境版本","url":"/2021/06/d54bb8006555/","content":"\n### 00.前言\nMacOS 上的 Python不同版本的环境一直是个让人头大的问题，原因在于，系统预先安装了2.7版本，但这是个老版本了，老版本是不能卸载的，一些系统程序都在依赖它。\n\n现在市面上开发的新程序多数在用3.x版本，部分老代码还在用2.x版本，两个大版本还是有些区别的，无法完全兼容，这就让管理多版本共存成了个问题。\n\n当然，也有一些管理工具，如pyenv，但其实python的venv模块已经足够了，下面会简单说一说使用。\n<!--more--> \n### 01.卸载干净\n据不完全统计，目前发现了以下这些还算固定的安装目录：\n\n- 自己安装的Python在这个目录，即通过官网下载的安装程序安装\n/Library/Frameworks/Python.framework\n\n- Python应用目录\n/Applications/Python3.x\n\n- 通过brew命令安装在这个目录，brew是个包管理工具，使用它安装的都在Cellar目录\n/usr/local/Cellar\n\n- 通过CommandLineTools安装在这个目录，这是个Xcode带的工具包\n/Libaray/Developer/CommandLineTools/Library/Frameworks\n\n- 系统预安装的在这个目录，这个看看就行了，不能删\n/System/Library/Frameworks/Python.framework\n\n```sh\n$ which python\n$ which python3\n```\n\n通过这两个命令，找到python可执行程序\n- /usr/local/bin，这个目录下的，可以删除\n- /usr/bin，这个目录下的，想删也删不了，没权限。Catalina以下的通过关闭SIP可以操作/usr/bin目录下的文件，但以上的版本关掉SIP也不行了。我在早年间通过这种方式在/usr/bin目录下放了一个python3的可执行程序，现在升级到了Big Sur版本，导致这个可执行文件删不掉了，除了重装系统，我也没想到什么好办法，暂时就先这么放着。\n\n终端窗口执行python会进入2.7的交互解释环境，执行python3会报错command not found\n```sh\n$ python3\n-bash: python3: command not found\n\n$ which python\n/usr/bin/python\n\n$ python\nWARNING: Python 2.7 is not recommended. \nThis version is included in macOS for compatibility with legacy software. \n```\n\n至此，现在系统里应该只剩下系统预安装的python2.7了，可执行文件在/usr/bin目录，同时/usr/local/bin目录不再有python可执行文件。\n\n### 02.安装最新\n直接用brew安装就好，别再用其他的各路神仙工具了，听我一句劝，不要在意别人怎么怂恿，就用brew就可以了，这个是macOS上最普遍、最通用的包管理工具，用最简单的方式做最大的事，多了不起。\n\n如果不是新买的机器，应该都装了brew工具了，要是没装，那就先装一下，一行代码，等着就好了\n```sh\n$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n如果发现访问困难，卡住、网速慢，可以使用国内镜像网站，下面这个是中科大的，速度还可以\n```sh\n$ ruby -e \"$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)\"\n```\n\n然后，安装python3，一行代码，还是等着就好了，python3有多个版本，3.6、3.7、3.8以及最新的3.9，不指定版本会默认安装最新，如果有需要，可以指定版本：python@3.x，如果同时存在多个3.x，要注意名字的区分\n```sh\n$ brew install python3\n```\n\n这里唠叨几句pip，pip是python的包管理工具，前身是easy_install，这两者的关系是，python是可执行文件，pip是python的一个模块，可有也可无，非必需，建议还是用pip，毕竟其他方式管理包很麻烦。如果意外把pip删除了也可以单独安装\n\n```sh\n# 安装\n$ python3 -m ensurepip\n$ python3 -m pip install pip --upgrade\n# 目标位置\n$ which pip\n/usr/local/bin/pip\n# 卸载\n$ python3 -m pip uninstall pip\n\n# 默认会安装这个三个，再安装用pip install {package}即可\n$ pip list -v\npip          21.1.2    /usr/local/lib/python3.9/site-packages     pip\nsetuptools   57.0.0    /usr/local/lib/python3.9/site-packages     pip\nwheel        0.36.2    /usr/local/lib/python3.9/site-packages     pip\n```\n\n一个pip关联一个python可执行文件，像上面这样，就是将pip关联到了python3，通过这个pip安装的包只有python3可调用到，系统自带的python调用不到，如果有需要，也可以为系统python可执行文件也装个pip工具，但要注意名字的区分\n\n```sh\n# 安装\n$ python -m ensurepip\n# python是系统自带的，但没有操作系统目录的权限，所以需要加上--user\n$ python -m pip install pip --upgrade --user\n# --user后会安装到当前用户目录库下，我的在这\n$ cd /Users/{username}/Library/Python/2.7/bin\n# 然后在pip同样的位置创建一个软连接就可以了\n$ ln -s /Users/{username}/Library/Python/2.7/bin/pip /usr/local/bin/pip2\n# 目标位置\n$ which pip2\n/usr/local/bin\n\n# 卸载\npython -m pip uninstall\n\n# 这个就比较多了，而且都在系统目录里，咱也操作不了\n# 再安装要加--user，这样会安装到当前用户目录库文件下: pip2 install {package} --user\n# /Users/{username}/Library/Python/2.7/lib/python/site-packages\n$ pip2 list -v\naltgraph   0.10.2  /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python\nasn1crypto 0.24.0  /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python\nbdist-mpkg 0.5.0   /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python\nbonjour-py 0.3     /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python\n```\n\n### 03.日常使用\n日常使用是通过venv模块，一般一个项目使用一个venv环境，互相独立、互不干扰。\n\n这种模式，就像是在一座大房子（机器）里可以建造很多不同类型（版本）的小房间（虚拟环境），每个小房间（虚拟环境）里的操作的影响范围只限于在这个房间（虚拟环境）内，各个房间（虚拟环境）互相独立互不影响，房间（虚拟环境）可以随时创建（新建）和拆除（删除）。\n\n```sh\n# 切换到项目的根目录下\n$ cd PyProj\n\n# 创建一个venv环境，第二个参数venvDir是环境目录的名称，一般使用venv，可随意，合法即可\n$ python3 -m venv venvDir\n\n# 查看虚拟环境，可看到如下内容\n$ ls -l venvDir\ndrwxr-xr-x  12 username  staff  384 Jun  8 23:44 bin\ndrwxr-xr-x   2 username  staff   64 Jun  8 23:44 include\ndrwxr-xr-x   3 username  staff   96 Jun  8 23:44 lib\n-rw-r--r--   1 username  staff   90 Jun  8 23:44 pyvenv.cfg\n\n# 激活当前venv环境，之后每行前面会多个(venvDir)，表示在该环境中\n$ source venvDir/bin/activate\n\n# 查看python可执行文件位置，此时在虚拟环境中，只有一个python，所以不要再输入python3\n(venvDir)$ which python\nPyPorj/venvDir/bin/python\n\n# 查看pip\n(venvDir)$ which pip\nPyPorj/venvDir/bin/pip\n\n# 此时的python可执行程序和pip可执行程序只在当前环境内有效，若要退出当前环境则执行\n(venvDir)$ deactivate\n```\n\n注意，如果在IDE（如PyCharm）的Terminal里执行创建venv的命令，可能会报权限的错，使用系统的终端便可正常使用。\n\n### 04.附录\n- 查看pip版本\n```sh\n$ pip -V\n```\n\n- 用pip安装package时，加上--user参数，会安装到当前用户的库目录中，只对当前用户有效，不加--user会安装到全局目录，对所有用户有效。如果你的电脑只有一个用户，那么二者没有区别\n```sh\n$ pip install --user\n～/Library/Python/3.9/lib/python/site-packages/\n\n$ pip install\n/usr/local/lib/python3.9/site-packages/\n```\n\n- brew安装目录\n/usr/local/Cellar\nHomebrew配置目录\n/usr/lcoal/etc\nHomebrew命令目录\n/usr/local/bin\n\n- brew常用命令\nbrew install FORMULA\nbrew cleanup\nbew searh FORMULA\nbrew info FORMULA\nbrew upgrade FORMULA\nbrew update","tags":["Python","MacOS"],"categories":["Python"]},{"title":"CircleImageView","url":"/2020/02/c0c9e38ff81e/","content":"\nAndroid 系统默认的 ImageView 是矩形，但有时页面上需要展示圆形的图片，如头像。这里提供一种最简单的实现思路。\n\n<!--more-->\n将圆形遮罩当作目标（DST），图片当作源（SRC）\n先画的是destination，后画的是source\n\n```java\npublic class CircleImageView extends AppCompatImageView {\n\n    private Paint mPaint;\n    private Xfermode mXfermodeDstOut;\n    private Path mPath;\n\n    public CircleImageView(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n    private void init() {\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.FILTER_BITMAP_FLAG);\n        mPaint.setStyle(Paint.Style.FILL);\n        mXfermodeDstOut = new PorterDuffXfermode(PorterDuff.Mode.DST_OUT);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        if (mPath == null) {\n            int w = getWidth();\n            int h = getHeight();\n            int cx = w / 2;\n            int cy = h / 2;\n            mPath = new Path();\n            mPath.moveTo(0, 0);\n            mPath.lineTo(w, 0);\n            mPath.lineTo(w, h);\n            mPath.lineTo(0, h);\n            mPath.addCircle(cx, cy, Math.min(cx, cy), Path.Direction.CCW);\n        }\n        canvas.saveLayer(0, 0, getWidth(), getHeight(), mPaint, Canvas.ALL_SAVE_FLAG);\n        super.onDraw(canvas);\n        mPaint.setXfermode(mXfermodeDstOut);\n        canvas.drawPath(mPath, mPaint);\n        mPaint.setXfermode(null);\n        canvas.restore();\n    }\n}\n```\n[源文件](https://github.com/oynix/widgetlib/blob/master/widget/src/main/java/com/oynix/widget/CircleImageView.java)","tags":["Android","Widget","CircleImageView"],"categories":["Android"]},{"title":"Paint常用方法说明","url":"/2020/02/bcaaeeb315b6/","content":"\n# Paint常用方法说明\n\n[原文地址](https://blog.csdn.net/aigestudio/article/details/41316141)，写的很详细并且有趣。这里只挑出一些常用的，难于理解的，单独拿出来做个笔记。\n\n<!--more-->\n\n## setAntiAlias(boolean aa)\n\n设置抗锯齿。也可以在 new 的时候传入 Paint.ANTI_ALIAS_FLAG。\n\n## setColorFilter(ColorFilter filter)\n\n类 ColorFilter 没有具体实现，它有三个子类：\n\n### ColorMatricColorFilter\n\n矩阵颜色过滤器，在 Android 中图片是以 RGBA 像素点的形式加载到内存中的，修改这些橡塑信息需要一个 ColorMatrix 类的支持，其定义了一个 4x5 的 float[] 类型的矩阵：\n\n```java\nColorMatrix colorMatric = new ColorMatrix(new float[]{\n  1, 0, 0, 0, 0,// R\n  0, 1, 0, 0, 0,// G\n  0, 0, 1, 0, 0,// B\n  0, 0, 0, 1, 0,// A\n});\n```\n\n其中，第一行表示 R(红色) 的向量，第二行表示 G(红色) 的向量，第三行表示 B(蓝色) 的向量，最后一行表示 A(透明度) 的向量，这一顺序是固定的，不可改变。每一行的前 4 个值表示的是 RGBA 的值，其范围在 0.0F 至 2.0F 之间，1 为保持原图的 RGB 的值。每一行的第 5 个表示偏移值，想让颜色更倾向于某个颜色时，就增加该颜色的偏移值。\n\n> 何为偏移值？顾名思义当我们想让颜色更倾向于红色的时候就增大R向量中的偏移值，想让颜色更倾向于蓝色的时候就增大B向量中的偏移值，这是最最朴素的理解，但是事实上色彩偏移的概念是基于白平衡来理解的，什么是白平衡呢？说得简单点就是白色是什么颜色！如果大家是个单反爱好者或者会些PS就会很容易理解这个概念，在单反的设置参数中有个色彩偏移，其定义的就是白平衡的色彩偏移值，就是当你去拍一张照片的时候白色是什么颜色的，在正常情况下白色是（255, 255, 255, 255）但是现实世界中我们是无法找到这样的纯白物体的，所以在我们用单反拍照之前就会拿一个我们认为是白色的物体让相机记录这个物体的颜色作为白色，然后拍摄时整张照片的颜色都会依据这个定义的白色来偏移！而这个我们定义的“白色”（比如：255, 253, 251, 247）和纯白（255, 255, 255, 255）之间的偏移值（0, 2, 4, 8）我们称之为白平衡的色彩偏移。\n\nColorMetrix 类里面提供一些实在的方法，如 setSaturation(float sat) 设置饱和度。\n\n### LighingColorFilter\n\n光照颜色过滤，该类只有一个构造方法：\n\n```java\nLightingColorFilter(int mul, int add)\n```\n\n其中 mul 的全称是 colorMultiply 意为色彩倍增，add 全称是 colorAdd 意为色彩增加，这两个值都是 16 进制的色彩值 0xAARRGGBB。\n\n### PorterDuffColorFilter\n\n同 LightingColorFilter 一样，只有一个构造方法：\n\n```java\nPorterDuffColorFilter(int color, PorterDuff.Mode mode)\n```\n\n接受两个值，一个是 16 进制的颜色值，另一个是 PorterDuff 内部类 Mode 中的常量值，表示混合模式。Mode 不仅仅应用于色彩混合，还应用于图形混合，如果在 PorterDuffColorFilter 中强行设置图形混合的模式，将不会看到任何对应的效果。\n\n## setXfermode(Xfermode xfermode)\n\nXfermode，可以直接理解为图像混合模式，它没有具体实现，但有 3 个子类，这 3 个子类实现的功能比 setColorFilter 的 3 个子类复杂\n\n### AvoidXfermode\n\n这个 API 因为不支持硬件加速所以在 API 16 已经过时了，如果想在高于 16 的机器上使用，必须关闭硬件加速，可以在 [HardwareAccelerate](https://developer.android.com/guide/topics/graphics/hardware-accel.html) 文档中查看如何关闭硬件加速，以及查看更多不支持硬件加速的 API。\n\nAvoidXfermode 只有一个含参的构造方法：\n\n```java\nAvoidXfermode(int opColor, int tolerance, AvoidXfermode.Mode mode)\n```\n\n具体实现和 ColorFilter 一样都被封装在 C/C++ 内，我们只管调用就好。第一个参数 opColor 表示一个 16 进制的可以带透明通道的颜色值，第二个参数 tolerance 表示容差值，可以理解为一个标识「精确」或「模糊」的东西，最后一个参数 AvoidXfermode 表示具体模式，可选值只有两个：AvoidXfermode.Mode.AVOID 或 AvoidXfermode.Mode.TARGET\n\n#### AvoidXfermode.Mode.TARGET\n\n在该模式下 Android 会判断画布上的颜色是否有跟 opColor 一样的颜色，比如 opColor 是红色，TARGET 模式下就会判断画布上是否有存在红色的地方，如果有则把该区域「染」上一层画笔定义的颜色，否则不「染」色，而 tolerance 容差值则表示画布上的像素和 opColor 之间的差别是多少的时候才去「染」，比如当前画布有一个像素的色值是(200, 20, 13)，而 opColore 是 (255, 0, 0)，当 tolerance 容差值为 255 时，即便(200, 20, 13)并不等于 opColor 也会被染色，容差值越大「染」色范围越广。\n\n#### AvoidXfermode.Mode.AVOID\n\n与 TARGET 恰恰相反，TARGET 是与 opColor 与画布颜色一样，而 AVOID 是 opColor 与 画布颜色不一样，其他的都类似。\n\n### PixelXorXfermode\n\n与 AvoidXfermode 一样也在 API 16 过时了，该类也提供了一个含参的构造方法\n\n```java\nPixelXorXfermode(int opColor)\n```\n\n该类的计算实现很简单，从官方给出的计算公式来看就是：op^src^dst，像素色值按位异或运算\n\n### PorterDuffXfermode\n\nXfermode的最后一个子类也是唯一一个没有过时切沿用至今的子类。该类同样只有一个构造方法：\n\n```\nPorterDuffXfermode(PorterDuff.Mode mode)\n```\n\n其中的 PorterDuff.Mode 和上面讲的 ColorFilter 用到的 PorterDuff.Mode 是一样的。PorterDuffXfermode 就是图形混合模式的意思，其概念最早来自 SIGGRAPH 的 Tomas Porter 和 Tom Duff，名字就是这两个人的名字的组合\n\n![](https://i.loli.net/2021/07/19/ALKqGnE3UshgClQ.jpg)\n\n这张图片从一定程度上形象地说明了图形混合的作用，两个图形一圆一方通过一定的计算产生不同的组合效果，在 API 中 Android 提供了 18 种（比上图多了两种 ADD 和 OVERPLAY）模式：\n\n![](https://i.loli.net/2021/07/19/3kGpPcMVwu7XaxL.jpg)\n\nSa 全称 Source Alpha，Sc 全称 Source Color，Da 全称 Destination Alpha，Dc 全称 Destination Color。每个中括号由两个值组成：[Alpha, Color]。\n\nSource 为源图像，意为将要绘制的图像；Destination 为目标图像，意为将源图像绘制到的图像。简单理解，先绘制的是 dst，后绘制的是 src。\n\n#### 总结\n\nOVER：谁在上谁在下的问题\n\nIN：绘制相交部分，SRC_IN绘制SRC，DST_IN绘制DST\n\nOUT：绘制不相交部分，SRC_OUT绘制SRC，DST_OUT绘制DST\n\nATOP：SRC_ATOP只绘制SRC中相交部分，DST_ATOP只绘制DST中相交部分\n\n## setDither(boolean dither)\n\n设置绘制图像时的抗抖动，也称为递色\n\n放大来看，其在很多相邻像素之间插入了一个中间值，使颜色过渡变得些许柔和\n\n## setMaskFilter(MaskFilter maskFilter)\n\nMaskFilter 类中没有任何实现方法，它有两个子类 BlurMaskFilter 和 EmbossMaskFilter，前者为模糊遮罩滤镜，而后者为浮雕遮罩滤镜，不支持硬件加速\n\n### BlurMaskFilter\n\n只有一个含参的都早方法\n\n```java\nBlurMaskFilter(float radisu, BlurMaskFilter.Blur style)\n```\n\n其中 radius 表示阴影半径，值越大越扩散。第二个参数 style 表示模糊类型，有四种选择：SOLD 效果是在图像的 Alpha 边界产生一层与 Paint 颜色一致的阴影效果而不影响图像本身；NORMAL 会将整个图像模糊掉；OUTER 会在 Alpha 边界外产生一层阴影且会将原本的图像变得透明；INNER 则会在图像内部产生模糊，很少用\n\n如上所说 BlurMaskFilter 是根据 Alpha 通道的边界来计算模糊的，如果是一张图片（注：Android 会把复制到资源目录的图片转为 RGB565）你会发现没有任何效果，那么如何给图片加一个类似阴影的效果呢？其实很简单，可以尝试从 Bitmap 中获取其 Alpha 通道，并在绘制 Bitmap 前先以该 Alpha 通道绘制一个模糊就可以了\n\n```java\npublic class BlurMaskFilterView extends View {\n\tprivate Paint shadowPaint;// 画笔\n\tprivate Context mContext;// 上下文环境引用\n\tprivate Bitmap srcBitmap, shadowBitmap;// 位图和阴影位图\n \n\tprivate int x, y;// 位图绘制时左上角的起点坐标\n \n\tpublic BlurMaskFilterView(Context context) {\n\t\tthis(context, null);\n\t}\n \n\tpublic BlurMaskFilterView(Context context, AttributeSet attrs) {\n\t\tsuper(context, attrs);\n\t\tmContext = context;\n\t\t// 记得设置模式为SOFTWARE\n\t\tsetLayerType(LAYER_TYPE_SOFTWARE, null);\n \n\t\t// 初始化画笔\n\t\tinitPaint();\n \n\t\t// 初始化资源\n\t\tinitRes(context);\n\t}\n \n\t/**\n\t * 初始化画笔\n\t */\n\tprivate void initPaint() {\n\t\t// 实例化画笔\n\t\tshadowPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);\n\t\tshadowPaint.setColor(Color.DKGRAY);\n\t\tshadowPaint.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.NORMAL));\n\t}\n \n\t/**\n\t * 初始化资源\n\t */\n\tprivate void initRes(Context context) {\n\t\t// 获取位图\n\t\tsrcBitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.a);\n \n\t\t// 获取位图的Alpha通道图\n\t\tshadowBitmap = srcBitmap.extractAlpha();\n \n\t\t/*\n\t\t * 计算位图绘制时左上角的坐标使其位于屏幕中心\n\t\t */\n\t\tx = MeasureUtil.getScreenSize((Activity) mContext)[0] / 2 - srcBitmap.getWidth() / 2;\n\t\ty = MeasureUtil.getScreenSize((Activity) mContext)[1] / 2 - srcBitmap.getHeight() / 2;\n\t}\n \n\t@Override\n\tprotected void onDraw(Canvas canvas) {\n\t\tsuper.onDraw(canvas);\n\t\t// 先绘制阴影\n\t\tcanvas.drawBitmap(shadowBitmap, x, y, shadowPaint);\n \n\t\t// 再绘制位图\n\t\tcanvas.drawBitmap(srcBitmap, x, y, null);\n\t}\n}\n```\n\n## setPathEffect(PathEffect effect)\n\nPathEffect 很明显就是路径效果的意思，其一共有六个子类，效果如下\n\n![](https://i.loli.net/2021/07/19/MUrCkB97ZFY8Hya.jpg)\n\n从上到下：未设置PathEffect，CornerPathEffect，DiscretePathEffect，DashPathEffect，PathDashPathEffect，ComposePathEffect，SumPathEffect\n\n## setStrokeCap(Paint.Cap cap)\n\n设置画笔笔触风格，ROUND，SQUARE 和 BUTT\n\n##setStrokeJoin(Paint.Join join)\n\n设置结合处的形态\n\n## setShadowLayer(float radius, float dx, float dy, int shadowColor)\n\n为绘制的图形添加一个阴影层效果，不支持硬件加速\n\n## setShader(Shader shader)\n\n着色器，有五个子类\n\n### BitmapShader\n\n只有一个含参的构造方法，其他 4 个子类都有两个\n\n```java\nBitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY)\n```\n\nShader.TileMode 有三种：CLAMP 拉伸，MIRROR 镜像和 REPEAT 重复\n\n### LinearGradient\n\n线性渐变\n\n```java\nLinearGradient(float x0, float y0, float x1, float y1, int color0, int color1, Shader.TileMode tile)\n```\n\n(x0, y0) 渐变的起点，(x1, y1) 渐变的终点，color0 起点颜色，color1 终点颜色\n\n```java\nLinearGradient(float x0, float y0, float x1, float y1, int[] colors, float[] positions, Shader.TileMode tile)\n```\n\ncolors 表示支持多个颜色，positons 表示各个颜色的分界位置，如 {Color.RED, Color.GREEN, Color.BLUE}，{0, 0.3F, 0.8F}，positions 为null 时均分渐变区域\n\n### SweepGradient\n\n梯度渐变，也称扫描式渐变，累死雷达扫描效果\n\n```java\nSweepGradient(float cx, float cy, int color0, int color1)\n\nSweepGradient(float cx, float cy, int[] colors, float[] positons)\n```\n\n同 LinearGradient\n\n### RadialGradient\n\n径向渐变，从圆心中心向四周渐变的效果，构造方法就先写一个，同上\n\n```java\nRadialGradient(float cx, float cy, float radius, int centerColor, int edgeColor, Shader.TileMode tile);\n```\n\n### ComposeShader\n\n组合 Shader\n\n```java\nComposeShasdr(Shader s0, Shader s1, Xfermode mode);\nComposeShader(Shader s0, Shader s1, PorterDuff.Mode mode)\n```\n\n## Metrix\n\n3 x 3 坐标矩阵，初始值:\n\n```java\nnew float[]{\n  1, 0, 0, // x\n  0, 1, 0, // y\n  0, 0, 1, // 1\n}\n```\n\n第一列表示 x 轴方向缩放，第二列表示 y 轴方向缩放，第三列表示偏移\n\n### setTranslate scale\n### preTranslate scale\n### postTranslate scale\n常应用于中心缩放\n```java\nmatrix.setScale(interpolatedTime, interpolatedTime);\nmatrix.preTranslate(-centerX, -centerY);\nmatrix.postTranslate(centerX, centerY);\n```\n","tags":["Android","Paint"],"categories":["Android"]},{"title":"Flask API 单元测试 unittest，mock && patch","url":"/2019/12/97c306187ae6/","content":"\n单元测试，主要是为了测试某个方法，或是某个代码快，对于各种输入的处理，输出是否符合预期。但由于其他库、或模块的依赖，以至于很难独立测试我们自己实现的逻辑代码。\n\n对此，引出 mock。\n<!--more--> \n## 一、Flask\n**Flask**是个轻量 API 框架，使用起来非常容易上手\n```python\n# 安装：pip install flask\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Hello Flask'\n\napp.run(port=5000)\n```\n这样，一个简单的 server 就跑起来了，访问 **http:localhost:5000** 便可以看到返回的数据：**Hello Flask**\n\n下面举例说明，如果对单一的接口写测试用例\n\n## 二、举例：用户登录\n1. 用户登录是个常见的功能接口，接口逻辑之外的部分基本同上，这里省略不写。用户使用 **name** 和 **password** 进行登陆操作，服务器收到请求后，根据 **name** 从数据库查询 **password** ，一致则返回 **200 OK**，不一致返回 **400 Bad Request**，很简单的实现，如下：\n\t```python\n\tfrom flask import request\n\tfrom app.model import UserDB\n\t\n\t@app.route('/login')\n\tdef login():\n\t    name = request.args.get('name')\n\t    if not name:\n\t        return 'name is required', 400\n\t   \n\t    password = request.args.get('password')\n\t    if not password:\n\t        return 'password is required', 400\n\t  \n\t    # 从数据库获取用户数据\n\t    user = UserDB.get_user(name)\n\t    if user.get('password') == password:\n\t        return 'OK', 200\n\t    else:\n\t        return 'password is wrong', 400\n\t```\n    其中 **UserDB** 为数据模块中，从数据库查询用户数据的类。这里对于**登录逻辑**的单元测试，只指测试该部分最小的代码块，对于代码块中引入的依赖，在测试时都认为是正常的。例如，在测试 **login()** 的时候，我们认为 **UserDB** 是正常的、可用的，至于 **UserDB** 的可靠性，需要 **UserDB** 模块的单元测试来保障。\n    对于待测试模块内引入的依赖，采用 **mock** 的方式模拟。\n2. **Flask** 的单元测试，先看代码\n\t```python\n\timport unittest\n\tfrom unittest.mock import Mock\n\tfrom unittest.mock import patch\n\t# 该app为创建的Flask实例\n\tfrom application import app\n\t\n\tfrom app.model import UserDB\n\t\n\tclass LoginTestCase(unittest.TestCase):\n\t  \n\t    def setUp(self):\n\t        # push一个上下文，便可以使用flask中的全局变量，如g\n\t        app.app_context().push()\n\t        app.testing = True\n\t        # 测试用的http client\n\t        self.client = app.test_client()\n\t    \n\t    def test_login_success(self):\n\t        # 真实请求中的url，host和port可省略\n\t        url = '/login?name=flask&password=flaskpassword'\n\t        # 模拟的方法名称，也可直接写字符串： get_user\n\t        func_name = UserDB.get_user.__name__\n\t        # 模拟的方法，不管请求参数是什么，都会返回return_value的值（Mock还有其他用法）\n\t        mock_func = Mock(return_value={'name': 'flask', 'password': 'flaskpassword'})\n\t        # patch意为，当UserDB的get_user方法被调用时，用mock出来的func来处理\n\t        # 而mock的func，不管请求参数，都会返回return_value\n\t        # 故而，只要UserDB的get_user被调用，都会返回{'name': 'flask', 'password': 'flaskpassword'}\n\t        # with，表示这种处理方式的作用范围\n\t        # 当在with的范围之外时，调用UserDB的get_user不受mock影响，会正常调用\n\t        with patch.object(UserDB, func_name, func):\n\t            # response为返回的响应\n\t            response = self.client.get(url)\n\t            # 因为传入的name和password，和UserDB的mock func返回的name和password相同\n\t            # 所以，该请求会返回200\n\t            # assertEqual意为，认定返回码与200相等，若不等则该用例不通过\n\t            self.assertEqual(response.status_code, 200)\n\t       \n\t    def test_login_failed(self):\n\t        # 测试传入错误密码的情况\n\t        url = '/login?name=flask&password=wrongpassword'\n\t        func_name = UserDB.get_user.__name__\n\t        mock_func = Mock(return_value={'name': 'flask', 'password': 'flaskpassword'})\n\t        with patch.object(UserDB, func_name, func):\n\t            response = self.client.get(url)\n\t            # 因为传入密码错误，所以在此我们认定返回码是400\n\t            self.assertEqual(response.status_code, 400)\n\t```\n\n此外，还可以对测试缺少参数，这里不再赘述。这样，便可对接口的各种情况进行测试了。\n","tags":["Flask","Python"],"categories":["Flask"]},{"title":"React - Webpack 项目脚手架搭建","url":"/2019/11/05d3ed0e9549/","content":"\n> 把手还是伸向了前端，抽空折腾了几天，算是理清了起步门槛。\n<!--more--> \n##### 一、首先确保安装了 npm，如果没装....那就想办法装上\n```sh\n$ npm\nUsage: npm <command>\n\nwhere <command> is one of:\n    access, adduser, bin, bugs, c, cache, completion, config,\n    ddp, dedupe, deprecate, dist-tag, docs, doctor, edit,\n    explore, get, help, help-search, i, init, install,\n    install-test, it, link, list, ln, login, logout, ls,\n    outdated, owner, pack, ping, prefix, profile, prune,\n    publish, rb, rebuild, repo, restart, root, run, run-script,\n    s, se, search, set, shrinkwrap, star, stars, start, stop, t,\n    team, test, token, tst, un, uninstall, unpublish, unstar,\n    up, update, v, version, view, whoami\n\nnpm <command> -h     quick help on <command>\nnpm -l           display full usage info\nnpm help <term>  search for help on <term>\nnpm help npm     involved overview\n\nSpecify configs in the ini-formatted file:\n    /Users/xiaoyu/.npmrc\nor on the command line via: npm <command> --key value\nConfig info can be viewed via: npm help config\n\nnpm@5.6.0 /usr/local/lib/node_modules/npm\n```\n##### 二、安装 create-react-app。如果用 WebStorm，可以跳过这一步。\n> IDE 可以选择创建 React App，省去了手动执行，所以创建后的目录内容是一样的。\n```sh\n// -g : global\n$ npm install create-react-app -g\n/usr/local/bin/create-react-app -> /usr/local/lib/node_modules/create-react-app/index.js\n+ create-react-app@3.2.0\nadded 91 packages in 24.685s\n\n$ create-react-app\nPlease specify the project directory:\n  create-react-app <project-directory>\n\nFor example:\n  create-react-app my-react-app\n\nRun create-react-app --help to see all options.\n```\n如介绍所言，创建一个app，名字任意，合法即可\n```sh\n$ create-react-app my-react-app\n```\n项目结构如下：\n```sh\n$ ls my-react-app\nREADME.md\t\t    package-lock.json\tpublic\nnode_modules\t\tpackage.json\t\tsrc\n```\n- README.md : 你懂的\n- node_moudles : 依赖都在找个目录下\n- package.json : npm的配置文件，或者说是项目的配置文件\n- package-lock.json : 锁定版本号\n- public : 存放静态资源\n- src :  代码／资源\n\n#### 三、安装 webpack 全家桶\n> npm install 参数说明：package.json 有几个依赖节点，`dependencies` 、 `devDependencies` 和 `optionalDependencies`，前者会随着项目发布出去；后者顾名思义，只在开发时使用；后后者为可选阶段\n>  - - - - - - - \n> -S， --save ：依赖添加到 `dependencies` 节点，\n> -D，--save-dev ：依赖添加到 `devDependencies` 节点\n> -O，--save-optional ：依赖添加到  `optionalDependencies` 节点\n\n以下命令，在项目根目录下执行\n```sh\n// 也可以放在一行执行\n$ npm install webpack -D\n$ npm install webpack-cli -D\n$ npm install webpack-dev-server -D\n```\n**注意，这里有个坑：这三个依赖的版本号一定要相互匹配，如果你要指定版本，一定要确认指定的版本号是行不通的，不然就会报错。都用最新版，目前一切正常。**\n\n#### 四、配置 webpack server\n鉴于 webpack 可用于本地 server，也可用于打包，各自使用不同的配置文件。在项目根目录创建个文件夹 `wepack`，用于存放 webpack 配置文件。\n1. webpack/webpack.config.js，用于开发 server\n```js\nconst path = require('path');\nconst webpack = require('webpack');\nconst __repo = path.dirname(__dirname);\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: { // 程序唯一入口\n        'index': path.resolve(__repo, 'src/index.jsx'),\n    },\n    mode: 'development',\n    output: { // 打包文件输出位置\n        path: path.resolve(__repo, \"build\"),\n        filename: \"bundle.js\",\n        publicPath: \"/\"\n    },\n    devServer: {\n        contentBase: [path.join(__repo, 'public'),], // 本地服务器索价在的页面所在目录\n        compress: false,\n        port: 7788, // server 使用端口\n        disableHostCheck: true,\n        inline: true, // 实时刷新\n        historyApiFallback: true, // 不跳转\n        hot: true\n    },\n    module: {\n        rules: [\n            {\n                test: /(\\.jsx|\\.js)$/, // 匹配所护理文件的扩展名正则表达式\n                exclude: /(node_modules|bower_components)/, // 手动添加／屏蔽的文件\n                use: {\n                    loader: 'babel-loader', // loader名称\n                }\n            },\n            {\n                test: /\\.(css|styl)$/,\n                use: [\n                    {\n                        loader: 'style-loader'\n                    },\n                    {\n                        loader: 'css-loader'\n                    }\n                 ]\n            },\n            {\n                test: /\\.html$/,\n                use: [\n                    {loader: 'html-loader'}\n                ]\n            },\n            {\n                test: /\\.(gif|jpg|png|svg|ttf|eot|woff|woff2)$/,\n                use : {\n                    loader: 'file-loader?name=fonts/[name].[ext]'\n                }\n            },\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            filename: 'index.html',\n            template: 'public/index.html'\n        })\n    ]\n};\n```\n其中的 `module`，就是 webpack 的 loader，都是用来打包用的：\n- **babel-loader**：打包jsx、js文件，转化成浏览器认识的格式，因该loader配置选项较多，一般单抽取出独立的文件`.bebelrc`，放在项目根目录，webpack可以自动识别到\n- **css-loader**，**style-loader**：打包css、style文件\n- **html-loader**：打包html文件\n- **file-loader**：打包其他格式文件，如配置中所写\n\n**.babelrc 内容如下：**\n```json\n{\n  \"presets\": [\"@babel/preset-react\", \"@babel/preset-env\"], // 支持的编码\n  \"plugins\": [\n    \"@babel/plugin-transform-runtime\"\n  ]\n}\n```\n其中，所有的loader、plugin，都需要手动安装\n```shell\n$ npm install -D babel-core babel-loader css-loader style-loader html-loader file-loader\n\n$ npm install -D @babel/preset-env @babel/preset-react @babel/plugin-transform-runtime html-webpack-plugin\n```\n2. 配置 package.json，使用webpack/webpack.config.js。修改 package.json 中的`scripts` 节点，如下：\n```json\n\"dev\": \"webpack-dev-server --config webpack/webpack.config.js\"\n```\n此时，在项目根目录下执行该命令，即可。\n\n```sh\n$ npm run dev\n```\n\n#### 五、配置 webpack 打包配置\n和 server 类似，这里直接贴上配置文件\n1. **webpack/webpack.config.build.js**\n\n```js\nconst path = require('path');\nconst webpack = require('webpack');\nconst __repo = path.dirname(__dirname);\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    mode: \"production\",\n    entry: path.resolve(__repo, 'src/index.jsx'),\n    devtool: \"#source-map\",\n    output: {\n        path: path.resolve(__repo, \"dist\"),\n        filename: \"app/[name].bundle.js\",\n        publicPath: \"/\"\n    },\n    module: {\n        rules: [\n            {\n                test: /(\\.jsx|\\.js)$/, // 匹配所护理文件的扩展名正则表达式\n                exclude: /(node_modules|bower_components)/, // 手动添加／屏蔽的文件\n                use: {\n                    loader: 'babel-loader', // loader名称\n                }\n            },\n            {\n                test: /\\.(css|styl)$/,\n                use: [\n                    {\n                        loader: 'style-loader'\n                    },\n                    {\n                        loader: 'css-loader'\n                    }\n                ]\n            },\n            {\n                test: /\\.html$/,\n                use: [\n                    {loader: 'html-loader'}\n                ]\n            },\n            {\n                test: /\\.(gif|jpg|png|svg|ttf|eot|woff|woff2)$/,\n                use : {\n                    loader: 'file-loader?name=fonts/[name].[ext]'\n                }\n            },\n        ]\n    },\n\n    plugins: [\n        new HtmlWebpackPlugin({\n            filename: 'index.html',\n            template: 'public/index.html'\n        })\n    ]\n};\n```\n2. 修改`package.json`中的scripts节点，如下\n\n```json\n\"build\": \"webpack --config webpack/webpack.config.build.js\"\n```\n执行打包命令后，所有文件会输出到项目根目录下的`dist`中。\n```sh\n$ npm run build\n```\n打包后的文件，配合`nginx`就可以访问请求了。\n","tags":["React","Webpack"],"categories":["React"]},{"title":"RHEL(Red Hat Enterprise Linux) 安装 zip、unzip","url":"/2019/11/4ae565dbddd3/","content":"\n> 多数的系统镜像文件中都是包含这两个命令，但总有意外。\n<!--more--> \n- 一般方法\n```sh\n$ sudo yum install zip unzip\n```\n- 如果一般方法报错，这个是安装unzip\n```sh\n$ sudo rpm -ivh https://rpmfind.net/linux/mageia/distrib/cauldron/x86_64/media/core/release/unzip-6.1c-6.mga8.x86_64.rpm\n```\n\n##### 其他版本的系统，链接从这里找 -> [点一下呗](https://rpmfind.net/linux/rpm2html/search.php?query=unzip)\n","tags":["Linux"],"categories":["Linux"]},{"title":"yum 安装最新版本 mysql","url":"/2019/11/fda8ed989b0e/","content":"---\n\n#### 一. 先到官网查询最新的版本，[官网地址](https://dev.mysql.com/downloads/repo/yum/)\n注意选择自己Linux对应的版本，查询方式：\n<!--more--> \n```shell\n$ cat /etc/*-release\nNAME=\"Red Hat Enterprise Linux Server\"\nVERSION=\"7.7 (Maipo)\"\n......\n\n$ uname -m\nx86_64\n```\n根据以上信息，选择所需版本的 rpm 名称，如图\n![](https://i.loli.net/2021/07/07/JsqNMBWZcmKpEXu.png)\n#### 二. 安装、启动\n1. 下载 rpm 文件。可以在网页上点 Download，然后在传送到服务器，也可以直接在服务器上下载，如下，替换链接后面部分即可：\n\t```sh\n\t$ wget http://repo.mysql.com/mysql80-community-release-el7-3.noarch.rpm\n\t```\n2. 导入 yum repo。\n\t```sh\n\t$ sudo rpm -ivh mysql80-community-release-el7-3.noarch.rpm\n\t```\n3. 安装\n\t```sh\n\t$ sudo yum install mysql-server\n\t```\n4. 启动\n\t```sh\n\t$ sudo systemctl start mysqld.service\n\t```\n\n#### 三. 连接、密码\n1. 连接\n\t```sh\n\t$ mysql -u root -p\n\t```\n2. 如果需要密码，去 `/var/log/mysqld.log`里面找，格式类似如下，`5Vgr6>Go.Azi`即是\n\t```sh\n\t2019-11-25T08:46:57.138469Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 5Vgr6>Go.Azi\n\t```\n3. 登陆成功之后，如果提示用`ALTER USER`修改密码，如下\n\t```sh\n\tmysql> alter user 'root'@'localhost' identified by 'new_password';\n\t```\n4. 如果提示密码不合格，查看一下当前密码要求，如下，length表示密码最小长度，mixed_case_count表示大小写字母混合数量，number_count表示数字数量，special_char_count表示特殊字符数量\n\t```sh\n\tmysql> show variables like 'validate_password%';\n\t+--------------------------------------+--------+\n\t| Variable_name                        | Value  |\n\t+--------------------------------------+--------+\n\t| validate_password.check_user_name    | ON     |\n\t| validate_password.dictionary_file    |        |\n\t| validate_password.length             | 6      |\n\t| validate_password.mixed_case_count   | 1      |\n\t| validate_password.number_count       | 1      |\n\t| validate_password.policy             | MEDIUM |\n\t| validate_password.special_char_count | 0      |\n\t+--------------------------------------+--------+\n\t7 rows in set (0.00 sec)\n\t```\n5. 如果想设置个简单好记的密码，修改一下密码检查，exit退出mysql，再连接登陆后生效\n\t```sh\n\tmysql> set global validate_password.mixed_case_count=0;\n\tmysql> set global validate_password.special_char_count=0;\n\t```","tags":["Linux","mysql","yum"],"categories":["Linux"]},{"title":"nginx路由匹配","url":"/2019/11/6e1530768100/","content":"\n几种匹配模式，今天涉及到了，在此记录。\n<!--more--> \n1. =\n精确匹配\n2. ^~\n精确前缀匹配\n3. ~\n正则匹配（大小写敏感）\n4. ~*\n正则匹配（大小写不敏感）\n5. /uri\n普通前缀匹配\n6. /\n通用匹配\n","tags":["nginx"],"categories":["nginx"]},{"title":"nginx 转发错误 13 permission denied","url":"/2019/11/5e5a9e36111c/","content":"---\n\n今天在做 nginx 转发的时候，总是权限的错误：\n<!--more-->\n```shell\n2019/11/23 14:22:28 [crit] 19986#19986: *1 connect() to 127.0.0.1:5050 failed (13: Permission denied) while connecting\n```\n\n从网上翻了翻，大多数文章都在说修改 nginx 用户，而且这些文章的内容还都是一样的，这让着急解决问题的我很恼火....不知道是一个人写完在各个地方发了一遍，还是别的什么，我没无聊到查这些... -_-#\n\n修改 nginx 配置文件，`/etc/nginx/nginx.conf`，改成 root\n```shell\nuser root\n```\n\n然后用 root 权限 restart nginx 服务\n```shell\n$ sudo systemctl restart nginx\n```\n\n一般到这就结束了，但是却还没解决我的问题，权限问题依然在。又在网上一番找，原来是 linux 给拦截了，暂时关掉就可以了 [链接](https://www.cnblogs.com/songxingzhu/p/10063043.html)\n```sh\n$ setenforce 0                  ##设置SELinux 成为permissive模式\n```\n","tags":["nginx"],"categories":["nginx"]},{"title":"ELK 单机部署，多 beat 节点","url":"/2019/11/c712d783ad18/","content":"\n[参考文章](https://www.cnblogs.com/sparkdev/p/10554076.html)\n\n适用场景：多个项目或服务，独立部署，各个服务有自己的 log 文件。为便于查看、过滤等，可单机部署 ELK 服务后，各个服务通过 filebeat 服务将 log 发送至 ELK 机器。\n<!--more--> \n![](https://i.loli.net/2021/07/07/rNvnGcQ4SyhpZlf.png)\n\n#### 一、安装 java\n```sh\n$ sudo yum install java\n\n$ java -version\nopenjdk version \"11.0.5\" 2019-10-15 LTS\nOpenJDK Runtime Environment Corretto-11.0.5.10.1 (build 11.0.5+10-LTS)\nOpenJDK 64-Bit Server VM Corretto-11.0.5.10.1 (build 11.0.5+10-LTS, mixed mode)\n```\n\n> 对于 elasticsearch、logstash 和 kibana，**Elastic.co** 都提供了多种环境的安装方式，这里只介绍通过 RPM 的方式，其他环境可参考[官网文档](https://www.elastic.co/guide/index.html)。\n#### 二、安装 elasticsearch \n1. 下载安装公钥。\n\t```sh\n$ rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch\n\t```\n2. 增加 yum 源。在 `/etc/yum.repos.d/` 创建文件 `elasticsearch.repo` 并写入以下内容:\n\t```sh\n[elasticsearch-7.x]\nname=Elasticsearch repository for 7.x packages\nbaseurl=https://artifacts.elastic.co/packages/7.x/yum\ngpgcheck=1\ngpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch\nenabled=1\nautorefresh=1\ntype=rpm-md\n\t```\n3. 安装、启动\n    ```sh\n$ sudo yum install elasticsearch\n\n$ sudo systemctl daemon-reload\n\n$ sudo systemctl enable elasticsearch.service\n Created symlink from /etc/systemd/system/multi-user.target.wants/elasticsearch.service to /usr/lib/systemd/system/elasticsearch.service.\n\n$ sudo systemctl start elasticsearch.service\n\n$ sudo systemctl | grep elasticsearch\n elasticsearch.service   loaded active running   Elasticsearch\n    ```\n    **注意**：elasticsearch 基于 java，默认占用的最小内存是 1G，如果机器内存不够启动时会报错 `Not enough space`，将 `/etc/elasticsearch/jvm.options` 中的 `-Xms` 和 `-Xmx` 改小后重试即可。\n\n\n#### 三、安装 logstash\n1. 下载安装公钥。如果上面执行过，可跳过。\n\t```sh\n$ rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch\n\t```\n2. 增加 yum 源。在 `/etc/yum.repos.d/` 创建文件 `logstash.repo` 并写入以下内容:\n\t```sh\n[logstash-7.x]\nname=Elastic repository for 7.x packages\nbaseurl=https://artifacts.elastic.co/packages/7.x/yum\ngpgcheck=1\ngpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch\nenabled=1\nautorefresh=1\ntype=rpm-md\n\t```\n3. 安装\n\t```sh\n$ sudo yum install logstash\n\t\n$ sudo systemctl daemon-reload\n\t\n$ sudo systemctl enable logstash.service\n Created symlink from /etc/systemd/system/multi-user.target.wants/logstash.service to /etc/systemd/system/logstash.service.\n\t```\n4. 配置。在 `/etc/logstash/conf.d/` 创建文件 `beat2es.conf`，并写入以下内容：\n\t```js\ninput {\n    beats{\n        port => 5044\n        ssl => false\n    }\n}\nfilter {\n    grok {\n        match => { \"message\" => \"%{TIMESTAMP_ISO8601:[@metadata][timestamp]} %{DATA:message\" }\n        overwrite => [ \"message\" ]\n    }\n    date {\n        match => [ \"[@metadata][timestamp]\" , \"yyyy-MM-dd HH:mm:ss,SSS\" ]\n    }\n}\noutput {\n    elasticsearch {\n        hosts => [\"localhost:9200\"]\n        index => \"%{[fields][appname]}-%{+YYYY.MM.dd}\"\n        sniffing => true\n    }\n}\n\t```\n5. 启动\n\t```sh\n$ sudo systemctl start logstash\n\t```\n\n#### 四、安装 kibana\n1. 下载安装公钥。如果上面执行过，可跳过。\n\t```sh\n$ rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch\n\t```\n2. 增加 yum 源。在 `/etc/yum.repos.d/` 创建文件 `kibana.repo` 并写入以下内容:\n\t```sh\n[kibana-7.x]\nname=Kibana repository for 7.x packages\nbaseurl=https://artifacts.elastic.co/packages/7.x/yum\ngpgcheck=1\ngpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch\nenabled=1\nautorefresh=1\ntype=rpm-md\n\t```\n3. 安装、启动\n\t```sh\n$ sudo yum install kibana\n\n$ sudo systemctl daemon-reload\n\n$ sudo systemctl enable kibana.service\nCreated symlink from /etc/systemd/system/multi-user.target.wants/kibana.service to /etc/systemd/system/kibana.service.\n\t\n$ sudo systemctl start kibana.service\n\t```\n\n###### 至此，ELK 服务已经部署完成。logstash 监听 5044 端口，所有发送到 5044 端口的内容都会传送至 elasticsearch，可通过 kibana 可视化搜索页面进行查询。\n###### kibana 默认部署在 locaohost:5601，为了增加安全性，需通过 nginx 为 kibana 设置用户登陆访问。\n###### 如果不需要安全性，可修改 `/etc/kibana/kibana.yml` 文件，将其中的 `server.host` 的值改为 `0.0.0.0` 后重启 kibana 服务，这样外网可直接通过该机器的 5601 端口访问 kibana 服务。\n\n#### 五、设置 kibana 登陆访问\n1. 添加 nginx 源\n\t```sh\n$ sudo rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm\n\t```\n2. 安装 nginx\n\t```sh\n$ sudo yum install nginx\n\t```\n3. 配置 nginx。修改 `/etc/nginx/conf.d/default.conf` 中 `/` 路由的配置，如下：\n\t```sh\nlocation / {\n     auth_basic \"secret\";\n     auth_basic_user_file /etc/nginx/db/passwd.db;\n     proxy_pass http://localhost:5601;\n     proxy_set_header Host $host:5601;\n     proxy_set_header X-Real-IP $remote_addr;\n     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n     proxy_set_header Via \"nginx\";\n  }\n\t```\n4. 安装 httpd\n\t```sh\n$ sudo yum install httpd\n\t```\n5. 设置用户。用户名：jack，密码：123456\n\t```sh\n$ sudo htpasswd -bc /etc/nginx/pwd.db jack 123456\n\t```\n6. 启动 nginx\n\t```sh\n$ sudo systemctl nginx.service\n\t```\n\n###### 至此，访问该机器的 80 端口，通过用户密码验证，即可访问到 kibana 服务。\n\n#### 六、安装 filebeat\n> filebeat 服务可安装在任何有 log 文件的机器上，其实时监听 log 文件，并将内容发送至 logstash 服务。\n1. 下载 rpm 文件，并安装\n\t```sh\n$ curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.4.2-x86_64.rpm\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100 22.7M  100 22.7M    0     0  24.8M      0 --:--:-- --:--:-- --:--:-- 24.8M\n\n$ sudo rpm -vi filebeat-7.4.2-x86_64.rpm\nPreparing packages...\nfilebeat-7.4.2-1.x86_64\n\n$ filebeat version\nfilebeat version 7.4.2 (amd64), libbeat 7.4.2 [15075156388b44390301f070960fd8aeac1c9712built 2019-10-28 19:46:13 +0000 UTC]\n\t```\n2. 配置。配置文件按模块分为了几部分，如 Filebeat inputs、Filebeat modules、Outputs等，在这里只需关心两个模块，一是 Filebeat inputs，另个为 Outputs。\nFilebeat inputs 用来配置 Filebeat 服务所监听、读取的文件，以及读取时的一些选项，这里的文件，即为 log 文件。\n\n\t```\n\t   enabled: true 表示开启\n\t\n\t   paths: 指定 log 文件的路径\n\t\n\t   fields: 配置元数据，appname 为必填项，用来区分不同项目\n\t\n\t   multiline.pattern: 正则表达式\n\t\n\t   multiline.negate: 是否反向。true 表示匹配 multiline.pattern 时开始新的一行；false 表示不匹配时开始新的一行\n\t\n\t   multiline.match: 连接的位置。after 表示不匹配 multiline.pattern 时连在上一句后面；before 表示连在下一句前面\n\t\n\t   这 3 项用来设置多行识别，'^[0-9]{4}-[0-9]{2}-[0-9]{2}' 是识别，行首格式为 YYYY-MM-DD 的日期，即每当行首为该格式的日期时，如 2019-11-15，都会重新开始一行。\n\t```\n   \n   Outputs 用来配置读取到的内容，如何输出。配置里缺省的输出方向是 Elasticsearch，这里需要切换为 Logstash。Logstash 的 SSL 目前尚未开启，因此只需配置 hosts 即可。\n\n\t```\nhosts: [\"{host}:5044\"]，logstash 服务所在的主机地址\n\t```\n\n   如无特殊需求，修改下面内容中的 `paths` 和 `appname` 以及 `hosts`，替换原 filebeat.yml 文件内容，即可。\n\n\t```sh\n\t   #=========================== Filebeat inputs =============================\n\t \n\tfilebeat.inputs:\n\t \n\t- type: log\n\t  enabled: true\n\t  paths:\n\t    - /var/log/app.log\n\t  fields:\n\t    appname: {your-app-name}\n\t  multiline.pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'\n\t  multiline.negate: true\n\t  multiline.match: after\n\t \n\t#============================= Filebeat modules ===============================\n\t \n\tfilebeat.config.modules:\n\t  # Glob pattern for configuration loading\n\t  path: ${path.config}/modules.d/*.yml\n\t \n\t  # Set to true to enable config reloading\n\t  reload.enabled: false\n\t \n\t#==================== Elasticsearch template setting ==========================\n\t \n\tsetup.template.settings:\n\t  index.number_of_shards: 1\n\t  #index.codec: best_compression\n\t  #_source.enabled: false\n\t \n\t#================================ Outputs =====================================\n\t \n\t#----------------------------- Logstash output --------------------------------\n\toutput.logstash:\n\t  # The Logstash hosts\n\t  hosts: [\"{host}:5044\"]\n\t \n\t  # Optional SSL. By default is off.\n\t  # List of root certificates for HTTPS server verifications\n\t  #ssl.certificate_authorities: [\"/etc/pki/root/ca.pem\"]\n\t \n\t  # Certificate for SSL client authentication\n\t  #ssl.certificate: \"/etc/pki/client/cert.pem\"\n\t \n\t  # Client Certificate Key\n\t  #ssl.key: \"/etc/pki/client/cert.key\"\n\t \n\t#================================ Processors =====================================\n\t \n\tprocessors:\n\t  - add_host_metadata: ~\n\t  - add_cloud_metadata: ~\n\t ```\n3. 启动\n\t```sh\n\t$ sudo systemctl enable filebeat.service\n\t\n\t$ sudo systemctl start filebeat.service\n\t```","tags":["ELK","Linux"],"categories":["ELK"]},{"title":"Elastic Beanstalk (EB) 引入 CloudWatch Log 服务","url":"/2019/11/95ca4e5703e9/","content":"\n- 原因\n 现所有 EB 环境服务的 log，均以文件的形式，存储在 EB 机器本地。当机器因各种问题（包含但不限于 bug ），造成无法远程访问时，无法读取其上的 log 来定位问题。故引入 AWS 的 CloudWatch Log 服务。\n\n<!--more-->\n\n- 原理\n CloudWatch Log 是一项服务。功能是，以接近实时的速度以流的方式读取、并存储文件。\n\n- 配置\n 1. 在项目根目录下创建名为`.ebextentions`的目录；\n 2. 在`.ebextentions`中新建文件`default.config`，扩展名必须为`.config`，文件名任意，合法即可；\n 3. 写入如下内容，部署时自动执行，具体见[AWS文档](https://docs.aws.amazon.com/zh_cn/elasticbeanstalk/latest/dg/ebextensions.html)\n```yaml\npackages:\n  yum:\n    awslogs: []\n\nfiles:\n  \"/etc/awslogs/awscli.conf\" :\n    mode: \"000600\"\n    owner: root\n    group: root\n    content: |\n      [plugins]\n      cwlogs = cwlogs\n      [default]\n      region = `{\"Ref\":\"AWS::Region\"}`\n\n  \"/etc/awslogs/awslogs.conf\" :\n    mode: \"000600\"\n    owner: root\n    group: root\n    content: |\n      [general]\n      state_file = /var/lib/awslogs/agent-state\n\n  \"/etc/awslogs/config/logs.conf\" :\n    mode: \"000600\"\n    owner: root\n    group: root\n    content: |\n      [/var/log/automation/app.log]\n      log_group_name = `{\"Fn::Join\":[\"/\", [\"/aws/elasticbeanstalk\", { \"Ref\":\"AWSEBEnvironmentName\" }, \"var/log/automation/app.log\"]]}`\n      log_stream_name = {instance_id}\n      file = /var/log/automation/app.log\n\ncommands:\n  \"1_init_log_dir\":\n      cwd: /var/log/\n      command: |\n        mkdir automation\n        chmod 775 automation\n        chgrp wsgi automation\n        chown wsgi automation\n      ignoreErrors: true\n  \"2_check_awslogs\":\n    command: chkconfig awslogs on\n  \"3_reload_awslogs\":\n    command: service awslogs restart\n```\n\n- 说明\n配置文件中使用了 3 个键，**packages**、**files** 和 **commands**。具体说明可见AWS文档。\n 1. **packages**\n - 使用 yum 安装 CloudWatch Log 服务，**awslogs**。\n \n 2. **files**：写入 awslogs 的配置文件，其中前两个 **awscli.conf** 和 **awslogs.conf** 在此不需要关心，只需关注第 3 个 **logs.conf**。\n - **log_group_name:** 在 CloudWatch Log 中显示的 **group** 的名称，对应下图中红色框；\n - **log_stream_name:** 在 CloudWatch Log 中显示的 **stream** 的名称，对应下图中蓝色框；\n - **file:** 该数据流所关联的文件的绝对路径\n ![](https://i.loli.net/2021/08/02/F7rtfBhgzmG6iLW.png)\n \n 3. **commands**\n 为便于查看和管理，统一将log放到了路径 `/var/log/` 下，并每个独立程序使用一个目录，这里使用automation说明。在 2 中，参数 **file** 使用的值是 `/var/log/automation/app.log`，所以在启动前需先创建 **automation** 目录。\n  - **1_init_log_dir：** 创建目录并修改权限，EB环境中，程序的默认执行用户是 wsgi；\n  - **2_check_awslogs：** 更新 awslogs 服务；\n  - **3_reload_awslogs：** 重启 awslogs 服务。\n\n- 使用\n将配置文件 **default.config** 中 **logs.conf** 的 **log_group_name**、**log_stream_name**和**file**以及 **1_init_log_dir** 替换为对应项目信息即可，在 **CloudWatch Log** 中可根据 **group_name** 和 **stream_name** 查找 **log**。\n\n- 扩展\n如有需要，可同时创建多个流，修改 **logs.conf** 即可，格式参考如下\n```yaml\n\"/etc/awslogs/config/logs.conf\" :\n    mode: \"000600\"\n    owner: root\n    group: root\n    content: |\n      [/var/log/messages]\n      log_group_name = `{\"Fn::Join\":[\"/\", [\"/aws/elasticbeanstalk\", { \"Ref\":\"AWSEBEnvironmentName\" }, \"var/log/messages\"]]}`\n      log_stream_name = {instance_id}\n      file = /var/log/messages\n\n      [/var/log/dmesg]\n      log_group_name = `{\"Fn::Join\":[\"/\", [\"/aws/elasticbeanstalk\", { \"Ref\":\"AWSEBEnvironmentName\" }, \"var/log/dmesg\"]]}`\n      log_stream_name = {instance_id}\n      file = /var/log/dmesg\n\n      [/var/log/automation/app.log]\n      log_group_name = `{\"Fn::Join\":[\"/\", [\"/aws/elasticbeanstalk\", { \"Ref\":\"AWSEBEnvironmentName\" }, \"var/log/automation/app.log\"]]}`\n      log_stream_name = {instance_id}\n      file = /var/log/automation/app.log\n```\n","tags":["AWS","CloudWatch Log"],"categories":["AWS"]},{"title":"保持ssh远程连接不断开","url":"/2019/09/ced3db1f808e/","content":"\n通过`ssh user@server`登陆到远程服务器时，经常会遇到一个问题，\n\n```sh\nConnection closed by remote host\n```\n意思就是服务器断开了这个连接。\n<!--more--> \n##### 解决方法\n\n```sh\n// 先登录到远程服务器\n$ ssh -i ./ssh/authorization.pem {root}@{server}\n\n// 切换到root\n$ sudo su -\n\n// 修改配置文件\n# vi /etc/ssh/sshd_config\n\n// 将其中的两行\n#ClientAliveInterval 0\n#ClientAliveCountMax 3\n// 修改为\nClientAliveInterval 2\nClientAliveCountMax 3\n// :wq 保存，并退出\n\n// 重启ssh服务\n# /etc/init.d/sshd restart\nStopping sshd:                                             [  OK  ]\nStarting sshd:                                             [  OK  ]\n```\n\n断开当前ssh连接，重新登录，问题解决。","tags":["Linux","ssh"],"categories":["Linux"]},{"title":"在AWS Lambda中使用psycopg2连接Redshift","url":"/2019/09/6df5f8cca1a9/","content":"\n- 环境：MacOS 10.12.6\n\n开始说正题。\n\nRedshift是基于PostgreSQL的二次开发应用，所以，能连接PostgreSQL的工具都可以用来连接Redshift。我选择的是使用最广泛的`psycopg2`。\n<!--more--> \n如果上来就执行:\n```sh\n$ pip install psycopg2\n```\n你会看到下面的提示错误：\n\n```sh\nError: pg_config executable not found.\n    \n    pg_config is required to build psycopg2 from source.  Please add the directory\n    containing pg_config to the $PATH or specify the full executable path with the\n    option:\n    \n        python setup.py build_ext --pg-config /path/to/pg_config build ...\n    \n    or with the pg_config option in 'setup.cfg'.\n    \n    If you prefer to avoid building psycopg2 from source, please install the PyPI\n    'psycopg2-binary' package instead.\n    \n    For further information please check the 'doc/src/install.rst' file (also at\n    <http://initd.org/psycopg/docs/install.html>).\n    \n    ----------------------------------------\nERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output.\n```\n提示需要一个叫做`pg_config`的东西。`pg_config`是个编译PostgreSQL源码后得到的一个文件。所以想要通过这种方式安装`psycopg2`就需要手动去编译源码。\n\n如果懒得编译，人家已经替你想好了办法，正如提示里所言，\n\n```sh\n If you prefer to avoid building psycopg2 from source, please install the PyPI\n    'psycopg2-binary' package instead.\n```\n因此，通过下面命令安装删减版的`psycopg2`，\n\n```sh\n$ pip install psycopg2-binary\n```\n然后，在本机上就可以正常使用了。\n\n---\n\n**但是，Lambda不可以。不同于独立的机器，Lambda需要完整的依赖包才能执行。**\n\n在Github上搜到了[awslambda-psycopg2](https://github.com/jkehler/awslambda-psycopg2)，作者介绍说是专门解决在Lambda上使用`psycopg2`的。\n\n按照`README.md`的步骤，先编译PostgreSQL，再用生成的`pg_config`去编译`psycopg2`。但执行后总会报一个错误，\n\n```python\nNo module named 'psycopg2._psycopg'\n```\n看着[issue](https://github.com/jkehler/awslambda-psycopg2/issues/47)里面几个老外说来说去，也没说出个可行的解决方案。\n\n几番尝试下来，终究是填了坑。\n\n**其实是编译环境的问题，在什么环境下编译生成的依赖包，只能在该环境下使用。Lambda是在Linux机器上执行的，所以必须在Linux上进行编译，生成的依赖包才可以使用。**\n\n就是这么简单。\n\n![](https://i.loli.net/2021/07/07/IX1DjFi72OblPoG.png)\n","tags":["AWS Lambda","python"],"categories":["Python"]},{"title":"在Spark中加载Redshift数据问题汇总","url":"/2019/09/e4951d749391/","content":"\n#### 1. java.sql.SQLException: No suitable driver\n这个错误是因为，连接Redshift时需要一个driver，而程序执行时找不到能用的driver，所以报错。AWS提供了多个版本连接Redshift的driver，[**点击查看**](https://docs.aws.amazon.com/zh_cn/redshift/latest/mgmt/configure-jdbc-connection.html#download-jdbc-driver)。\n<!--more--> \n#### 2. java.lang.NoClassDefFoundError: com/amazonaws/services/kinesis/model/Record\n经过几次尝试发现，直接使用AWS提供的驱动可以连上Redshift，打印出表结构，但是不能加载数据，一加载数据会报这个奇怪的错误，表结构都可以打印出来，为什么不能加载数据呢？我想不通。几番查询，找到了一个包装库，[**github地址**](https://github.com/databricks/spark-redshift#python)。\n\n#### 3. java.lang.IllegalArgumentException: AWS Access Key ID and Secret Access Key must be specified as the username or password (respectively) of a s3n URL, or by setting the fs.s3n.awsAccessKeyId or fs.s3n.awsSecretAccessKey properties (respectively).\n按照2里面的github库里的文档说明配置好后，可能会报这个错。因为spark-redshift用到了S3，所以要配置key和secret才可以。文档里也提供了[**几种方式**](https://github.com/databricks/spark-redshift#configuration)，i、ii和iii，开始我选择的是第三种方式，直接写在了URI里面。\n\n#### 4. java.lang.NoClassDefFoundError: com/eclipsesource/json/Json\n紧接着，配置好aws的key和secret，可能会遇到这个错误。这个错误一眼看上去感觉奇怪，为什么会报json的错误呢？在[**spark-redshift的issue**](https://github.com/databricks/spark-redshift/issues/279)里面找到了遇到同样问题的人，最下面**arvindkanda**提供了解决方案，启动时提供一个额外的jar包就可以了。\n\n\n#### 5. java.sql.SQLException: [Amazon](500310) Invalid operation: S3ServiceException:The S3 bucket addressed by the query is in a different region from this cluster.\n这个问题是说，S3和EMR必须在同一个region，不然Spark是读不到Redshift的数据的。我这里用的都是us-west-2，Oregon，俄勒冈。\n\n\n#### 6. com.amazon.ws.emr.hadoop.fs.shaded.com.amazonaws.services.s3.model.AmazonS3Exception: Bad Request (Service: Amazon S3; Status Code: 400; Error Code: 400 Bad Request; \n这个问题，就比较厉害了，卡了我好几个小时。网上各种方案都在说，因为签名版本的问题，所以访问S3时，必须指定S3的endpoint，查来的都是`s3a`的，[**比如这个**](https://stackoverflow.com/questions/34209196/amazon-s3a-returns-400-bad-request-with-spark)。但是因为spark-redshift里用的是`s3n`，我就将a替换成了n，但是这个问题还是在。各种方案不断尝试，可能是运气好，莫名的就试对了一种方式：将3里面的方式替换成ii，然后再配置`sc.hadoopConfiguration.set(\"fs.s3a.endpoint\", \"s3.us-west-2.amazonaws.com\")`，就可以了。\n\n#### 最终代码如下，\n\n```java\nspark = SparkSession.builder.getOrCreate()\nspark._jsc.hadoopConfiguration().set('fs.s3n.awsAccessKeyId', aws_access_key_id)\nspark._jsc.hadoopConfiguration().set('fs.s3n.awsSecretAccessKey', aws_secret_access_key)\nspark._jsc.hadoopConfiguration().set(\"fs.s3n.endpoint\", \"s3.us-west-2.amazonaws.com\")\n\nrsdf = spark.read\\\n        .format('com.databricks.spark.redshift')\\\n        .option('url', 'jdbc:redshift://host:port/schema')\\\n        .option('dbtable', 'table_name')\\\n        .option('user', 'username')\\\n        .option('password', 'password')\\\n        .option('tempdir', 's3n://bucket/dir')\\\n        .load()\n# 打印表结构\nrsdf.printSchema()\n# 打印表内容\nrsdf.show()\n```\n\n##### 关于spark启动命令参数，[**这篇文章**](https://blog.csdn.net/u012402124/article/details/99485901)已经说明过，这里就不再赘述。","tags":["AWS","Spark","Redshift"],"categories":["Spark"]},{"title":"「AWS」入门安装aws cli","url":"/2019/08/c35313b67e87/","content":"\n> cli，即Command Line Interface，是aws服务常用的命令工具\n<!--more--> \n[AWS官网地址](https://amazonaws-china.com/cn/cli/)\n\n- 环境：Python\n\n1. 安装\n\n安装起来只需要一条命令：\n```shell\n$ pip install awscli --user\n```\n \n执行完成之后，输入`aws`，输出如下，则说明安装成功了：\n```shell\n$ aws\nusage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]\nTo see help text, you can run:\n\n  aws help\n  aws <command> help\n  aws <command> <subcommand> help\naws: error: the following arguments are required: command\n```\n\n查看支持的命令，其中的`AVAILABLE SERVICES`便是支持的命令，内容过多，只罗列了部分\n```shell\n$ aws help\nNAME\n       aws -\n\nDESCRIPTION\n       The  AWS  Command  Line  Interface is a unified tool to manage your AWS\n       services.\n\nSYNOPSIS\n          aws [options] <command> <subcommand> [parameters]\n\n       Use aws command help for information on a  specific  command.  Use  aws\n       help  topics  to view a list of available help topics. The synopsis for\n       each command shows its parameters and their usage. Optional  parameters\n       are shown in square brackets.\nAVAILABLE SERVICES\n       o acm\n\n       o acm-pca\n\n       o alexaforbusiness\n\n       o amplify\n\n       o apigateway\n\n       o apigatewaymanagementapi\n\n       o apigatewayv2\n\n       o application-autoscaling\n\n       o appmesh\n\n       o appstream\n\n       o appsync\n\n       o athena\n\n       o autoscaling\n\n       o autoscaling-plans\n\n       o backup\n\n       o batch\n\n       o budgets\n\n       o ce\n\n       o chime\n\n       o cloud9\n\n       o clouddirectory\n\n       o cloudformation\n\n       o cloudfront\n\n       o cloudhsm\n\n       o cloudhsmv2\n\n       o cloudsearch\n\n```\n\n2. 配置\n\n其中有一个子命令`configure`，是用来配置aws cli的。aws cli访问的都是 aws 服务，而每个服务都是需要身份验证的，所以在使用之前，需要先配置身份信息。\n\n同样，先查看`configure`的说明：\n```shell\n$ aws configure help\nNAME\n       configure -\n\nDESCRIPTION\n       Configure  AWS  CLI  options. If this command is run with no arguments,\n       you will be prompted for configuration values such as your  AWS  Access\n       Key  Id  and you AWS Secret Access Key.  You can configure a named pro-\n       file using the --profile argument.  If your config file does not  exist\n       (the default location is ~/.aws/config), the AWS CLI will create it for\n       you.  To keep an existing value, hit enter when prompted for the value.\n       When  you  are prompted for information, the current value will be dis-\n       played in [brackets].  If the config item has no value, it be displayed\n       as  [None].  Note that the configure command only work with values from\n       the config file.  It does not use any configuration values  from  envi-\n       ronment variables or the IAM role.\n\n       Note:  the  values  you  provide  for the AWS Access Key ID and the AWS\n       Secret Access Key will  be  written  to  the  shared  credentials  file\n       (~/.aws/credentials).\n\nCONFIGURATION VARIABLES\n       The following configuration variables are supported in the config file:\n\n       o aws_access_key_id - The AWS access key part of your credentials\n\n       o aws_secret_access_key - The AWS secret access key part of  your  cre-\n         dentials\n\n       o aws_session_token  - The session token part of your credentials (ses-\n         sion tokens only)\n\n       o metadata_service_timeout - The number of seconds to  wait  until  the\n         metadata service request times out.  This is used if you are using an\n         IAM role to provide your credentials.\n\n       o metadata_service_num_attempts - The number  of  attempts  to  try  to\n         retrieve  credentials.   If you know for certain you will be using an\n         IAM role on an Amazon EC2 instance, you can set this value to  ensure\n         any intermittent failures are retried.  By default this value is 1.\n\n       For  more information on configuration options, see Configuring the AWS\n       Command Line Interface in the AWS CLI User Guide.\n\n       See 'aws help' for descriptions of global parameters.\n\n```\n\n其中有用的就是`CONFIGURATION VARIABLES`，一般需要两个参数，`aws_access_key_id`和`aws_secrct_access_key`，这两个参数登陆AWS后从IAM获取，下面是配置方法，`--profile`是给当前配置的身份起一个名字，这里起名叫`dev`：\n```shell\n$ aws configure --profile dev\nAWS Access Key ID [None]: \nAWS Secret Access Key [None]: \nDefault region name [None]: \nDefault output format [None]: \n```\n执行后会让你输入以上几项，`aws_access_key_id`和`aws_secrct_access_key`照常填写，后面几项可以不填，也可按需填写。\n\n这样，就配置完成了，使用`dev`这个身份，就可以访问aws的各种服务了。\n\n---\n\n**到这就算是入门了**","tags":["AWS","Python"],"categories":["AWS"]},{"title":"Golang 项目结构","url":"/2019/08/d923d0c927c5/","content":"\n>  好久没写 golang 的项目了，前两天接个临时需求，需求不难，但要求必须用golang来写。一时间竟然忘了如何开始，从哪入手了，故在此做个记录，以备不时之需。\n<!--more--> \n- 环境： MacOS\n- IDE：GoLand\n\n1. 项目路径\n    为了便于管理和引用其他 package，一般放在 `/{GOPATH}/src` 下。在该目录下，创建一个公司域名的文件夹，在此文件夹下创建项目命名的文件夹，如`/{GOPATH}/src/domain.com/project_name/`。\n\n2. 项目结构\n```\n  project_name/\n    |__bin/\n    |__build/\n    |__config/\n    |__cmd/\n    |  |__service_1/\n    |     |__service_1.go\n    |  |__service_2/\n    |     |__service_2.go\n    |__docs/\n    |__Godep/\n    |__pkg/\n    |    |__lib/\n    |    |__...\n    |    |__...\n    |__resource/\n    |__vendor/\n```\n- bin/：编译后的二进制文件\n- build/：编译、构建脚本文件\n- config/：配置文件，json/yaml等\n- cmd/：所有服务\n- cmd/service_1/：某个具体的服务\n- cmd/service_1/service_1.go：服务入口\n- docs/：文档\n- Godep/：godep 自动生成的目录\n- pkg/：主要代码\n- resource/：资源\n- vendor/：godep 自动生成的目录\n\n3. `godep`\n    包依赖管理工具，使每个项目的依赖的版本相互独立。在项目根目录下执行`godep save ./cmd`，自动生成 Godep 和 vendor。\n\n\n**大致，就这些。**","tags":["Golang"],"categories":["Golang"]},{"title":"AWS EMR 上运行 Spark + Kinesis: NoSuchMethodError: org.apache.spark.internal.Logging","url":"/2019/08/bb99d69df7f6/","content":"\n> 如题，因有需求，这两天在弄这个Spark，用的是AWS的EMR，具体是什么就不解释了。上面这个问题卡了很久，故在此记录一下。\n<!--more--> \n- Spark支持多种语言，如Scala、Java、Python、R，我用的是Python。\n\n官方有个叫WordCount的Example，我没看，直接照着文档撸代码。[Spark文档地址](https://spark.apache.org/docs/latest/streaming-kinesis-integration.html)\n\n\n初始化代码很简单，如下：\n\n```python \n# main.py\nfrom pyspark import SparkContext\nfrom pyspark.streaming import StreamingContext\nfrom pyspark.streaming.kinesis import KinesisUtils, InitialPositionInStream\n\naws_access_key_id = 'your-aws-access-key-id'\naws_secret_access_key = 'your-aws-secret-access-key'\n\nif __name__ == '__main__':\n    sc = SparkContext('local[*]', 'first_test0809')\n    ssc = StreamingContext(sc, 1)\n    kinesis_stream = KinesisUtils.createStream(\n        ssc,\n        'ssc_kinesis',\n        'kinesistest',\n        'https://kinesis.us-west-2.amazonaws.com',\n        'region-name',\n        InitialPositionInStream.TRIM_HORIZON,\n        2,\n        awsAccessKeyId=aws_access_key_id,\n        awsSecretKey=aws_secret_access_key\n    )\n\n    kinesis_stream.pprint(500)\n\n    ssc.start()\n    ssc.awaitTermination()\n```\n\n`kinesistest`是我创建的一个kinesis streaming，会有源源不断的数据写到这个streaming里，Spark负责处理这个streaming里的数据。\n\n接下来就是将这个文件部署到EMR上，依然是照着文档来操作。[文档地址](https://docs.aws.amazon.com/zh_cn/emr/latest/ReleaseGuide/emr-spark-submit-step.html)\n\n不得不说，AWS的文档既简约又简单，却不明了，在这个文档的指引下，没有一次我是顺利走通的。\n\n添加Step的命令：\n\n```shell\naws emr add-steps --cluster-id j-2AXXXXXXGAPLF --steps Type=Spark,Name=\"Spark Program\",ActionOnFailure=CONTINUE,Args=[--class,org.apache.spark.examples.SparkPi,/usr/lib/spark/lib/spark-examples.jar,10]\n```\n\n这个命令要分为两部分来看，前部分是AWS自身的命令`aws emr add-steps`，后部分就是`Args`这个参数的值。\n因为部署Spark程序实际上用的是`spark-submit`命令，而`Args`的值，都会传给`spark-submit`。\n\n前半部分比较简单，`cluster-id`就是在创建EMR集群后自动生成的id，这里需要注意的是，创建的EMR集群必须要设置共有IP，这样外部机器才能访问到。`Type`固定为Spark，`Name`自己随便写，`ActionOnFailure`一般都传CONTINUE，其他可选值可通过`aws emr add-steps help`查看。\n\n后半部分的`Args`的相关说明在[这里](https://github.com/apache/spark/blob/branch-1.3/core/src/main/scala/org/apache/spark/deploy/SparkSubmitArguments.scala#L454)，说的很详细。\n\n在部署运行之后，会报一些`ClassNotFound`的错误，这种错误不要紧，把缺的jar文件当作参数传上去就能解决问题。[Maven搜索地址1](https://mvnrepository.com/) | [Maven搜索地址2](https://search.maven.org/)\n\n上面的main.py用到了两个没有的jar文件，kinesisi和kcl，为了便于观看，使用了另一种格式，如下：\n\n```shell\n$ aws emr add-steps --cluster-id j-2AXXXXXXGAPLF --steps file://./step.json\n```\n\n将参数都抽取到一个josn文件中：\n```json\n[\n  {\n    \"Name\": \"Spark Program\",\n    \"Type\": \"Spark\",\n    \"ActionOnFailure\": \"CONTINUE\",\n    \"Args\": [\n      \"--master\",\n      \"local\",\n      \"--jars\",\n      \"local:///home/hadoop/spark-streaming-kinesis-asl_2.11-2.4.3.jar,local:///home/hadoop/amazon-kinesis-client-1.11.1.jar\",\n      \"local:///home/hadoop/main.py\"\n    ]\n  }\n]\n```\n\n注意，命令中所用到的所有文件，包括jar和py，都需要提前上传到机器上。具体上传方法见`aws emr put`命令\n\n至此，所有的工作基本完成，你以为这样就可以跑起来了吗？\nNO！\n\n最麻烦的问题，就是Spark版本的问题。之前用的最多、最稳定的就是1.6.5版本的，现在最新版已经2.4.3了，里面变动不小，尤其是`Logging`这个类，直接内部化了。\n\n仔细看会发现，上面的kinesis jar文件有两个版本号：2.11-2.4.3，后面的2.4.3是Spark大版本，前面的是什么我没查。在Maven里，这个版本最新的是2.12，所以最开始的时候我直接用了最新的，因为网上一直在强调的都是后面的2.4.3这个版本号，结果就出问题了，如题所写，总是报NoSuchMethodError。\n\n2.0之前的，Logging的位置是org.apache.spark.Logging，2.0之后变成了org.apache.spark.internal.Logging，但我用的都是最新版，为什么总说找不到呢？想了想，想了又想，试了各种办法，都行不通，这个过程持续了一天多，让人头大。\n\n后来不知是巧合，还是时候到了，偶然发现cluster机器上spark-core的版本号是2.11-2.4.3，报着尝试的心态从Maven下了2.11-2.4.3的kinesis jar文件，换上去一跑，哎，就这么成了。真是气人。\n\n所以说呢，有些时候解决问题是很简单的，困难的是发现问题。\n","tags":["AWS","EMR"],"categories":["Spark"]},{"title":"摸摸「浮点数」的底","url":"/2019/06/3754d5b7c490/","content":"\n> 摆理论和套公式其实也是为了说明问题，解释原理，不过有时却适得其反。\n\n\n\n前一个主题介绍了整数在计算机里的存储形式，浮点数，即小数，例如 3.14、2.71828 等，看起来和整数相近，而二者在计算机中存储的形式大为不同，作为一种常用的数据类型，来了解了解其中的本质，这个主题我们一起来摸摸「浮点数」的底。\n\n\n\n浮点数有多种类型，*但是我们写代码时常用到的有两种*，按照所占长度分为：一个是单精度，占用 32 个二进制位，另一个是双精度，占用 64 个二进制位。不管是什么类型、占用多少位，存储的**模式**都是类似的，而这也正是我们想要摸的「底」。\n\n\n\n##### 1. 化身为二进制的浮点数\n\n首先明确一点，不管什么类型的数据，整数也好，浮点数也罢，在计算机中都是以二进制形式存储，即 01001、10110 这样的形式。\n\n\n\n那么，二进制的浮点数该如何表示呢？\n\n\n\n在此之前，我们先来看下十进制的小数 22.71是如何表示的：**小数点左边第一位为个位，表示 1，第二位为十位，表示 10；小数点右边第一位为十分位，表示 1/10，即 10^<sup>-1</sup>，第二位为百分位，表示 1/100，即 10^<sup>-2</sup>，综合如下**。\n\n```java\n22.71 = 2*10^1 + 2*10^0 + 7*10^-1 + 1*10^-2\n      = 20 + 2 + 0.7 + 0.01\n      = 22.71\n```\n\n\n\n上面就是十进制浮点数的表示形式，而二进制与十进制整体相同，唯一区别就在于将 10 换成了 2，举个例子，如二进制浮点数 101.11：**小数点左边第一位表示 2^<sup>0</sup>，即 1，第二位表示 2^<sup>1</sup>，即 2，第三位表示2^<sup>2</sup>，即 4；小数点右边第一位表示 2^<sup>-1</sup>，即 0.5，第二位表示 2^<sup>-2</sup>，即 0.25，综合如下**。\n\n```java\n101.11 = 1*2^2 + 0*2^1 + 1*2^0 + 1*2^-1 + 1*2-2\n       = 4 + 0 + 1 + 0.5 + 0.25\n       = 5.75\n```\n\n\n\n##### 2. 自由转化的浮点数\n\n既然，浮点数既可以用十进制表示，也可以用二进制表示，那么同一个浮点数如何在这两种进制之间自由转化呢？由二进制转为十进制就不用说了，上面刚刚用 101.11 演示完，而由十进制转为二进制很多人都是直接套公式却没想过原理，接下来说说推导公式的过程。**这个转化过程需要将浮点数的整数部分和小数分别转化，之后再进行合并**。\n\n\n\n我们用 6.625 来举例说明。先看整数部分的 6，这个我们一眼就能看出来，结果是 110，但是如果换成 60、600，这些不能一眼看出的数呢？其实很多事情都是如此，将思考过程从「一眼就能看出的」的情况中抽象出来，就是计算方法。这个思考过程无非就是，想知道需要几个二进制位、每个二进制的值是多少，就可以表示 6。\n\n\n\n为了便于理解，我们先看一下计算表示 758 需要几个十进制位以及每位的值是多少。\n\n\n\n```java\n先从个位，即右起第一位开始:\n\n很显然，求个位的值用 758 对 10 取余即可：758 / 10 = 75···8，结果为 8，此时原数还剩下 75*10，大于 0，说明一位不够；\n\n继续求第二位的值：75*10 / 100 = 75 / 10 = 7···5，结果为 5，此时原数还剩下 7*100，大于 0，说明两位还是不够；\n\n继续求第三位的值：7*100 / 1000 = 7 / 10 = 0···7，结果为 7，此时原数还剩下 0*1000，等于 0，说明三位十进制够用了。\n\n最终结果，需要 3 个十进制位，从左到右的值分别是 7、5、8，即 758。\n\n同时我们发现的一个规律是：\n求第二位的值时，用计算完第一位的商对 10 取余即可，\n求第三位的值时，用计算完第二位的商对 10 取余即可。\n```\n\n**由此可得，求第 n 位的值时，用计算完 n-1 位的商对 10 取余数即可，当商为 0 时，结束，注意 n > 1。**如上，就是十进制抽取方法的过程，也同样适用于二进制，区别就在于将 10 换成了 2，实际计算一下。\n\n```java\n计算将 6 用二进制的值，同样从右起的第一位开始：\n\n先求第一位：6 / 2 = 3···0，结果为 0，原数还剩下 3*2^1，大于 0，说明一位不够；\n\n继续求第二位，3 / 2 = 1···1，结果为 1，原数还剩下 1*2^2，大于 0，说明两位不够；\n\n继续求第三位，1 / 2 = 0···1，结果为 1，原数还剩下 0*2^3，等于 0，说明三位二进制够了。\n\n最终结果，需要 3 个二进制位，从左到右的值分别是 1、1、0，即 110，而这也与我们直观上看到的结果相符。\n```\n\n\n\n与整数部分的计算类似，再看下小数部分的计算。同样，先用比较直观的十进制浮点数举例，从而从中总结规律。\n\n```java\n计算 0.358 用几位十进制的浮点数表示，及每位的值的过程，从左开始，\n\n先求第一位，注意，与整数不同的是，这里是取商，而不是余数：\n0.358 / 10^-1 = 0.358 * 10 = 3···0.58，结果是：3，原数还剩下：0.58*10^-1 > 0;\n继续求第二位，\n0.58*10^-1 / 10^-2 = 0.58 * 10 = 5···0.8，结果是：5，还剩下：0.8*10^-2 > 0;\n继续求第三位，\n0.8*10^-2 / 10^-3 = 0.8 * 10 = 8···0，结果是：8，还剩下：0，说明 3 位十进制够了。\n\n最终结果，需要 3 个十进制，从右向左分别是 3、5、8，即 0.358。\n\n同时，我们发现：\n求第二位时，用计算完第一位的余数乘 10 再取商即可，\n求第三位时，用计算完第二位的余数乘 10 再取商即可。\n```\n\n**由此可得，计算第 n 位时，用计算完第 n-1 位的余数乘 10 再取商即可，当余数等于 0 时结束，注意 n > 1。**紧接着，用我们从上面十进制例子中总结的方法计算下二进制。\n\n```java\n计算 6.625 的小数部分 0.625 的二进制形式，从左开始，\n\n先求第一位，0.625 * 2 = 1···0.25，结果是 1，原数还剩下：0.25*2^-1 > 0；\n继续求第二位，0.25 * 2 = 0···0.5，结果是 0，原数还剩下：0.5*2^-2 > 0；\n继续求第三位，0.5 * 2 = 1···0，结果是 1，原数还剩下：0，结束。\n\n最终结果，需要 3 个二进制位，从左向右分别是：1、0、1，即 0.101。\n```\n\n至此，我们完成了所有计算过程，整数部分：110，小数部分：101，最终结果为：110.101。\n\n\n\n##### 3. 如何存储\n\n前面做了那么多铺垫，现在终于可以开始说存储了。存储之前，需要先把二进制的浮点数用科学计数法表示，也称规范化，即 \n\n**N = ±a x 2^<sup>n</sup>** , a∈ **[1,2)**\n\n**a** 叫作尾数，**n** 叫作阶码。计算机存储的浮点数都是这种形式的，例如上面的 110.101 就需要变成 1.10101x2^<sup>2</sup>，而 0.1101 就需要变成 1.101x2^<sup>-1</sup>，这个变换的过程很简单。\n\n\n\n对于浮点数 **±a\\*2^<sup>n</sup>**，计算机将其分成了 3 个部分来进行存储，即存储正负的**符号位**、存储 n 的**指数域**和存储 a 的**尾数域**，是的，存储 a 的部分叫做**尾数域**。\n\n\n\n对于长度为 32 位二进制的浮点数，从左起，第 1 位用来表示符号，0 代表正数，1 代表负数。接下来的 8 位，即第 2 位到第 9 位，用来表示指数。而从第 10 位开始一直到最后的 32 位，都用来表示尾数，对于科学计数法下的 a，其整数部分的值永远都是 1，所以这个 1 就省略了，因此 23 位尾数二进制只存储了 a 的小数部分，即 1.10101 的 10101，1.101 的 101。\n\n\n\n和 32 位类似，长度为 64 位二进制的浮点数，从左起，第一位存储符号，接下来的 11 位存储指数，剩下的 52 位存储尾数，而尾数同样省略了 a 的整数部分，只存储小数部分。\n\n\n\n##### 4. 阶码\n\n符号位，0 或 1，尾数域，采用原码表示，这两种比较简单明了，这里要单独说一说阶码。\n\n\n\n在此之前，先回忆一下移码。所谓移码，实际上就是把负数映射到正轴上，通俗的说就是消灭负数。例如，4 个bit位能表示的范围，[-2^<sup>3</sup>, 2^<sup>3</sup> - 1]，即[-8, 7]。每个数字加上偏移量 2^<sup>3</sup>，即为移码。\n\n\n\n阶码在计算机中也是以移码的形式存储的，区别在于这个偏移量。**根据 IEEE 754 标准，k 位二进制位的解码，偏移量 bias 为 2^<sup>k-1</sup> - 1**，例如 32 位单精度浮点数，阶码为 8 位，则偏移量为 2^<sup>8-1</sup> - 1 = 127。\n\n\n\n**N = (-1)^<sup>S</sup> x 2^<sup>E-Bias</sup> x (1+M)**\n\n其中，**S为符号位的值，E为指数的值，M为尾数域的值，Bias为移码偏移量**。\n\n\n\n举个例子，-6.75，**单精度浮点数，转化为规范化二进制为：**-110.11 = -1.1011 x 2^<sup>2</sup>\n\n符号位 **S = 1**，\n\n阶码 **E = 2 + Bias = 2 + 127 = 129**\n\n尾数 **M = 1.1011 - 1 = 1011** (省去小数点)\n\n**1 10000001 10110000000000000000000** （尾数域：4 位精度 + 19 个 0，共 23 位）\n\n\n\n至此，浮点数就介绍完了。\n\n\n\n","tags":["编码","浮点数"],"categories":["编码"]},{"title":"「原码 反码 补码 移码」一探究竟（下）","url":"/2019/01/0a1eac4519fc/","content":"\n> 抛开复杂的理论，直探事物的本质。\n\n这是这个主题的第三篇文章，前两篇介绍了**这几种码的基本概念**，这篇文章来具体说说「移码」。\n<!--more-->\n**00. 回顾**\n\n先来回顾一下移码是什么，简单说定义就一句话：**将补码符号位取反，即为移码**。乍一看，是不是有点懵，这到底在说什么呢？什么是移码？为什么是这么算？它能干嘛用？莫急，这些问题一个一个都会解决。\n\n相比于移码，应该使用补码的几率更高一些。因为移码主要用在浮点数的阶码中，用的较少。注意，这里又出来了一个新名词，「阶码」，关于这块的内容比较乱，会单独写一篇文章来说。而现在只需要记住一句话，**移码的出现就是为了消灭负数**。\n\n<!--more--> \n\n**01. 如何「消灭」负数**\n\n\n先拿大家都熟悉的数轴举个例子。\n![](https://i.loli.net/2021/07/07/cdtpFeLJPyw9Txl.png)\n\n如图，数轴上一共有 5 个点，分别为 -2、-1、0、1、2，其中有 2 个负数，所谓消灭负数，就是用 5 个非负数来表示这 5 个点，方法就是**将 0 向左移动两个位置**，如下。\n![](https://i.loli.net/2021/07/07/HwXenQjWztJC2rY.png)\n\n很简单吧，这样一移动负数就被消灭了，而「**移码**」的计算就是这个道理，而**将 0 向左移动 2 个位置就等同于将所有数字加 2**，这个很好理解。很显然，**移动的位数就是表示范围内负数的个数。**\n\n**02. 为什么是补码符号位取反？**\n\n先明确一点：**因为移码都是非负数，不需要符号位，所以，所有的二进制位都是用来表示数据的。**\n\n接下来，根据上面得出的结论，我们亲自来算一算移码。为了便于计算，就拿 4 位二进制来举例。在计算机中，4 位二进制能表示的范围为 **[-2^3, 2^3-1] = [-8, 7]**，其中负数的个数为 -1 到 -8，共 **2^3** 个，也就是 8 个，所以需要将 0 向左移动 8 个位置，**即给每个数加上 8**，如下。\n\n```\n     补码   +8  移码\n-8  [1000]  0 [0000]\n-7  [1001]  1 [0001]\n-6  [1010]  2 [0010]\n-5  [1011]  3 [0011]\n-4  [1100]  4 [0100]\n-3  [1101]  5 [0101]\n-2  [1110]  6 [0110]\n-1  [1111]  7 [0111]\n 0  [0000]  8 [1000]\n 1  [0001]  9 [1001]\n 2  [0010] 10 [1010]\n 3  [0011] 11 [1011]\n 4  [0100] 12 [1100]\n 5  [0101] 13 [1101]\n 6  [0110] 14 [1110]\n 7  [0111] 15 [1111]\n```\n\n上面这样对比着看，应该很清晰了。经过计算得出的移码，刚好等于补码符号位取反，所以移码的定义就简化成了一句话：将补码符号位取反，即为移码。\n\n再说一个有点不好理解的方法，觉得啰嗦略过就好。除去首位的符号位不看，单看剩下的  3 位二进制，-8 到 -1 本身就符合从小到大的规律，而 0 到 7 也是如此，但 [0,7] 要大于  [-1,-8]，强转成无符号数，用符号位的 0 和 1 两个值便可以区分原本的 8 个负数和 8 个非负数，**最终就是将负数转化为了正数，将正数转化为了更大的正数**。\n\n**结束**\n\n至此，关于「**原码 反码 补码 移码**」主题的文章就告一段落了。\n\n段首写了这么一句话：「**抛开复杂的理论，直探事物的本质**」。我是这么理解这句话的，讲一样东西，只有把没什么基础的人都说明白了，说懂了，也不用过多的摆理论、套公式，这样才算是真的讲透彻了，话虽俗，理不俗。\n","tags":["编码"],"categories":["编码"]},{"title":"「原码 反码 补码 移码」一探究竟（中）","url":"/2019/01/76011953e8ea/","content":"---\n上文「原码 反码 补码 移码」一探究竟（上）说了基本定义和原码，对于补码，我们只知道是对原码符号位不变，其他位置取反，最后再加 1 得来的，为何如此呢？接下来咱们来揭下「补码」的面具，看看它到底是什么。\n\n<!--more--> \n\n**0. 关于 1 + (-1)**\n\n首先，先看一个问题。\n\n1 的原码为[0000 0001]，-1 的原码为[1000 0001]，所以计算这两个数相加，应该是这样的：\n\n```\n1 + (-1) \n\n= [0000 0001]原 + [1000 0001]原 \n\n= [1000 0010]原 \n\n= -2\n```\n\n结果竟然是 -2，很明显是错的，这样用原码计算就出问题了。当然，劳动人民的智慧不可估量，总能发现合适的方式来解决各种问题，于是，补码就诞生了，再看用补码计算的过程。\n\n```\n1 + (-1) \n\n= [0000 0001]原 + [1000 0001]原 \n\n= [0000 00001]补 + [1111 1111]补 \n\n= [0000 0000]补 \n\n= [0000 0000]原 \n\n= 0\n```\n\n结果正确，问题得以解决，而这也是计算机都是以补码的形式来存储整数的原因。\n\n但是，为什么用补码计算就能得到正确结果呢？为什么补码的计算方式是原码取反再加 1 呢？带着问题，我们继续往下看。\n\n\n**1. 钟表上的哲学**\n\n钟表，每个人应该都清楚的，上面的数字范围[0,11]，也可以理解为[1, 12]，毕竟上面没有写 0 这个数字，但是不变的是，都可以表示12个小时。\n\n比方说，现在是  9:00，时针指向9。我要想知道 7 个小时之前是几点，那么我只需要将时针向回拨动 7 个格子即可，结果很显然，时针将会指向 2，表示  2:00；但是，我要想知道 5 个小时后是几点呢？也很简单，将时针向前拨动 5 个格子，结果也很显然，时针也会指向 2，表示 2:00。\n\n通过不同方式，我们得到了同样的结果，**也就是说在钟表上，9 - 7 = 9 + 5 = 2**。不仅 7 和 5 有这样的规律，8 和 4、9 和 3等都有这样的规律，也就是说，相加等于 12 的两个数都符合这样的规律，即 **X - Y = X + (12 -Y)**，而 12 在这里有个名字，叫做这个钟表的**模**，12 - Y 叫做 Y 的**补数**。\n\n**减去一个数，等于加上这个数的补数，应用这个规律就可以将减法转换为加法了。**\n\n那么问题来了，模长该怎么求？\n\n\n**2. 通俗的「模」**\n\n通俗的讲，很简单。还是拿钟表举例，上面能表示的数字的总数就是其模长，所以不管是[0, 11]，还是[1, 12]，都为12。\n\n再来看 8 位二进制，其原码能表示的范围 (注意看，这里说的是原码)，**[1111 1111] ~ [0111 1111]**，即 **[-2^7 - 1, 2^7 - 1]** = **[-127, 127]**，因为我们是要将其全部转变为非负数，即能表示的范围为[0, 127]，所以模长为 128。\n\n说完了这些，我们再来重新看下 -3 的补码的计算过程。-3 原码为 **[1000 0011]**，而**取反的过程实际上等同于用[0111 1111]减去 -3 原码中的符号位之外的部分**，之后再加 1 即得到补码，所以：\n\n```\n-3 补码(未添加符号位)\n\n= [1000 0011]原 取反 + [0000 0001]\n\n= [0111 1111] - [0000 0011] + [0000 0001]\n \n= [0111 1111] + [0000 0001] - [0000 0011]\n \n= [1000 0000] - [0000 0011]\n\n= 128 - [0000 0011]\n\n= 模  - [0000 0011] \n\n= 模  - 3\n```\n\n看到这，是不是一下就明白了？**补码实际上就是模减去原码的值，再加上一个符号位，也就是所说的：符号位不变，取反再加1**。\n\n所以，在计算机中，整数都是以补码的形式存储的，是为了统一加减法运算。因为计算机之中是没有做减法的逻辑门，减法都会被转化为加法来完成计算。\n\n而通过溢出，符号位也可以直接参与计算，大大简化了计算过程，看个例子就明白了。\n\n```\n7 + （-3）\n\n= [0000 0111]原 + [1000 0011]原 \n\n= [0000 0111]补 + [1111 1101]补 \n\n= [0000 0100]补 (溢出部分不用处理)\n\n= [0000 0100]原 \n\n= 4 \n\n2 + （-3）\n\n= [0000 0010]原 + [1000 0011]原 \n\n= [0000 0010]补 + [1111 1101]补 \n\n= [1111 1111]补 \n\n= [1000 0001]原 \n\n= -1\n```\n\n再看个特例。\n\n```\n-1 + (-127) \n\n= [1000 0001]原 + [1111 1111]原 \n\n= [1111 1111]补 + [1000 0001]补 \n\n= [1000 0000]补 \n\n= -128\n```\n\n用原码能表示的最小负数为 **-127**，补码却能表示的最小负数为 **-128**，但是 **-128** 没有原码和反码表示，由于计算机中使用补码表示整数，所以这没有影响，因此 8 位二进制数，也就是 **byte** 类型能表示的范围是 **[-128, 127]**。\n\n说到这，对于补码，应该足够清晰了吧！","tags":["编码"],"categories":["编码"]},{"title":"「原码 反码 补码 移码」一探究竟（上）","url":"/2019/01/8ebb2c9120f0/","content":"\n> 抛开复杂的理论，直探事物的本质。\n\n**0. 二进制**\n\n相比于二进制，十进制数字大家都比较熟悉。从右往左依次是个位、十位、百位、千位等，每个位置上的数字范围 [0, 9]。个位上的 1 表示 1，十位上的 1 表示 10，百位上的 1 表示 100，即从右向左的第 n 位就代表 10^(n-1)：\n<!--more--> \n```\n761 = 7*100 + 6*10 + 1*1 = 7*10^2 + 6*10^1 + 1*10^0\n```\n\n而二进制，也是同样的道理，区别就是将 10 的 n-1 次幂变成了 2 的 n-1 次幂：\n\n```\n1101 = 1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 8 + 4 + 0 + 1 = 13\n```\n\n有了这些基础概念，接着再来看下面的内容。\n\n**1.** **这些「码」都是什么？**\n\n**计算机中的数字一般分为两种，有符号数和无符号数。**\n\n**原码**，是一种计算机中对数字的二进制表示的方法。\n\n**有符号数**，即用最高位的二进制位来表示正负，剩下的位来存储数据。\n\n**无符号数**，即所有的二进制位都来表示数据，所以无符号数字无法表示负数，全部大于等于 0。\n\n光看定义干巴巴的，用长度为 8 位二进制的类型举几个例子。\n\n有符号数，最高位表示正负，0 表示正数，1 表示负数。\n\n```\n   7 : [0000 0111]原\n  -3 : [1000 0011]原\n-127 : [1111 1111]原\n```\n\n无符号数，没有符号位，全部二进制位用来表示数据。\n\n```\n  7 : [0000 0111]原 \n 16 : [0001 0000]原\n255 : [1111 1111]原\n```\n\n上面就是原码的定义，而反码、补码、移码都是在原码的基础上做了对应的变换。\n\n**反码**：正数的反码就是其原码，负数的反码为，符号位不变，其余位取反，即 0 变 1，1 变 0。\n\n**补码**：正数的补码就是其原码，负数的补码为在其反码的基础上再加 1，而在计算机中，整数都是以补码的形式存储的。\n\n**移码**：将补码符号位取反，即为移码。\n\n**这几种码都是针对有符号数，而无符号数用原码就足够了**，后面会对此说明原因。同样，也举几个例子说明。\n\n```\n 7 : [0000 0111]原 [0000 0111]反 [0000 0111]补 [1000 0111]移\n-3 : [1000 0011]原 [1111 1100]反 [1111 1101]补 [0111 1101]移\n```\n\n关于定义，就说这些。既然原码就能表示数字，那为什么又会有这么多类型的码呢？而这些不同的码又是怎么来的呢？计算机中为什么要以补码而不是其他码来存储整数呢？移码又是做什么的呢？鉴于篇幅过长，下篇文章，会对这些问题一一说明。\n","tags":["编码"],"categories":["编码"]},{"title":"Goland调整Terminal窗口字体大小","url":"/2018/12/44fb710f68f6/","content":"\nGoland的Ternimal窗口样式和Console窗口公用同一个样式，修改路径:\n> Setting->Editor->Color Scheme->Console Font\n\n若不生效，重启一下IDE即可。\n<!--more--> \n\n![](https://i.loli.net/2021/07/07/pkb8qoWm7RzV2ij.png)\n","tags":["GoLand"],"categories":["Golang"]},{"title":"Golang websocket client读取数据","url":"/2018/11/f0d738b44296/","content":"\nGolang 既可以写 websocket 的 server 端也可以写 websocket 的 client 端，前者网上的资料很多后者甚少，今天遇到写 client 的需求，在此做个总结。\n\n- 测试地址：火币网\n- websocket包：golang.org/x/net/websocket\n<!--more--> \n### 1. 建立连接。\n连接成功建立后，client 和 server 均可以随时往数据通道里写数据同时也可以从中读取数据。\n\n```golang\nvar wsurl = \"wss://api.huobi.pro/ws\"\nvar origin = \"http://api.huobi.pro/\"\nws, err := websocket.Dial(wsurl, \"\", origin)\nif err != nil {\n    panic(err)\n}\n```\n### 2. 写数据。\n在通道已建立的前提下，写数据操作通过一行代码即可完成：\n\n```golang\nfunc sendMessage(data []bytes) {\n\tws.Write(msg)\n}\n```\n### 3.1 读数据。\n最简单的方法是调用`func (ws *Conn) Read(msg []byte) (n int, err error)`方法，定义一个用来接收数据的`[]byte`数组当作参数传入，但是由于不知道server发来的数据长度，所以一般是定义一个足够大的字节`[]byte`数组，这样读取一来浪费内存二来处理起来麻烦，不建议使用；\n\n```golang\nfunc readMessage(ws *websocket.Conn) {\n\tdata := make([]byte, 1024*10)\n\t_, err := ws.Read(data)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n```\n### 3.2 读数据。\n对于都是以json方式传输的数据，websocket包提供了将每条message读取到一个`interface{}`中的方法，等同于`json.Unmarshal`。\n\n```golang\nfunc readJsonMessage(ws *websocket.Conn) {\n\tvar data interfact{} // data的类型为接收的JSON类型struct\n\terr := websocket.Message.Receive(ws, data)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n```\n### 3.3 读数据。\n3.2是将接收到的数据直接unmarshal到struct里了，而我的需求比这个要麻烦一点：server发来的数据`[]byte`数组是压缩过的，所以接收到数据后第一步应该解压缩然后才能unmarshal，所以不能再用3.2的方式，参照3.2的源码，实现方式如下。\n\n```golang\nfunc readOriginMessage(ws *websocket.Conn) {\n\tagain:\n\t\tfr, err := ws.NewFrameReader()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"new frame reader err %v\", err)\n\t\t\treturn\n\t\t}\n\t\tframe, err := ws.HandleFrame(fr)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"handle frame err %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif frame == nil {\n\t\t\tgoto again\n\t\t}\n\t\t\n\t\tbytes, err := ioutil.ReadAll(frame)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"read frame data err %v\", err)\n\t\t}\n\t\tunzipData, err := utils.UnzipByte(bytes)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"unzip data err %v\", err)\n\t\t}\n\n\t\tvar message map[string]interface{}\n\t\te := json.Unmarshal(unzipData, &message)\n\t\tif e != nil {\n\t\t\tlog.Printf(\"unmarshal err %v\", e)\n\t\t}\n\t\t\n\t\tlog.Printf(\"message content= %+v\", message)\n}\n```","tags":["Goland","websocket"],"categories":["Golang"]},{"title":"Android WebView加载URL不显示图片","url":"/2018/10/ab916a013a16/","content":"---\n偶然遇到的一个问题\n<!--more--> \n```java\n        WebSettings settings = mWebView.getSettings();\n        settings.setJavaScriptEnabled(true);//启用js\n        settings.setBlockNetworkImage(false);//解决图片不显示\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            settings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);\n        }\n```\n","tags":["Android","WebView"],"categories":["Android"]},{"title":"Program type already present: org.iq80.leveldb.CompressionType","url":"/2018/08/f07f2aa62201/","content":"---\n添加新依赖时遇到一个报错。\n<!--more--> \n今天在Android Studio添加了一个新的依赖：\n```\nimplementation (\"org.ethereum:ethereumj-core:$ethereumj_version\")\n```\n然后`Sync`可以通过，但是`Rebuild`报错如标题，往上搜了几个方法都未奏效，最后只好顺着问题找答案。\n\n报错的内容就是说`CompressionType`重复了，换句话说，添加的新依赖不添加这个即可。双击`Shift`全局搜索`CompressionType`定位，如图：\n![](https://i.loli.net/2021/07/07/nOSFvNhZ4BTgCmE.png)\n\n添加依赖时增加：\n\n```\n implementation (\"org.ethereum:ethereumj-core:$ethereumj_version\") {\n        exclude group: 'org.iq80.leveldb', module: 'leveldb-api'\n    }\n```\n`Sync`通过，`Rebuild`又报新错误：\n\n```\nMore than one file was found with OS independent path 'META-INF/spring.tooling'\n```\n在`android`节点增加配置：\n\n```\nandroid {\n\tpackagingOptions {\n        pickFirst 'META-INF/*'\n    }\n}\n```\n继续`Sync`，通过；`Rebuild`，通过。\n\n问题解决。","tags":["Android","Gradle"],"categories":["Android"]},{"title":"[翻译]种子词","url":"/2018/08/a8ab36581124/","content":"\n> 原文地址：https://en.bitcoin.it/wiki/Seed_phrase\n\n### 种子短语\n种子短语、种子恢复短语或备用种子短语是存储恢复比特币钱包所需的所有信息的单词列表。钱包软件通常会生成一个种子短语并指示用户将其写在纸上。如果用户的电脑坏了或者他们的硬盘坏了，他们可以再次下载相同的钱包软件，使用纸质备份来取回他们的比特币。\n<!--more--> \n任何发现这个短语的人都可以偷比特币，所以比特币必须保存的像珠宝或现金一样安全。例如，它不能被键入任何网站。\n\n种子短语是备份和存储比特币的好方法，因此几乎所有受好评的钱包都使用它们\n\n#### 举例\n种子短语的一个例子是:\n```\nwitch collapse practice feed shame open despair creek road again ice least\n```\n单词的顺序是很重要的。\n\n#### 解释\n关于种子短语如何工作的一个简单的解释是，钱包软件有一个从字典中提取的单词列表，每个单词被分配给一个数字。种子短语可以转换为一个数字，该数字用作种子整数，以生成钱包中使用的所有密钥对的确定性钱包。\n\nBIP39标准2048字的英文词库,如果这个词只包含12个随机的单词,可能的组合的数量将是2048 ^ 12 = 2 ^ 132，并且短语有132位安全性。但是，BIP39短语中的一些数据不是随机的，所以12个单词的BIP39种子短语的实际安全性只有128位。这与所有比特币私钥的强度大致相同，因此大多数专家认为它足够安全。\n\n发明你自己的种子短语并不安全，因为人类不善于产生随机性。最好的方法是让钱包软件生成你写下的短语。\n\n#### 双重种子短语\n种子短语和所有备份一样，可以存储任意数量的比特币。这是一个令人担忧的想法，可能有足够购买整个建筑的钱，却只是写在一张纸上而没有任何保护。由于这个原因，许多钱包使得用密码加密种子短语成为可能。\n\n密码可用于创建一个双因素种子短语，其中需要“你拥有的东西”和“你知道的东西”才能解锁比特币。\n\n它的工作原理是钱包创建一个种子短语并向用户询问密码。然后需要种子短语和额外的单词，才能恢复钱包。Electrum和其他一些钱包把密码短语叫做“种子扩展”，“扩展词”或者“第13 /25个单词”。BIP39标准定义了一种保护种子短语的方法。在Electrum标准中也使用了类似的方案。如果没有密码，则使用空字符串“”。\n\n警告:忘记这个密码将导致比特币钱包和任何钱包里包含的钱丢失。不要高估你记住密码的能力，尤其是当你可能不经常使用密码的时候。\n\n警告:种子短语密码不应该与用于加密磁盘上钱包文件的密码混淆。这可能就是为什么许多钱包称它为扩展词而不是密码。\n\n#### 诱骗的钱包\n这个功能还提供了貌似合理的可否认性，因为每个密码都会生成一个有效的钱包，但只有正确的密码才会让你想要的钱包可用。您可以创建一个具有相同种子短语但不同密码的诱骗钱包，如果身体上被迫，那么只显示第一个密码，并将第二个密码保密。\n\n另一方面，强迫你的实体可能已经知道诱骗钱包的概念。他们可以继续打你，直到你放弃两三个密码。\n\n关于这个问题的更长的讨论，请参见存储比特币# 5美元扳手攻击\n\n#### 长期储存种子短语\n大多数人在纸上写下短语，但也可以用许多其他的方式来存储，比如记忆、雕刻金属、在书页空白处写字、刻石碑或任何其他有创意的方式。\n\n用铅笔在纸上书写要比用钢笔书写好得多。纸张应无酸味或档案纸，存放在黑暗中，避免高温和潮湿。\n\n有些人想把他们的短语分开。在一个地方储存6个单词，在另一个地方储存6个单词。这是一个糟糕的想法，不应该这样做，因为如果一组6个单词被发现，那么就更容易对剩下的短语进行暴力攻击。像这样在多个地方存储比特币应该通过多签名钱包来实现。\n\n另一个坏主意是添加一些对你有意义的随机假词，然后把它们删除，只留下12个单词短语。这个短语来自于一本已知的字典(见下一节)，所以任何人都可以用那本字典来除去假词。\n\n在同一张纸上写一些解释的词，这可能是个好主意。如果长期储存，你可能会忘记一个短语应该如何处理。可以加以修改的示例解释是:\n\n    这十二个字控制着比特币。保管好这张纸，像现金或珠宝一样保密。本文中的比特币信息用密码加密。它是一个多  签名钱包的一部分，是在2012年1月1日由电子比特币钱包软件制作的。\n\n#### 单词列表\n一般来说，种子短语只适用于创建它的相同的钱包软件。如果储存的时间很长，最好也写上钱包的名字。\n\nBIP39英语单词表中，每个单词都由前四个字母唯一地识别出来，这在空间有限的情况下是很有用的。\n\n#### 替代的名字“助记词”\n种子短语有时被称为“助记短语”，特别是在古老的文学作品中。这是一个不好的名字，因为单词助记意味着这个短语应该被记住。把它们叫做种子短语没有那么误导人。","tags":["区块链"],"categories":["区块链"]},{"title":"[翻译]比特币确定性钱包","url":"/2018/08/97037d409735/","content":"\n> 原文地址：https://en.bitcoin.it/wiki/Deterministic_wallet\n<!--more--> \n\n### 确定性钱包\n确定性钱包是一种系统，从一个被称为种子的单一起点获取密钥。种子允许用户在不需要任何其他信息的情况下轻松备份和恢复钱包，在某些情况下，用户可以在不知道私钥的情况下创建公共地址。种子通常被串行化为人类可读的字词。\n\n#### 好处\n早期的客户端，如Satoshi客户端，会生成一个新的随机私钥缓冲区，在将来用作接收和更改地址。在短时间内耗尽密钥池缓冲区(通常是100个地址)后，这将使备份失效。确定性钱包可以在动态中产生无限数量的地址，因此不会受到这个问题的影响。由于地址是以一种已知的方式生成的，而不是随机生成的，一些客户端可以在多个设备上使用，而不会造成资金损失。用户可以方便地以人类可读的格式创建种子的单个备份，这种格式将持续钱包的使用寿命，而不必担心这种备份会变得过时。\n特定类型的确定性钱包(BIP0032, Armory, Coinkite和Coinb)额外允许完全分离私有和公共密钥的创建，以获得更大的安全性和方便性。在这个模型中，服务器可以设置为只知道特定确定性钱包的主公钥。这允许服务器创建尽可能多的公钥来接收资金，但是MPK协议不会允许攻击者从钱包中花钱。它们也可以在Electrum和Armory中使用，以实现完全离线存储和花费，离线计算机知道私钥，而在线的计算机只知道MPK。通过USB存储器，两种计算机之间可以通过USB存储器进行交易，避免将离线计算机暴露给基于网络的攻击。\n由硬件钱包(TREZOR)实现的确定性钱包将生成的私钥保持离线状态，即使花钱时也不将它们暴露给计算机。\n\n#### 类型\n#### 类型1 确定性钱包\n类型1确定性钱包是一种从已知的起始字符串生成地址的简单方法，因此它不允许高级功能，如主公钥。要生成一个私钥，需要使用SHA256(string + n)，其中n是一个ascii编码的数字，它从1开始，并随着需要额外的键而增加。\n这种类型的钱包可以由Casascius比特币地址实用程序创建。\n#### 类型2 分层确定性钱包\n这种钱包类型在bip0032中进行了描述，并在TREZOR、Electrum和CarbonWallet中得到了充分的实现。种子是一个随机的128位值，用户可以使用常用的英语单词作为12个单词的种子短语。该种子在10万轮SHA256之后使用，以减缓对弱用户选择字符串的攻击。\n这种钱包类型的最初描述和工作原理都归功于格雷戈里·麦克斯韦。\n#### Armory确定性钱包\nArmory有自己基于“根键”和“链码”的2型确定性钱包格式。早期版本的Armory需要备份“根键”和“链码”，而较新的版本则以不可逆转的方式从私钥派生链码。这些新的Armory(0.89+)只需要一个256位的根键。这种旧格式打算逐步淘汰，以支持标准BIP0032格式。","tags":["区块链","Bitcoin"],"categories":["区块链"]},{"title":"[翻译]Bitcoin Address介绍","url":"/2018/08/6dcc04b57a51/","content":"\n> 原文地址: https://en.bitcoin.it/wiki/Address\n<!--more--> \n## 地址\n\n一个比特币地址或是一个简单地址，是一个26-35个字母或数字组成的标识符，以数字1或3开头，这代表了比特币支付的可能目的地。任何比特币的使用者不需要任何话费便可以生成地址。例如使用Bitcoin Core客户端，点击“New Address“就会被分配一个地址。通过一个交易所账号或者在线钱包服务来获得比特币地址也是可能的。目前正被使用中的地址有3种格式：\n 1. P2PKH类型，以数字`1`开头，例如：`1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2`.\n 2. P2SH类型，以数字`3`开头，例如：`3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy`.\n 3. Bech32类型，以`bc1`开头，例如：`bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq`.\n\n\n#### 比特币地址是一个一次性的令牌\n就像e-mail地址，你可以通过向一个人比特币地址中的一个地址发送比特币来实现给这个人发送比特币。然而，和e-mail地址不同的是，一个人可以拥有很多比特币地址，每一次交易应该使用一个唯一的地址。大多数比特币软件和网站都会帮助你在每次创建发票或付款请求时生成一个全新的地址。\n\n#### 地址可以离线创建\n创建地址无需互联网连接，也不需要与比特币网络进行任何联系或注册。可以使用免费的软件工具创建大量离线地址。生成大量地址在几个场景很有用，比如电子商务网站，为每个选择“用比特币支付”选项的客户提供一个唯一的预先生成的地址。较新的“HD钱包”可以生成一个“种子”令牌，可以用来让不受信任的系统(如webservers)生成无限数量的地址，而无需花费接收到的比特币。\n\n#### 地址通常是区分大小写和准确的\n旧式的比特币地址是大小写敏感的。比特币的地址应该尽可能地使用电脑的剪贴板复制和粘贴。如果你手工键入一个比特币地址，而每个字符都没有被准确地转录(包括大写)，那么不正确的地址很可能会被比特币软件拒绝。你必须检查你的条目，然后再试一次。一个输入错误的地址被接受为有效的概率是1 / 232，也就是大约1 / 42.9亿。新型bech32地址不区分大小写。\n\n#### 证明你收到了一个地址\n大多数比特币钱包都有一个“签名”信息的功能，这可以证明接收资金的实体已经同意该信息。例如，这可以用于在支付合同之前，以一种加密的可验证的方式确定合同。\n有些服务还将利用这种功能，只指定一个特定的地址进行身份验证，在这种情况下，该地址永远不应该用于实际的比特币交易。当您登录或使用他们的服务时，您将提供一个签名，证明您与预先商定的地址相同。\n值得注意的是，这些签名仅仅证明一个人收到了一个地址。由于比特币交易没有“来自”地址，你无法证明你是资金的发送者。\n目前的消息签名标准仅与“0版本”的比特币地址(以数字1开头)兼容。\n\n#### 地址验证\n如果希望在应用程序中验证比特币地址，建议使用[这个线程中](https://bitcointalk.org/index.php?topic=1026.0)的方法，而不是只检查字符串长度、允许的字符，或者地址以1或3开头。验证还可以使用[各种语言](http://rosettacode.org/wiki/Bitcoin/address_validation)的开放源代码或使用[在线验证工具](http://lenschulwitz.com/base58)进行。\n\n#### 多重签名的地址\n可以创建需要多个私钥组合的地址。由于它们利用了较新的特性，所以它们以较新的前缀3而不是旧的1开始。这可以被看作是向两方开出支票——“支付给某人和其他人的订单”——双方必须在支票上签字以获得资金。\n必须满足的实际需求(所需的私钥数量、相应的公钥等)是由生成此类地址的人预先决定的，一旦创建了地址，就不能在不生成新地址的情况下更改该需求。\n\n#### 一个地址里有什么\n大多数比特币的地址是34个字符。它们由随机数字、大写字母和小写字母组成，除了大写字母“O”、大写字母“I”、小写字母“l”和数字“0”从未使用来避免视觉上的歧义。\n一些比特币地址可以短于34个字符(少到26个字符)，但仍然有效。相当大比例的比特币地址只有33个字符，有些甚至可能更短。每个比特币地址代表一个数字。这些较短的地址是有效的，因为它们代表的是恰好以0开头的数字，当这些0被省略时，编码的地址就会变短。\n比特币地址中有几个字符被用作校验和，因此可以自动查找和拒绝排版错误。校验和还允许比特币软件确认一个33个字符(或更短)的地址实际上是有效的，而不是一个缺少字符的地址。\n\n#### 测试网络\n比特币Testnet上的地址是用不同的地址版本生成的，这会产生不同的前缀。有关详细信息，请参阅地址前缀和Testnet列表。\n\n### 误解\n\n#### 地址重用\n地址不打算被使用多次，这样做有许多相关的问题。有关地址重用的详细信息，请参阅专门的文章。\n\n#### 地址余额\n地址不是钱包或账户，也没有余额。他们只收钱，而你在任何时候都不发送“从”地址。各种混乱的服务和软件显示'用一个地址接收比特币',从随机不相关的交易中减去已发送的比特币作为一个'地址余额',但这个数字是没有意义的:它并不意味着向这个地址发送的比特币的接收者已经花掉了它们，也不意味着他们仍然持有接收的比特币。\n这种误解造成比特币损失的一个例子是，人们认为他们的地址包含3btc。他们花了0.5比特币，认为地址现在包含2.5比特币，而实际上它包含零比特币。剩余的2.5比特币被转移到一个没有备份的更改地址，因此丢失。这发生在一些使用纸质钱包的用户的场合。\n\n#### “从“地址\n比特币交易没有任何来源——来源——或“来自”地址。有关“来自地址”的详细信息，请参阅专门的文章。\n\n#### 地址图\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S43U7xMP-1625627005514)(https://en.bitcoin.it/w/images/en/4/48/Address_map.jpg)]\n","tags":["区块链","Bitcoin"],"categories":["区块链"]},{"title":"Linux服务器常用命令","url":"/2018/07/6e2872c17d01/","content":"我常用到的是这几个：\n<!--more--> \n### systemctl\n- systemctl status name.service\n   查看某个服务的状态\n- systemctl | grep name-partern\n   过滤显示所有服务名符合name-partern的服务\n- systemctl enable name.service\n   设置开机自启\n- systemctl restart name.service\n  重启服务\n\n### journalctl\n- journalctl -f -u unit-name\n  实时查看某个服务的log\n- journalctl --since 18:34 --until 19:12 -u unit-name\n  查看某个服务在该时间段内的log\n- journactl --since '2018-07-29 19:00' --until now -u unit-name\n  查看时间段内的日志\n\n### grep\n- grep -E 'regex'\n  根据正则表达式过滤\n- grep -w 'wrod'\n  根据单词word过滤\n- grep -c 'target'\n  显示过滤后的行数\n\n### tail\n- tail -n 2000 file.name\n  显示文件末尾的2000行内容\n- tail -f file.name\n  实时显示文件最新追加的内容\n- tail -s 1\n  显示内容刷新时间间隔为1秒\n\n### ls\n- ls -l\n  以列表形式显示\n- ls -a\n  显示所有文件\n- ls -h\n  以便于阅读的方式显示\n- ls -S\n  按照文件大小排序\n\n### vi\n- :set nu\n  显示行号\n- :set nonu\n  隐藏行号\n- 0\n  移动光标到行首\n- $\n  移动光标到行尾\n- gg\n  移动光标到内容开头\n- G\n  移动光标到内容结束\n- dd\n  删除行\n- x\n  删除一个字符\n- r\n  替换一个字符\n- R\n  一直替换\n- u\n  撤销上次操作\n- 10 j\n  向下移动光标10行\n- /c[ok]\\\\{1\\\\}mplete\n  查找complete\n","tags":["Linux"],"categories":["Linux"]},{"title":"持续集成与自动化测试 Continuous Integration，CI","url":"/2018/05/262671d24b2e/","content":"\n> 所谓持续集成与自动化，是指用机器替代人工持续不间断地集成代码，让产品可以快速迭代，同时还能保证代码质量。一个完整的持续集成环境需要Jenkins与Git、Gerrit一起配合，才能发挥出它最强大的功能。一般来说，在开发者Push代码后会首先到Gerrit进行代码Review。Review分为两部分，一部分是使用程序的自动化Review，主要是通过静态代码检测工具来进行代码质量分析（比如Sonar、CheckStyle、FindBugs等）；另一部分是人工Review，主要检测代码的运行逻辑，当Review完毕后，通过Git hook、Jenkins完成代码的自动拉取、编译和部署，最后通过自动化测试工具完成测试用例，并生成相应的测试报表。这样一整个测试流程需要人工来做的也就是人工代码Review部分，而其他部分全部通过自动化来实现，甚至可以在半夜对程序进行不间断Monkey测试，测试稳定性和潜在问题。\n<!--more--> \n**摘自《Android群英传：神兵利器》**","tags":["Android","CI"],"categories":["Android"]},{"title":"Java继承机制的弊端","url":"/2018/05/d71d19b7fe7b/","content":"\n转载，原文链接:http://www.sunxin.org/forum/thread/20672.html# \n\n为什么Java中继承多数是有害的 \n<!--more--> \n大多数好的设计者象躲避瘟疫一样来避免使用实现继承(`extends` 关系)。实际上80%的代码应该完全用`interface`写,而不是通过`extends`。Java设计模式一书详细阐述了怎样用接口继承代替实现继承。这篇文章描述设计者为什么会这么作。 \n\n`Extends`是有害的;也许对于*Charles Manson*这个级别的不是,但是足够糟糕的它应该在任何可能的时候被避开。JAVA设计模式一书花了很大的部分讨论用`interface`继承代替实现继承。 \n\n好的设计者在他的代码中,大部分用`interface`,而不是具体的基类。本文讨论为什么设计者会这样选择,并且也介绍一些基于`interface`的编程基础。 \n\n- 接口(`Interface`)和类(`Class`)? \n\n一次,我参加一个Java用户组的会议。在会议中,*Jams Gosling*(Java之父)做发起人讲话。在那令人难忘的Q&A部分中,有人问他:如果你重新构造Java,你想改变什么?。我想抛弃classes他回答。在笑声平息后,它解释说,真正的问题不是由于class本身,而是实现继承(`extends`) 关系。接口继承(`implements`关系)是更好的。你应该尽可能的避免实现继承。 \n\n- 失去了灵活性 \n\n为什么你应该避免实现继承呢?第一个问题是明确的使用具体类名将你固定到特定的实现,给底层的改变增加了不必要的困难。 \n\n在当前的敏捷编程方法中,核心是并行的设计和开发的概念。在你详细设计程序前,你开始编程。这个技术不同于传统方法的形式----传统的方式是设计应该在编码开始前完成----但是许多成功的项目已经证明你能够更快速的开发高质量代码,相对于传统的按部就班的方法。但是在并行开发的核心是主张灵活性。你不得不以某一种方式写你的代码以至于最新发现的需求能够尽可能没有痛苦的合并到已有的代码中。 \n\n胜于实现你也许需要的特征,你只需实现你明确需要的特征,而且适度的对变化的包容。如果你没有这种灵活,并行的开发,那简直不可能。 \n\n对于`Inteface`的编程是灵活结构的核心。为了说明为什么,让我们看一下当使用它们的时候,会发生什么。考虑下面的代码: \n```Java\nf() { \n\tLinkedList list = new LinkedList(); \n\tg(list); \n} \ng(LinkedList list) { \n\tlist.add( ... ); \n\tg2(list) ;\n} \n```\n假设一个对于快速查询的需求被提出,以至于这个`LinkedList`不能够解决。你需要用`HashSet`来代替它。在已有代码中,变化不能够局部化,因为你不仅仅需要修改`f()`也需要修改`g()`(它带有`LinkedList`参数),并且还有`g()`把列表传递给的任何代码。像下面这样重写代码: \n```Java\nf() { \n\tCollection list = new LinkedList(); \n\tg(list); \n} \ng(Collection list) { \n\tlist.add(...); \n\tg2(list);\n} \n```\n这样修改Linked list成hash,可能只是简单的用new HashSet()代替new LinkedList()。就这样。没有其他的需要修改的地方。 \n\n作为另一个例子,比较下面两段代码: \n```Java\nf() { \n\tCollection c = new HashSet(); \n\t//... \n\tg( c ); \n} \ng(Collection c) { \n\tfor(Iterator i = c.iterator(); i.hasNext()) \n\t\tdo_something_with(i.next()); \n} \nf2() { \n\tCollection c = new HashSet(); \n\t//... \n\tg2( c.iterator() ); \n} \ng2(Iterator i) { \n\twhile(i.hasNext()) \n\t\tdo_something_with(i.next()); \n} \n```\n\n`g2()`方法现在能够遍历`Collection`的派生,就像你能够从`Map`中得到的键值对。事实上,你能够写`iterator`,它产生数据,代替遍历一个`Collection`。你能够写`iterator`,它从测试的框架或者文件中得到信息。这会有巨大的灵活性。 \n\n- 耦合 \n\n对于实现继承,一个更加关键的问题是耦合---令人烦躁的依赖,就是那种程序的一部分对于另一部分的依赖。全局变量提供经典的例子,证明为什么强耦合会引起麻烦。例如,如果你改变全局变量的类型,那么所有用到这个变量的函数也许都被影响,所以所有这些代码都要被检查,变更和重新测试。而且,所有用到这个变量的函数通过这个变量相互耦合。也就是,如果一个变量值在难以使用的时候被改变,一个函数也许就不正确的影响了另一个函数的行为。这个问题显著的隐藏于多线程的程序。 \n\n作为一个设计者,你应该努力最小化耦合关系。你不能一并消除耦合,因为从一个类的对象到另一个类的对象的方法调用是一个松耦合的形式。你不可能有一个程序,它没有任何的耦合。然而,你能够通过遵守OO规则,最小化一定的耦合(最重要的是,一个对象的实现应该完全隐藏于使用他的对象)。例如,一个对象的实例变量(不是常量的成员域),应该总是`private`。我意思是某段时期的,无例外的,不断的。(你能够偶尔有效地使用`protected`方法,但是`protected`实例变量是可憎的事)同样的原因你应该不用get/set函数---他们对于是一个域公用只是使人感到过于复杂的方式(尽管返回修饰的对象而不是基本类型值的访问函数是在某些情况下是由原因的,那种情况下,返回的对象类是一个在设计时的关键抽象)。 \n\n这里,我不是书生气。在我自己的工作中,我发现一个直接的相互关系在我OO方法的严格之间,快速代码开发和容易的代码实现。无论什么时候我违反中心的OO原则,如实现隐藏,我结果重写那个代码(一般因为代码是不可调试的)。我没有时间重写代码,所以我遵循那些规则。我关心的完全实用?我对干净的原因没有兴趣。 \n\n- 脆弱的基类问题 \n\n现在,让我们应用耦合的概念到继承。在一个用`extends`的继承实现系统中,派生类是非常紧密的和基类耦合,当且这种紧密的连接是不期望的。设计者已经应用了绰号脆弱的基类问题去描述这个行为。基础类被认为是脆弱的是,因为你在看起来安全的情况下修改基类,但是当从派生类继承时,新的行为也许引起派生类出现功能紊乱。你不能通过简单的在隔离下检查基类的方法来分辨基类的变化是安全的;而是你也必须看(和测试)所有派生类。而且,你必须检查所有的代码,它们也用在基类和派生类对象中,因为这个代码也许被新的行为所打破。一个对于基础类的简单变化可能导致整个程序不可操作。 \n\n让我们一起检查脆弱的基类和基类耦合的问题。下面的类`extends`了Java的`ArrayList`类去使它像一个`stack`来运转: \n```Java\nclass Stack extends ArrayList { \n\tprivate int stack_pointer = 0; \n\tpublic void push( Object article ) { \n\t\tadd( stack_pointer++, article ); \n\t} \n\tpublic Object pop() { \n\t\treturn remove( --stack_pointer ); \n\t} \n\tpublic void push_many( Object[] articles ) { \n\t\tfor( int i = 0; i < articles.length; ++i ) \n\t\t\tpush( articles[i] ); \n\t} \n} \n```\n甚至一个象这样简单的类也有问题。思考当一个用户平衡继承和用`ArrayList`的`clear()`方法去弹出堆栈时: \n```java\nStack a_stack = new Stack(); \na_stack.push(\"1\"); \na_stack.push(\"2\"); \na_stack.clear(); \n```\n这个代码成功编译,但是因为基类不知道关于`stack`指针堆栈的情况,这个`stack`对象当前在一个未定义的状态。下一个对于`push()`调用把新的项放入索引2的位置。(`stack_pointer`的当前值),所以`stack`有效地有三个元素-下边两个是垃圾。(Java的stack类正是有这个问题,不要用它). \n\n对这个令人讨厌的继承的方法问题的解决办法是为`Stack`覆盖所有的`ArrayList`方法,那能够修改数组的状态,所以覆盖正确的操作`Stack`指针或者抛出一个例外。(`removeRange()`方法对于抛出一个例外一个好的候选方法)。 \n\n这个方法有两个缺点。第一,如果你覆盖了所有的东西,这个基类应该真正的是一个`interface`,而不是一个`class`。如果你不用任何继承方法,在实现继承中就没有这一点。第二,更重要的是,你不能够让一个`stack`支持所有的`ArrayList`方法。例如,令人烦恼的`removeRange()`没有什么作用。唯一实现无用方法的合理的途径是使它抛出一个例外,因为它应该永远不被调用。这个方法有效的把编译错误成为运行错误。不好的方法是,如果方法只是不被定义,编译器会输出一个方法未找到的错误。如果方法存在,但是抛出一个例外,你只有在程序真正的运行时,你才能够发现调用错误。 \n\n对于这个基类问题的一个更好的解决办法是封装数据结构代替用继承。这是新的和改进的Stack的版本: \n```Java\nclass Stack { \n\tprivate int stack_pointer = 0; \n\tprivate ArrayList the_data = new ArrayList(); \n\tpublic void push( Object article ) { \n\t\tthe_data.add( stack_poniter++, article ); \n\t} \n\tpublic Object pop() { \n\t\treturn the_data.remove( --stack_pointer ); \n\t} \n\tpublic void push_many( Object[] articles ) { \n\t\tfor( int i = 0; i < o.length; ++i ) \n\t\t\tpush( articles[i] ); \n\t} \n} \n```\n到现在为止,一直都不错,但是考虑脆弱的基类问题,我们说你想要在`stack`创建一个变量, 用它在一段周期内跟踪最大的堆栈尺寸。一个可能的实现也许象下面这样: \n```Java\nclass Monitorable_stack extends Stack { \n\tprivate int high_water_mark = 0; \n\tprivate int current_size; \n\tpublic void push( Object article ) { \n\t\tif( ++current_size > high_water_mark ) \n\t\t\thigh_water_mark = current_size; \n\t\tsuper.push( article ); \n\t} \n\tpublish Object pop() { \n\t\t--current_size; \n\t\treturn super.pop(); \n\t} \n\tpublic int maximum_size_so_far() { \n\t\treturn high_water_mark; \n\t} \n} \n```\n这个新类运行的很好,至少是一段时间。不幸的是,这个代码发掘了一个事实,`push_many()`通过调用`push()`来运行。首先,这个细节看起来不是一个坏的选择。它简化了代码,并且你能够得到`push()`的派生类版本,甚至当`Monitorable_stack`通过Stack的参考来访问的时候,以至于`high_water_mark`能够正确的更新。 \n","tags":["Android","Java"],"categories":["Android"]},{"title":"Android使用netty框架配置SSL适配7.0以上的系统","url":"/2018/05/5483a3584872/","content":"\n最近项目在使用的netty框架加上了SSL安全设置，SSL可单项验证也可双向验证，我使用的是双向验证，即Client验证Server同时Server也验证Client。\n以下只说明Client（Android）端的实现方式。\n<!--more--> \n- 首先需要两个文件，`client.p12`和`cacert.pem`，由服务器端提供。\n- 使用java的`keytool`工具将`cacert.pem`导入到keystore中\n```shell\n$ keytool -import -trustcacerts -keystore /Users/xxx/server.bks -file /Users/xxx/cacert.pem -storetype BKS -provider org.bouncycastle.jce.provider.BouncyCastleProvider\n```\n\n记住这个命令执行后要求输入的密码。\n*（其中的org.bouncycastle.jce.provider.BouncyCastleProvider如何添加使用自行百度即可。）*\n\n- 现在已经有了两个文件`client.p12`和`server.bks`\n- 准备完成，下面进行java实现。\n```java\npublic SSLContext createSSLContext(Context context) {\n        SSLContext sslContext = null;\n        try {\n\t        // 该密码为生成client.p12时设置的密码\n            String keyPassword = \"\";\n            // 该密码为生成server.bks时设置的密码\n            String trustPassword = \"\";\n            \n            // key store manager\n            KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n            InputStream keyInput = context.getResources().openRawResource(R.raw.client);\n            keyStore.load(keyInput, keyPassword.toCharArray());\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyPassword.toCharArray());\n            \n            // trust store manager\n            KeyStore trustStore = KeyStore.getInstance(\"BKS\");\n            InputStream trustInput = context.getResources().openRawResource(R.raw.server);\n            trustStore.load(trustInput, trustPassword.toCharArray());\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            trustManagerFactory.init(trustStore);\n            \n            // assemble\n            sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return sslContext;\n    }\n```\n\n- 接下来配置netty中的SSL\n```java\nclass ClientInitializer extends ChannelInitializer<SocketChannel> {\n\n        private SSLContext mSslContext;\n\n        public ClientInitializer(SSLContext sslContext) {\n            mSslContext = sslContext;\n        }\n        \n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n            ChannelPipeline pipeline = ch.pipeline();\n            SSLEngine sslEngine = mSslContext.createSSLEngine();\n            sslEngine.setUseClientMode(true);\n            pipeline.addFirst(\"ssl\", new SslHandler(sslEngine));\n            pipeline.addLast(\"decoder\", new ClientDecoder());\n            pipeline.addLast(\"encoder\", new ClientEncoder());\n            pipeline.addLast(\"handler\", new ClientHandler());\n\n        }\n    }\n```\n\n- 至此，所有工作就完成了，以上标准配置在android7.0以下的机器上均可正常运行，但是一旦运行到7.0及以上的机器上就会报错\n```java\njavax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found.\n        at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:374)\n        at libcore.net.http.HttpConnection.setupSecureSocket(HttpConnection.java:209)\n        at libcore.net.http.HttpsURLConnectionImpl$HttpsEngine.makeSslConnection(HttpsURLConnectionImpl.java:478)\n        at libcore.net.http.HttpsURLConnectionImpl$HttpsEngine.connect(HttpsURLConnectionImpl.java:433)\n        at libcore.net.http.HttpEngine.sendSocketRequest(HttpEngine.java:290)\n        at libcore.net.http.HttpEngine.sendRequest(HttpEngine.java:240)\n        at libcore.net.http.HttpURLConnectionImpl.getResponse(HttpURLConnectionImpl.java:282)\n        at libcore.net.http.HttpURLConnectionImpl.getInputStream(HttpURLConnectionImpl.java:177)\n        at libcore.net.http.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:271)\n```\n\n经过一番查询验证，在官网上找到了解决办法，[原链接](https://developer.android.google.cn/training/articles/security-ssl#CommonProblems)-不需翻墙即可访问。\n\n**解决方式如下**\n\n- 和服务器端再要一个文件`server.crt`。\n- 准备完成，下面修改java实现\n```java\npublic SSLContext createSSLContext(Context context) {\n        SSLContext sslContext = null;\n        try {\n            String keyPassword = \"\";\n\n             // key store manager\n            KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n            InputStream keyInput = context.getResources().openRawResource(R.raw.client);\n            keyStore.load(keyInput, keyPassword.toCharArray());\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyPassword.toCharArray());\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(keyStore, keyPassword.toCharArray());\n\n            // trust store manager\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            InputStream caInput = context.getResources().openRawResource(R.raw.server);\n            Certificate ca;\n            try {\n                ca = cf.generateCertificate(caInput);\n            } finally {\n                caInput.close();\n            }\n            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            trustStore.load(null, null);\n            trustStore.setCertificateEntry(\"CA\", ca);\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n            trustManagerFactory.init(trustStore);\n\n            // assemble\n            sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return sslContext;\n    }\n```\n**只需要修改`trust store`的创建方式，其他不需要改动。经过以上修改，程序在所有版本的机器上都可以正常运行了！棒**\n","tags":["Android","Netty"],"categories":["Android"]},{"title":"MySql的modify和change区别","url":"/2018/04/c9ea6aa5bbde/","content":"\n- 相同点：都是用来改变column的属性，change和modify执行成功后都会用本次设置的属性替换column原属性，请注意是【替换】；\n- 不同点：重命名只能使用change\n<!--more--> \n格式（mysql默认不区分大小写）\n\n 1 change\n```\nalter table table_name change current_column_name new_column_name type extra;\n// for example.（如果是改名字需要把column原属性都挂上，因为是替换）\nalter table user change id userid int(11) not null auto_increment;\n```\n 2 modify\n \n\n```\nalter table table_name modify column_name type extra;\n// for example\nalter table user modify id int(11) not null auto_increment;\n```","tags":["MySql"],"categories":["MySql"]},{"title":"「巧用Gradle构建Android应用」读书整理","url":"/2018/04/23aff262eba5/","content":"\n周末看完了「巧用Gradle构建Android应用」，故将新认知整理在此以便以后供自己以及有需要的人查看。\n<!--more--> \nGradle\n\n- Gradle构建过程实际上是执行DAG(Directed Acyclic Graph，有向无环图)，允许定义自己的task并插入到其中。\n  build.gradle中Android块时Android DSL()的入口。\n- 依赖的语法\n```groovy\n//完整语法 (禁用传递依赖)\ntestCompile group: 'junit', name: 'junit', version: '4.12'， transitive: false \n//排除依赖\nandroidTestCompile('org.splckframeword:spock-core:1.0-groovy-2.4') {\n\texclude group: 'org.codehaus.groovy'\n\texclude group: 'junit'\n}\n```\n\n- 配置仓库\n```groovy\nrepositories {\n\tmaven {\n\t// 其中的username值和password值可以写在gradle.properties或者在执行gradlew命令时以参数输入\n\t// ./gradlew -Puser=user_from_pFlag -Ppass=pass_from_pFlag\n\t\tusername 'username'\n\t\tpassword 'password'\n\t}\n\turl 'http://repo.mycompany.com/maven2'\n}\n// 还可以在ext块中配置\next {\n\tif (!project.hasProperty('user')) {\n\t\tdef username = 'alice'\n\t}\n\tif (!project.hasProperty('pass')) {\n\t\tdef password = 'passpass'\n\t}\n}\n```\n\n- 升级Gradle版本\n```groovy\n// 方法一\ntask wrapper(type: Wrapper) {\n\tgradleVersion = 2.12\n}\n./gradlew wrapper\n// 方法二：直接修改gradle-wrapper.properties文件的distributionUrl属性。\n```\n\n- 签名\n```groovy\nandroid {\n\t// ...other section...\n\tsigningConfigs {\n\t\trelease {\n\t\t\tkeyAlias 'my_alias'\n\t\t\tkeyPassword 'password'\n\t\t\tstoreFile file('/Users/kousen/keystores/myapp.ketstore')\n\t\t\tstorePassword 'password'\n\t\t}\n\t}\n}\n// 同样，密码可以放到gradle.properties中，或者以gradlew的参数输入\n```\n\n- 构建类型\n```groovy\nbuildTypes {\n// 加后缀区分可同时安装在同一设备上\n\tdebug {\n\t\tapplicationIdSuffix '.debug'\n\t\tversionNameSuffix '-debug'\n\t}\n}\n```\n\n- 产品定制&纬度\n```groovy\nandroid {\n\tproductFlavors {\n\t\tarrogant {\n\t\t\tdimension 'attitude'\n\t\t\tapplicationId 'com.oreilly.helloword.arrg'\n\t\t}\n\t\tfriendly {\n\t\t\tdimension 'attitude'\n\t\t\tapplicationId 'com.oreilly.helloword.fund'\n\t\t}\n\t\tstark {\n\t\t\tdimension 'client'\n\t\t}\n\t}\n}\n```\n\n- 自定义任务。Grale的DSL API已经存在很多任务，如Copy、Wrapper和Exec等，这些任务可以简单地设置属性然后使用。比如Copy任务所包含的from和into属性。\n```groovy\n// 复制任务\ntask copyApks(type: Copy) {\n\tfrom(\"$buildDir/outputs/apk\") {\n\t\texclude '**/*unsigned.apk', '**/*unaligned.apk'\n\t}\n\tinto '../apks'\n}\n// 显示所有可用任务的变种。这个任务中无论在doLast之前还是之后的所有事情都是在配置阶段执行，\n// doLast块中的代码在运行阶段执行\n// applicationVariants属性只针对com.android.application插件有效\n// libraryVariants属性只针对com.android.library插件有效\ntask printVariantNames() {\n\tdoLast {\n\t\tandroid.applicationVariants.all { variant ->\n\t\t\tprintln variant.name\n\t\t}\n\t}\n}\n// 执行安装所有应用的变种的任务\n// dependsOn属性显示这是配置阶段的一部分，而不是运行阶段。每一个变种名字都被首字母大写了\n// 并且相应的安装任务也被添加到installDebugFlavors任务的一个依赖\ntask installDebugFlavors() {\n\tandroid.applicationVariants.all { v ->\n\t\tif (v.name.endWiths('Debug')) {\n\t\t\tString name = v.name.capitalize()\n\t\t\tdependsOn \"install$name\"\n\t\t}\n\t}\n}\n```\n\n- 延长ADB超时时长\n```groovy\n// 30秒\nandroid {\n\tadbOptions {\n\t\ttimeOutInMs = 30 * 1000\n\t}\n}\n```\n\n- 添加自定义任务到构建过程\n```groovy\n// 基于assembleDebug的依赖意味着在运行copy任务之前所有调试APK都会被生成。\ntask copyApks (type: Copy, dependsOn: assembleDebug) {\n\tfrom(\"$buildDir/outputs/apk\") {\n\t\texclude '**/*unsigned.apk', '**/*unsigned.apk'\n\t}\n\tinto '../apks'\n}\n// 如果想要在每次构建的时候都运行copyApks任务，将其作为build任务的一个依赖\nbuild.dependsOn copyApks\n```\n\n- 排除任务\n```groovy\n> ./gradlw build -x lint\n// Gradle运行时，其组装了一个task graph，通过gradle获得这个图的饮用，所有对这个图的操纵都需要发生\n// 在其构建出来之后，所以需要使用whenReady属性\ngradle.taskGraph.whenReady { graph ->\n\tif (project.hasProperty('nolint')) {\n\t\tgraph.allTask.findAll {\n\t\t\tit.name ==~/lint.*/}*.enabled = false\n\t\t}\n\t}\n}\n```\n\n- 性能\n```groovy\n// gradle.properties\n// 守护进程\norg.gradle.daemon=true\n// 按需配置设置\norg.gradle.configureondemand=true\n// 选择JVM设置 Xmx最大内存 Xms初始内存 XX:MaxPermSize永代久空间 \n// HeapDumpOnOutOfMemoryError发生时，将堆中情况导出到一个文件中\norg.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError\n\n// 使用dex选项\ndexOptions {\n\tincremental true\n\tjavaMaxHeapSize '2g'\n\tjumboMode = true//运载dex文件中出现的大量字符串，可能需要配置ProdGuard\n\tpreDexLibraries = true\n} \n```","tags":["Android","Gradle"],"categories":["读书笔记"]},{"title":"gradle各个版本资源","url":"/2017/12/22d73a690578/","content":"\ngradle官网下载地址:[点击跳转](http://services.gradle.org/distributions/)\n\n但是这个网站有时需要翻墙有时下载速度慢，趁着现在翻墙方便一次性将上面的里程碑版本下了下来\n<!--more--> \n链接: https://pan.baidu.com/s/1i4Fm9Q9 密码: cjfd\n\n**最新更新日期:2017-12-22 18:17:06**(如果想的起来就更新)\n\nps: 如有小更新版本需求, 邮箱联系 : oynix@foxmail.com\n\n\n---\n**如何使用**\n\n当用AndroidStudio打开一个项目长时间卡在build页面，多半是项目所需要版本的gradle在本地没有，AS去上面那个网址下却又下不来。操作如下:\n\n1. 关闭AS, 找到项目所使用gradle的版本, 打开**项目根目录/gradle/wrapper/gradle-wrapper.properties**文件, 里面的**distributionUrl**就是;\n2. 将下载好的对应版本的gradle的zip压缩包复制到gradle本地路径, Windows和Mac相同, **~/.gradle/wrapper/dists/{项目使用的版本}/{一串数字字母的名字}/**, 如果该目录存在则直接替换, 复制完直接将zip解压到当前文件夹, 即解压到**{一串数字字母的名字}**文件夹下, 完成后重新打开AS即可.\n","tags":["Android","Gradle"],"categories":["Android"]},{"title":"HelloKotlin - Error:Gradle-failed to create directory","url":"/2017/12/11b68604d6b4/","content":"---\n今天在看Kotlin-Docs，于是随手建了一个HelloKotlin的项目准备练练手，于是引发了一连串的问题。在此记录过程。\n\n<!--more-->\n\n**环境**\n\n - Windows 7 64bit\n - AndroidStudio 3.0.1\n \n---\n一般的，像下面这样，直接写一个程序入口main函数，跑一些简单代码时不用构建apk省时省力：\n![](https://i.loli.net/2021/07/07/5vgDVB4MTyKipoW.png)\n\n同样的，我想创建一个Kotlin的程序入口。\n创建项目时勾选上Kotlin，AndroidStudio便自动导入Kotlin环境，然后直接新建了一个Hello.kt的文件，里面代码很简单，只有三行，如下：\n\n```kotlin\nfun main(args: Array<String>) {\n\tSystem.out.print(\"Hello Kotlin\")\n}\n```\n**fun**单词前有个彩色的Kotlin Logo，直接点击就可以运行HelloKotlin（按道理这样就可以正常跑起来了，我是这么以为的），**但是，报了下面这个错误**：\n![](https://i.loli.net/2021/07/07/g7Jp9tOwETl6diU.png)\n\n在网上搜索**Error:Gradle:failed to create directory**一番后，找到了解决办法，原来是新版AndroidStudio自带的Aapt2引起的，直接禁用就好：在**gradle.properties**添加如下配置即可：\n\n```\nandroid.enableAapt2=false\n```\n\n再次点击**fun**前面的彩色Kotlin Logo，我以为可以运行了，**但是，又报了下面这个错误**：\n![](https://i.loli.net/2021/07/07/uxXfnlNcjMZeOmP.png)\n\n**IDE说找不到HelloKt.class，然而勤劳的我却凭借双手找到了，措不及防**\n![](https://i.loli.net/2021/07/07/b4U69Lmts1A2qBn.png)\n<br>\n这下我就有点不知所措了。。。\n网上也没查出什么相关参考，又试了几种不同的写法，依然不行，最后不知怎么突然想到修改Gradle版本试试看，事实证明此路可行！\nAndroidStudio 3.0.1创建新项目默认的Gradle版本时4.1，Android Plugin Version是3.0.1。我把HelloKotlin项目向下降了一个版本，即Gradle-3.4，Android Plugin - 2.3.3，去掉DSL method google()\n![](https://i.loli.net/2021/07/07/7LJtogyjH4Od3GV.png)\n\n相应的，Module的build.gradle里一些版本都要下调。\n\n```groovy\n// 部分内容\nandroid {\n    compileSdkVersion 25\n    buildToolsVersion '25.0.3'\n    defaultConfig {\n        applicationId \"com.oy.hellokot\"\n        minSdkVersion 15\n        targetSdkVersion 25\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    ...\n}\n\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile\"org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version\"\n    compile 'com.android.support:appcompat-v7:25.3.1'\n    compile 'com.android.support.constraint:constraint-layout:1.0.2'\n    testCompile 'junit:junit:4.12'\n    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'\n}\n```\n\n如上配置以后，再次点击**fun**之前的彩色Kotlin Logo，程序便可以跑起来了。","tags":["AndroidStudio","Kotlin"],"categories":["Kotlin"]},{"title":"Windows下编译OpenSSL","url":"/2017/11/0d432f214850/","content":"---\n\n今天为了获取FB秘钥，里面有个命令openssl，于是网上找了一下教程，众说纷纭，最后可算成功了，在此记录过程。\n<!--more-->\n#### **环境**\n - Windows 64位\n - 已安装Visual Studio 2017 社区版（已过期不过没影响）\n - 已安装Active Perl v5.16.2\n\n#### **准备源码**\n - [OpenSSL官网](https://www.openssl.org/)\n - 或者直接用文中所用的 :  https://pan.baidu.com/s/1pL0vDhx 密码: hndw\n\n---\n#### **过程**\n1. 在Microsoft Visual Studio目录下搜索**vcvarsall.bat**并进入所在目录。\n![](https://i.loli.net/2021/07/07/hbDj3oUKWFLJfuq.png)\n2. 在所在目录下打开cmd，运行`vcvarsall.bat x86_amd64`\n\n\t```sh\n\tC:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Auxiliary\\Build>vcvarsall.bat x86_amd64\n\t[vcvarsall.bat] Environment initialized for: 'x86_x64'\n\t```\n3.  cmd切换到解压完的OpenSSL源码目录运行\n\n\t```sh\nC:\\Users\\it\\Desktop\\openssl-1.0.2m>perl Configure VC-WIN64A\n\t```\n4. 继续运行\n\n\t```sh\nC:\\Users\\it\\Desktop\\openssl-1.0.2m>ms\\do_win64a\n\t```\n5. 继续执行，这步在我的电脑上跑了好几分钟\n\n\t```sh\nC:\\Users\\it\\Desktop\\openssl-1.0.2m>nmake -f ms\\nt.mak \n\t```\n6. 继续执行。执行完第六步之后，编译好的OpenSSL就复制到了`\\usr\\local\\ssl\\lib`路径下，我是在桌面编译的，所以在C盘根目录\n\n\t```sh\nC:\\Users\\it\\Desktop\\openssl-1.0.2m>nmake -f ms\\nt.mak install\n\t```\n\n7. 将OpenSSL路径`C:\\usr\\local\\ssl\\bin`添加到系统路径path里\n\n8. 打开一个新的cmd窗口，运行openssl命令，如图表明成功\n![](https://i.loli.net/2021/07/07/UHcXsjCJErxna65.png)\n\n---\n#### **注意**\n第2步到第3步要在同一个cmd窗口里运行。开始运行第5步不管用，总提示找不到nmake命令，我就直接把nmake.exe（Microsoft Visual Studio目录下搜索到的，同步骤1）直接放到系统路径里了，可以运行，后来发现2、 3只要在同一个cmd窗口就可以了。\n","tags":["Windows","OpenSSL"],"categories":["OpenSSL"]},{"title":"「Effective Java」读书整理","url":"/2017/11/29c00d69eefc/","content":"---\n书地址 ：链接: https://pan.baidu.com/s/1kUAwYgv 密码: ij4j\n<!--more-->\n###  - Chapter 3 适用于所有对象\n#### **8. 重写`equals`方法**\n> 三个原则：对称性、传递性、一致性\n\n#### **9. 重写`equals`方法必定要重写`hashCode`方法**\n> 例如在HashMap中存储时会调用该方法\n\n#### **10. 始终要重写`toString`方法**\n> 便于阅读，使类用起来更加舒适\n\n#### **11. 谨慎的覆盖`clone`方法**\n> 相当于另一个构造器\n\n#### **12. 考虑实现Comparable接口**\n> 用于对象比较、排序（在集合里sort）\n\n----\n\n### - Chapter 4 类和接口\n#### **13. 使类和成员的可访问性最小化(encapsulation)**\n```java\n// 错误方式,安全漏洞; \n// 当域为基本类型或不可变对象时安全;\n// 当为可变对象的引用时存在安全漏洞, VALUE虽不可修改但数组里的对象可被修改\npublic static final Thing[] VALUE = {....};\n// 正确方式\nprivate static final Thing[] PRIVATE_VALUES = {...};\npublic static final List<Thing> VALUES = Collections.unodifiableList(Arrays.asList(PRIVATE_VALUES));\n```\n#### **14. 在公有类中使用访问方法而非公有域**\n> 总有类永远不应该暴露可变域\n\n#### **15. 使可变性最小化**\n成为不可变类的5条规则 :\n\n 1. 不要提供任何会修改对象状态的方法;\n 2. 保证类不会被扩展(fina);\n 3. 使所有域都是final的;\n 4. 使所有域都成为私有的;\n 5. 确保对于任何可变组件的互斥访问.\n\n#### **16. 复合优先于继承**\n> 当B和A的关系为\"is-a\"时，让B继承自A；否则B中应包含一个A的实例（复合），而不是扩展A（继承）。\n\n#### **17. 要么为继承而设计，并提供文档说明， 要么就禁止继承**\n> 1>. 关于程序文档有句格言：*好的API文档应该描述一个给定的方法做了什么工作，而不是描述它如何做到的。*\n\n为了允许继承，类还必须遵守其他一些约束：\n\n - 构造器决不能调用可被覆盖的方法；\n - 无论是clone（Cloneable接口）还是readObject（Serializable接口），都不可调用可覆盖的方法，不管是直接还是间接的方式。\n\n#### **18. 接口优先于抽象类**\n> 抽象类的演变比接口容易；\n> 骨架实现，即接口的简单实现\n\n#### **19. 接口只用于定义类型**\n> 避免常量接口；\n> 接口应该只被用来定义类型\n\n#### **20. 类层次优先于标签类**\n> 标签类过于冗长、容易出错，并且效率底下\n\n\n#### **21. 用函数对象表示策略**\n> 比较器：String.CASE_INSENSITIVE_ORDER\n\n#### **22. 优先考虑静态成员类**\n嵌套类种类\n\n 1. 静态成员类；\n 2. 非静态成员类；\n 3. 匿名类；\n 4. 局部类。\n\n后三种都被称为内部类。\n> 如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成为静态成员类，而不是非静态成员类。如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。例如ViewHolder。\n\n---\n\n### - Chapter 5 泛型\n\n#### 23. 请不要在新代码中使用原生态类型\n\n - `Set` : 原生态类型， 脱离了泛型系统；\n - `Set<?>` : 无限通配符类型，只能包含某种未知对象类型；\n - `Set<Object>`: 参数化类型，可以包含任何对象类型。\n\n```java\nif (o instanceof Set) {\n\tSet<?> m = (Set<?>) o;\n}\n```\n> 原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。\n\n术语 | 示例\n-------| -------\n参数化类型 | `List<String>`\n实际类型参数 | `String`\n泛型 | `List<E>`\n形式类型参数 | `E`\n无限制通配符类型 | `List<?>`\n有限制类型参数 | `<E extends Number>`\n递归类型限制 | `<T extends Comparable<T>>`\n有限制通配符类型 | `List<? extends Number>`\n泛型方法 | `static <E>List<E> asList(E[] a)`\n泛型令牌 | `String.class`\n\n#### **24. 消除非受检警告**\n> @SuppressWarnings(\"unchecked\")要放在一个声明上，要将禁止非受检警告范围缩到最小；每次使用时都要添加一个注释，说明为什么这么做是安全的。\n\n```java\n// 例如ArrayList中的toArray方法, 注解不加在方法上而是单独声明一个局部变量\n// 为的就是缩小非受检警告范围, 这么做是值得的.\npublic <T> T[] toArray(T[] a) {\n\tif (a.length < size) {\n\t\t// This cast is correct because the array we're creating \n\t\t// is of the same type as the one passed in, which is T[].\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tT[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());\n\t\treturn result;\n\t}\n\tSystem.arrayCopy(elements, 0, a, 0, size);\n\tif (a.length > size)\n\t\ta[size] = null;\n\treturn a;\n}\n```\n\n#### **25. 列表优先于数组**\n\n - 禁止创建泛型数组，优先使用集合；\n - 数组是协变且可以具体化的，泛型是不可变的且可以被擦除的。\n - 混合使用时如何得到编译时错误或者警告时，用列表代替数组。\n\n#### **26. 优先考虑泛型**\n> 使用泛型比使用需要在客户端代码中进行转换的类型来的更加安全，也更加容易。只要时间允许，就把现有的类型都泛型化。\n\n#### **27. 优先考虑泛型方法**\n\n```java\n// 递归泛型 类型参数\npublic static <T extends Comparable<T>> T max(List<T> list) {\n\tIterator<T> i = list.iterator();\n\tT result = i.next();\n\twhile (i.hasNext()) {\n\t\tT t = i.next();\n\t\tif (t.compare(result) > 0)\n\t\t\tresult = t;\n\t}\n\treturn result;\n}\n```\n\n#### **28. 利用有限制通配符来提升API的灵活性**\n> 为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。\n> **PECS表示producer-extends，consumer-super**\n> 换句话说， 如果参数化类型表示一个T生产者，就使用<? extends T>；如果表示一个T消费者，就使用<? super T>\n\n```java\n// 用Stack示例\npublic void pushAll(Iterable<? extends E> src) {\n\tfor (E e : src)\n\t\tpush(e);\n}\npublic void popAll(Collection<? super E> dst) {\n\twhile (!isEmpty()) \n\t\tdst.add(pop());\n}\n```\n修改过的使用通配符类型的声明：PECS规则，list生产T实例，T的comparable消费T实例并产生表示顺序关系的整值。comparable始终是消费者，因此使用时始终应该是`Comparable<? super T>`优先于`Comparable<T>`。对于comparator也一样，因此使用时始终应该是`Comparator<? super T>` 优先于`Comparator<T>`\n\n```java\npublic static <T extends Comparable<? super T>> T max(List<? extends T> list)  {\n\t// 这里做了修改\n\tIterator<? extends T> i = list.iterator();\n\tT result = i.next();\n\twhile (i.hasNext()) {\n\t\tT t = i.next();\n\t\tif (t.compare(result) > 0)\n\t\t\tresult = t;\n\t}\n\treturn result;\n}\n```\n#### **29. 优先考虑类型安全的异构容器**\n\n```java\npublic class Favorites {\n\tprivate Map<Class<?>, Object> favorites = new HashMap<Class<?>, Object>();\n\n\tpublic <T> void putFavorite(Class<T> type, T instance) {\n\t\tif (type == null) \n\t\t\tthrow new NullPointerException(\"type is null\");\n\t\tfavorites.put(type, instance);\n\t}\n\n\tpublic <T> T getFavorite(Class<T> type) {\n\t\treturn type.cast(favorites.get(type));\n\t}\n}\n```\n确保永远不违背它的类型约束条件：\n```java\nCollections.checkedXXX();\n```\n利用Class.asSubclass方法进行转换：\n\n```java\npublic <T extends Annotation> T getAnnotation(Class<T> annotationType);\nClass<?> typeOne = Class.forName(typeOneInstance);\ngetAnnotation(typeOne.asSubclass(Annotation.class));\n```\n\n### -Chapter 6 枚举和注解\n#### **30. 用enum代替int常量**\n> 枚举类型有一个自动产生valueOf（String）方法，它将常量的名字转变成常量本身；\n> 枚举中的switch语句适合于给外部的枚举类型增加特定于常量的行为。\n```java\npublic enum Operation {\n\tPLUS(\"+\") {double apply(double x, double y) {return x + y;} },\n\tMIMUS(\"-\") {double apply(double x, double y) {return x - y} },\n\tTIMES(\"*\") {double apply(double x, double y) {return x * y} },\n\tDIVEDES(\"/\") {double apply(double x, double y) {return x / y} };\n\n\tprivate String symbol;\n\tpublic Operation(String sym) {\n\t\tthis.symbol = sym;\n\t}\n\t@Override\n\tpublic void toString() {\n\t\treturn symbol;\n\t}\n\tabstract double apply(double x, double y);\n}\n```\n\n#### **31. 用实例域代替序数**\n> 所有的枚举都有一个`ordinal`方法， 它返回每个枚举常量在类型中的数字位置。永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例中\n\n```java\npublic enum Ensemble {\n\tSOLO(1), DUET(2), TRIO(3);\n\n\tprivate int numberOfMusicians;\n\tpublic Ensemble(int size) {\n\t\tthis.numberOfMusicians = size;\n\t}\n\tpublic int numberOfMusician() {\n\t\treturn numberOfMusicians;\n\t}\n}\n```\n\n#### **32. 用EnumSet代替位域**\n> 正是因为枚举类型要用在集合Set中, 所有没有理由用位域来表示它.EnumSet具有简洁和性能的优势.\n```java\npublic class Text {\n\tpublic enum Style {BOLD, ITALIC, UNDERLINE, STRIKETHROUGH}\n\t\n\t// 所有的Set都可传入, 但是EnumSet最好\n\t// 考虑到可能还有其他实现,所以使用Set<Style>而不是EnumSet<Style>\n\tpublic void applyStyles(Set<Style> styles){...}\n}\n\n// 下面是将EnumSet实例传递给applyStyles方法的客户端代码。EnumSet提供了丰富的\n// 静态工厂来轻松创建集合, 其中一个如下\ntext.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));\n```\n\n#### **33. 用EnumMap代替序数索引**\n\n```java\nMap<Herb.Type, Set<Herb>> herbsByType = new EnumMap<Herb.Type, Set<Herb>>(Herb.Type.class);\nfor (Herb.Type t : Herb.Type.values()) {\n\therbsByType.put(t, new HashSet<Herb>);\n}\nfor (Herb b : garden) {\n\therbsByType.get(b.type).add(b);\n}\n```\n\n#### **34. 用接口模拟可伸缩的枚举**\n> 避免扩展枚举类型(继承), 采用用枚举类型实现接口(实现)\n```java\n// 定义一个接口\npublic interface Operation{...}\n// ExtendOperation实现了这个接口\npublic ExtendOperation implements Operation{...}\npublic static void main(String[] args) {\n\tdouble x = 3.3;\n\tdouble y = 3.4;\n\t// 方法一\n\ttest(ExtendOperation.class, x, y);\n\t// 方法二\n\ttest(Arrays.asList(ExtendOperation.values()), x, y);\n}\n// 方法一 : 确保Class对象既表示枚举又表示Operation的子类型\nprivate static <T extends Enum<T> & Operation> void test(\n\tClass<T> opSet, double x, double y) {\n\tfor (Operation op : opSet.getEnumConstants()) {\n\t\t// do sth\n\t}\n}\n// 方法二 \nprivate static void test(Collection<? extends Operation> opSet, double x, double y) {\n\tfor (Operation op : opSet) {\n\t\t// do sth\n\t}\n}\n```\n\n#### **35. 注解优先于命名模式**\n\n```java\n// 注解类, 只用在无参数的静态方法上\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Test {}\n\n// 测试\nClass testClass = Class.forName(agrs[0]);\nfor (Method m : testClass.getDeclaredMethods()) {\n\t// 判断某个方法是否被Test注解标注\n\tif (m.isAnnotationPresent(Test.class)) {\n\t\ttry {\n\t\t\t// 可直接执行说明是静态方法; 传入null说明无参数\n\t\t\tm.invoke(null);\n\t\t} catch(InvocationTargetException ite) {\n\t\t\t// 1. 实例方法\n\t\t\t// 2. 一个或多个参数\n\t\t\t// 3. 不可访问的方法\n\t\t}\n\t}\n}\n\n// 只有抛出异常才算成功的注解类\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface ExceptionTest {\n\tClass<? extends Exception> value();\n}\n// 待测试的方法\n@ExceptionTest(ArithmeticException.class)\npublic static void method1() {\n\tint i = 0;\n\ti = i / i;\n}\n@ExceptionTest(ArithmeticException.class)\npublic static void method2() {\n\tint[] arr = new int[1];\n\tint i = arr[3];\n}\n@ExceptionTest(ArithmeticException.class)\npublic static void method3() {\n\t// do nothing\n}\n\n// 测试工具类\nif (m.isAnnotationPresent(ExceptionTest.class)) {\n\ttry {\n\t\tm.invoke(null);\n\t} catch (InvocationTargetExcetpion ite) {\n\t\t// 出现的异常类型\n\t\tThrowable exception = ite.getCause();\n\t\t// 期待的异常类型\n\t\tClass<? extends Exception> ex = m.getAnnotation(ExceptionTest.class).value();\n\t\t// 出现的异常与期待的异常时同一种\n\t\tif (ex.instanceOf(exception)) {...}\n\t}\n}\n\n// 多种类型异常注解类\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementTarget.METHOD)\npublic @interface ExceptionsTest {\n\tClass<? extends Exception>[] value();\n}\n// 待测试方法注解\n@ExceptionsTest({IndexOutOfBoundException.class, ArithmeticException.class})\npublic static void method4() {\n}\n```\n\n#### **36. 坚持使用Override注解**\n> IDE可检查\n\n#### **37. 用标记接口定义类型**\n**标记接口，类似于Serializable接口，没有方法，只是一个空接口作为标记，被标记过的实例可以通过ObjectOutputStream处理。**\n两者比较：标记接口和标记注解\n - 标记接口定义的类型是由被标记类的实例实现的；标记注解则是没有定义这样的类型。这个类型允许你在编译时捕捉在使用标记注解的情况下要到运行时才能捕捉到的错误；\n - 标记接口的另一个优点，可以被跟家精确的锁定；\n - 标记注解胜过标记接口的最大优点在于，它可以通过默认的方式添加一个或者多个注解类型元素，给一倍使用过的注解类型添加更多的信息。随着时间的推移，简单类型的标记注解可以演变成丰富的标记注解， 标记接口则不能。\n - 标记注解的另一个优点在于，它们是更大的注解机制的一部分。因此，标记注解在那些支持注解作为编程元素之一的框架中同样具有一致性。\n\n区分使用\n\n - 应用到任何程序元素（方法，字段等）而不是类或者接口，必须用标记注解；\n - 标记类和接口， 优先使用标记接口；\n - 标记只用于特殊接口的元素，将标记定义为该接口的一个子接口；\n - 如果以后需要扩展，用标记注解；\n - 当目标是ElementType.TYPE时，多考虑标记接口。\n\n### -Chapter 7 方法\n\n#### **38. 检查参数的有效性**\n\n - 在方法体的开头检查参数；\n - 使用断言assert，失败时抛出AssertionError；\n - 检查构造器的参数尤为重要\n\n#### **39. 必要时进行保护性拷贝**\n\n- 保护性拷贝是在检查参数有效性之前进行的，并且有效性检查是针对拷贝之后的对象；\n- 对于参数类型可以被不可信任方子类化的参数，请不要使用clone进行保护性拷贝\n\n#### **40. 谨慎设计方法签名**\n\n 1. 谨慎选择方法名称。\n 2. 不要过于追求提供便利的方法。\n 3. 避免过长的参数列表（小于等于4）。\n 4. 对于参数类型，优先使用接口而不是类。\n 5. 对于boolean参数， 优先使用两个元素的枚举类型。\n\n#### **41. 慎用重载**\n\n - 对于重载方法（overloaded method）的选择是静态的，而对于被覆盖的方法（overridden method）的选择是动态的。\n - 避免胡乱使用重载机制的安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法是可变参数，保守策略是根本不要重载它。\n\n#### **42. 慎用可变参数**\n#### **43. 返回零长度的数组或集合，而不是null**\n\n```java\nprivate final List<Cheese> cheeseInStock = ....;\nprivate final static Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];\n\npublic Cheese[] getCheese() {\n\treturn cheeseInStock.toArray(EMPTY_CHEESE_ARRAY);\n}\n\n// 集合值的方法\npublic List<Cheese> getCheeseList() {\n\tif (cheeseOfStock .isEmpty()) {\n\t\treturn Collections.emptyList();\n\t} else {\n\t\treturn new ArrayList<Cheese>(cheeseOfStock);\n\t}\n}\n```\n\n#### **44. 为所有到处的API元素编写文档注释**\n\n### -Chapter 8 通用程序设计\n\n#### **45. 将局部变量的作用域最小化**\n\n - 要是局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。\n - 几乎每个局部变量的声明都应该包含一个初始化表达式，如果没有则应推迟声明。try-catch例外。\n - 如果循环终止之后不再需要循环变量的内容，for循环优于while循环。\n\n```java\n// n的作用是:避免每次循环产生额外计算的开销\nfor (int i = 0 , n = getSize(); i < n; i++) {\n\tdoSomething(i);\n}\n```\n\n#### **46. for-each循环优于传统的for循环**\n\n三种情况无法使用for-each\n 1. 过滤：如果需要遍历集合，并删除选定的元素，就需要使用显示的迭代器，以便可以调用它的remove方法。\n 2. 转换：如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设定元素的值。\n 3. 平行迭代：如果需要并行的遍历多个集合，就需要显示的控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移。\n\n#### **47. 了解和使用类库**\n\n - 使用标准类库而不是专门的实现。\n - Collections Framework\n - java.util.concurrent包含高级并发工具来简化多线程的编程任务，还包含低级别的并发基本类型\n\n#### **48. 如果需要精确的答案， 请避免使用float和double**\n> 使用int或者long或者BigDecimal替代。\n\n#### **49. 基本类型优先于装箱基本类型**\n\n#### **50. 如果其他类型更适合， 则尽量避免使用字符串**\n\n - 字符串不合适代替其他的值类型。\n - 字符串不合适代替枚举类型。\n - 字符串不适合代替聚集类型。\n - 字符串也不适合代替能力表。\n\n#### **51. 当心字符串连接的性能**\n> 使用StringBuilder\n\n#### **52. 通过接口引用对象**\n> 如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明，如List。\n> 如果没哟合适的接口存在，完全可以用类而不是接口来引用对象，如值类String、BigInteger\n\n#### **53. 接口优先于反射机制**\n\n#### **54. 谨慎地使用本地方法**\n> 使用本地方法提高性能的做法不值得提倡\n\n#### **55. 谨慎地进行优化**\n\n - 努力避免那些限制性能的设计决策。\n - 为获得更好的性能而对API进行包装，这是一种非常不好的想法。\n\n#### **56. 遵守普遍接受的命名惯例**\n\n### -Chapter 9 异常\n\n#### **57. 只针对异常的情况才使用异常**\n\n#### **58. 对于可恢复的情况使用受检异常，对编程错误使用运行时异常**\n\n#### **59. 避免不必要地使用受检异常**\n\n#### **60. 优先使用标准的异常**\n\n#### **61. 抛出与抽象相对应的异常**\n> 底层的异常被传到高层的异常，高层的异常提供访问方法（Throwable.getCause）来获得底层的异常\n\n#### **62. 每个方法抛出的异常都要有文档**\n\n#### **63. 在细节消息中包含能捕获失败的信息**\n\n#### **64. 努力使失败保持原子性**\n\n#### **65. 不要忽略异常**\n\n### -Chapter 10 并发\n\n#### **66. 同步访问共享的可变数据**\n> 当多个线程共享可变数据的时候，每个读或者写数据的线程必须执行同步。\n\n#### **67. 避免过度同步**\n\n - 为了避免活性失败和安全性失败，在一个被同步的方法或者代码块中，永远不要放弃对客户端的控制。\n - 在同步区域内做尽可能少的工作。\n - 为了避免死锁和数据损坏，千万不要从同步区域内部调用外来方法。\n\n#### **68. executor和task优先于线程**\n\n#### **69. 并发工具优先于wait和notify**\n\n - 除非迫不得已，否则应该优先使用ConcurrentHashMap，而不是使用Collections.synchronizedMap或Hashtable。只要用并发Map替代老式的同步Map，就可以极大地提升应用程序的性能。更一般地，应该优先使用并发集合，而不是使用外部的同步集合。\n - 对于间歇式的定时，始终应该优先使用System.nanoTime，而不是System.currentTimeMills，前者更加准确也更加精确，它不受系统的实时始终的调整影响。\n - 使用应该使用wait循环模式来调用wait方法；永远不要在循环之外调用wait方法。循环会在等待之前和之后测试条件。\n\n```java\nprivate static final ConcurrentMap<String, String> map = ConcurrentHashMap<>();\n\npublic static String intern(String s) {\n\tString result = map.get(s);\n\tif (result == null) {\n\t\t// 应对并发情况\n\t\tresult = map.putIfAbsent(s, s);\n\t\tif (result == null) {\n\t\t\tresult = s;\n\t\t}\n\t}\n\treturn result;\n}\n```\n\n#### **70. 线程安全性的文档化**\n\n - “出现synchronized关键字就足以用文档说明线程安全性”的这种说法隐含了一个错误的观念，即认为线程安全性是一种“要么全有要么全无”的属性。\n\n线程安全性的几种级别：\n\n 1. 不可变的（immutable）：这个类的实例是不变的。所以，不需要外部的同步。这样的例子包括String、Long和BigInteger。\n 2. 无条件的线程安全（unconditionally thread-safe）：这个类的实例是可变的，但是这个类有着足够的内部同步，所以，它的实例可以被并发使用，无需任何外部同步。其例子包括Random和ConcurrentHashMap。\n 3. 有条件的线程安全（conditionally thread-safe）：除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。这样的例子包括Collections.synchronized包装返回的集合，它们的迭代器（iterator）要求外部同步。\n 4. 非线程安全（not thread-safe）：这个类的实例是可变的。为了并发地使用它们，客户必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如ArrayList和HashMap。\n 5. 线程对立的（thread-hostile）：这个类不能安全地被多个线程并发使用，即使所有的方法调用都被外部同步包围。线程对立的根源通常在于，没有同步地修改静态数据。没有人会有意编写一个线程对立的类；这种类是因为没有考虑到并发性儿产生的后果。幸运的是，在Java平台类库中，线程对立的类或者方法非常少。System.runFinalizersOnExit方法是线程对立的，但已经被废除了。\n\n#### **71. 慎用延迟初始化**\n\n - 在大多数情况下，正常初始化要优先于延迟初始化。如果域只在类的实例部分被访问，并且初始化这个域的开销很高，可能就值得进行延迟初始化。\n\n```java\n// 正常初始化\nprivate final FieldType field = computeFieldValue();\n\n// 延迟初始化，要使用同步访问方法\nprivate FieldType field;\nsynchronized FieldType getField() {\n\tif (field == null)\n\t\tfield = computeFieldValue();\n\treturn field;\n}\n```\n\n - 如果出于性能的考虑而需要对**静态域**使用延迟初始化，就是用lazy initialization holder class模式。这种模式保证了类要到用到的时候才会被初始化。\n\n```java\nprivate static class FieldHolder {\n\tstatic final FieldType field = computeFieldValue();\n}\nstatic Field getField() {\n\treturn FieldHolder.field;\n}\n```\n\n - 如果处于性能考虑而需要对**实例域**使用延迟初始化，就使用双重检查模式。这种模式避免了在域被初始化之后访问这个域时的锁定开销。\n\n```java\nprivate volatile FieldType field;\nFieldType getField() {\n\t// 局部变量result的作用是确保field只在已经被初始化的情况下读取一次,提升性能\n\tFieldType result = field;\n\tif (result == null) {\n\t\tsynchronized(this) {\n\t\t\tresult = field;\n\t\t\tif (result == null)\n\t\t\t\tfield = result = computeFieldValue();\n\t\t}\n\t}\n\treturn result;\n}\n```\n\n - 延迟初始化一个可以接受重复初始化的实例域，可使用单重检查模式。\n \n \n\n```java\nprivate volatile FieldType field;\nprivate FieldType getField() {\n\tFieldType result = field;\n\tif (result == null) \n\t\tfield = result = computeFieldValue();\n\treturn result;\n}\n```\n\n#### **72. 不要依赖于线程调度器**\n> 不要让程序的正确性依赖于线程调度器，否则结果得到的应用将既不健壮也不具有可移植性。作为推论，不要依赖Thread.yield或者线程优先级。\n\n#### **73. 避免使用线程组**\n\n### -Chapter 11 序列化\n\n#### **74. 谨慎地实现Serializable接口**\n> 为了继承而设计的类应该尽可能少地去实现Serializable接口，用户的接口也应该尽可能少地继承Serializable接口。\n> 如果一个类或者一个接口存在的目的主要是为了参与到某个框架中，该框架要求所有的参与者必须实现Serializable接口，这个时候实现或者扩展Serializable接口就很有意义。\n> 内部类不应该实现Serializable，内部类的默认序列化形式是定义不清楚的，然而静态成员类却可以实现Serializable。\n\n```java\npublic class Foo extends AbstractFoo implements Serializable {\n\tprivate void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n\t\ts.defaultReadObject();\n\t\t// Manually deserialize and initialize superclass state\n\t\tint x = s.readInt();\n\t\tint y = s.readInt();\n\t\tinitialize(x, y);\n\t}\n\n\tprivate void writeObject(ObjectOutputStream s) throws IOException {\n\t\ts.defaultWriteObject();\n\t\t// Manually serialize superclass state\n\t\ts.writeInt(getX());\n\t\ts.writeInt(getY());\n\t}\n\t\n\tpublic Foo(int x, int y) {\n\t\tsuper(x, y);\n\t}\n\t\n\tprivate static final long serialVersionUID = 185683560954L;\n}\n```\n\n#### **75. 考虑使用自动以序列化形式**\n\n```java\npublic final class StringList implements Serializable {\n\tprivate int size = 0;\n\tprivate Entry head = null;\n\tprivate static class Entry implements Serializable {\n\t\tString data;\n\t\tEntry next;\n\t\tEntry previous;\n\t}\n\t// ...Remainder omitted\n}\n```\n\n当一个对象的物理表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下4个缺点：\n\n 1. **它使这个类的导出API永远地束缚在该类的内部表示法上。**在上面的例子中，私有的StringList.Entry类变成了公有API的一部分。如果在将来额版本中，内部表示法发生了变化，StringList类仍将需要接受链表形式的输入，并产生链表形式的输出。这个类永远也摆脱不了维护链表项所需要的所有代码，即使它不再使用链表作为内部结构了，也仍然需要这些代码。\n 2. **它会消耗过多的空间。**在上面的例子中，序列化形式既表示了链表中的每个项，也表示了所有的链接关系，这是不必要的。这些链表项以及链表只不过是实现细节，不值得记录在序列化形式中。因为这样的序列化形式过于庞大，所以把它写到硬盘中，或者在网络上发送都将非常慢。\n 3. **它会消耗过多的时间。**序列化逻辑并不了解对象图的拓补关系，所以它必须要经过一个昂贵的图遍历（traversal）过程。在上面的例子中，沿着next引用进行遍历是非常简单的。\n 4. **它会引起栈溢出。**默认的序列化过程要对对象图执行一次递归遍历，即使对于中等规模的对象图，这样的操作也可能引起栈溢出。到底多少个元素会引发栈溢出，这要取决于JVM的具体实现以及Java启动时的命令行参数，（比如Heap Size的-Xms与-Xmx的值）有些实现可能根本不存在这样的问题。\n\n修订版本，transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉。\n\n```java\npublic final class StringList implements Serializable {\n\tprivate transient int size = 0;\n\tprivate transient Entry head = null;\n\tprivate static class Entry {\n\t\tString data;\n\t\tEntry next;\n\t\tEntry previous;\n\t}\n\t// 添加指定的string到这个集合\n\tpublic final void add(String s) {...}\n\n\t// 重写writeObject方法, 与物理表示法的细节脱离\n\tprivate void writeObject(ObjectOutputStream s) throws IOException {\n\t\ts.defaultWriteObject();\n\t\ts.writeInt(size);\n\t\tfor (Entry e = head; e != null; e = e.next) {\n\t\t\ts.writeObject(e.data);\n\t\t}\n\t}\n\n\t// 重写readObject方法,与write对应\n\tprivate void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\n\t\ts.defaultReadObject();\n\t\tint numElements = s.readInt();\n\t\tfor (int i = 0; i < numElements; i++) {\n\t\t\tadd((String) s.readObject());\n\t\t}\n\t}\n\t...// Remainder omitted\n}\n```\n> 尽管StringList的所有域都是瞬时的(transient)，但wirteObject方法的首要任务仍是调用defaultWriteObject，readObject方法的首要任务则是调用defaultReadObject。如果所有的实例域都是瞬时的，从技术角度而言，不调用defaultWriteObject和defaultReadObject也是允许的，但是不推荐这样做。即使所有的实例域都是transient的，调用defaultWriteObject也会影响该类的序列化形式，从而极大地增强灵活性。这样得到的序列化形式允许在以后的发行版中增加非transient实例域，并且还能保持向前或者向后兼容性。如果某一个实例将在未来的版本中被序列化，然后在前一个版本中被反序列化，那么，后增加的域将被忽略掉。如果旧版本的readObject方法没有调用defaultReadObject，反序列化过程将失败，引发StreamCorrupted Exception异常。\n> 无论是否使用默认的序列化形式，当defaultWriteObject方法被调用的时候，每一个未被标记为transient的实例域都会被序列化。因此每一个可以被标记为transient的实例域都应该做上这样的标记。这包括那些冗余的域，即它们的值可以根据其他“基本数据类型”计算而得到的域，比如缓存起来的散列值。**在将一个域做成非transient的之前，请一定要确信它的值是该对象逻辑状态的一部分。**如果你正在使用一种自定义的序列化形式，大多数实例域，或者所有的实例域则都应该被标记为transient，就像上面例子中的StringList那样。\n> 如果正在使用默认的序列化形式， 并且把一个或者多个域标记为transient，则要记住，当一个实例被反序列化的时候，这些域将被初始化为它们的默认值。\n> 无论是否使用默认的序列化形式，如果在读取整个对象状态的任何其他方法上强制任何同步，则必须在对象序列化上强制这种同步。\n> 不管选择了哪种序列化形式，都要为自己编写的每个可序列化的类声明一个显示的序列化版本UID（serial version UID）。第一避免不兼容，第二减小额外计算的开销。\n\n```java\npirvate static final long serialVersionUID = randomLongValue;\n```\n> 在编写新类时，为randomLongValue选择什么值并不重要。通过在该类上运行serialver工具，就可以得到这样一个值，但是，凭空编造一个数值也是可以的。如果想修改一个没有序列版本UID的现有的类，并希望新的版本能够接受现有的序列化实例，就必须使用serialver工具为旧版本生成值。\n\n#### **76. 保护性地编写readObject方法**\n> 当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。\n\n指导方针：\n\n - 对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别。\n - 对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后。\n - 如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口。\n - 无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法。\n\n#### **77. 对于实例控制，枚举类型优先于readResolve**\n> readResolve特性允许你用readObject创建的实例代替另一个实例。对于一个正在被反序列化的对象，如果它的类定义了一个readResolve方法，并且具备正确的声明，那么在反序列化之后，新建对象上的readResolve方法就会被调用。然后该方法返回的对象引用将被返回，取代新建的对象。在这个特性的绝大多数用法中，指向新建对象的引用不需要再被保留，因此立即成为垃圾回收的对象。\n\n> 总而言之，应该尽可能地使用枚举dang来实施实例控制的约束条件。如果做不到，同时又需要一个既可序列化又是实例受控的类，就必须提供一个readResolve方法，并确保该类的所有实例域都为基本类型，或者时transient。\n\n#### **78. 考虑用序列化代理代替序列化实例**\n序列化代理模式相当简单：\n\n 1. 为可序列化的类设计一个私有的静态嵌套类，精确地表示外围类的实例的逻辑状态。这个嵌套类被称作序列化代理，它应该有一个单独的构造器，其参数类型就是那个外围类。这个构造器只从它的参数中复制数据：它不需要进行任何一致性检查或者保护性拷贝。从设计的角度来看，序列化代理的默认序列化形式是外围类最好的序列化形式。外围类及其序列代理都必须声明实现Serializable接口。\n\t \n\t```\n\tprivate static class SerializationProxy implements Serializable {\n\t\tprivate final Date start;\n\t\tprivate final Date end;\n\t\n\t\tSerializationProxy(Period p) {\n\t\t\tthis.start = p.start;\n\t\t\tthis.end = p.end;\n\t\t}\n\t\tprivate static final long serialVerionUID = 302480420480234L;\n\t}\n\t```\n\n 2.  接下来，将下面的writeReplace方法添加到外围类中。通过序列化代理，这个方法可以被逐字复制到任何类中：\n \n\t```\n\tprivate Object writeReplace() {\n\t\treturn new SerializationProxy(this);\n\t}\n\t```\n这个方法的存在导致序列化系统产生一个SerializationProxy实例,代替外围类的实例。换句话说，writeReplace方法在序列化之前，将外围类的实例转变成了它的序列化代理。所以序列化系统永远不会产生外围类的序列化实例，为了避免攻击者伪造，只要在外围类中添加这个readObject方法即可：\n\n\t```\n\tprivate void readObject(ObjectInputStream s) throws InvalidationException {\n\t\tthrow new InvalidationException(\"Proxy required\");\n\t}\n\t```\n\n 3. 最后，在SerializationProxy类中提供一个readResolve方法，它返回一个逻辑上相当于外围类的实例。这个方法使序列化系统在反序列化时将序列化代理转变回外围类的实例。\n这个readResolve方法仅仅利用它的公有API创建外围类的一个实例，这正是该模式的魅力之所在。它极大地消除了序列化机制中语言本身之外的特征，因为反序列化实例是利用与任何其他实例相同的构造器、静态工厂和方法而创建的。这样就不必单独确保被反序列化的实例一定要遵守类的约束条件。如果该类的静态工厂或者构造器建立了这些约束条件，并且它的实例方法在维持着这些约束条件，你就可以确信序列化也会维持这些约束条件。\n上述Period.SerializationProxy的readResolve方法：\n\n\t```\n\tprivate Object readResolve() {\n\t\treturn new Period(start, end);\n\t}\n\t```\n\n---\n- 两个局限性：它不能与可以被客户端扩展的类兼容，它也不能与对象图中包含循环的某些类兼容：如果企图从一个对象的序列化代理的readResolve方法内部调用这个对象的方法，就会得到一个ClassCastException异常，因为还没有这个对象，只有它的序列化代理。\n-  代价：比保护性拷贝进行的开销大。\n- 当必须在一个不能被客户端扩展的类（final）上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式。","tags":["Java"],"categories":["读书笔记"]},{"title":"Android YuvImage直接旋转","url":"/2017/10/5fec38fe91ba/","content":"---\n操作相机的`Preview`可通过以下三种方式添加回调接口：\n<!--more--> \n```java\nCamera.setPreviewCallbackBuffer(PreviewCallback);\nCamera.setOneShotPreviewCallback(PreviewCallback);\nCamera.setPreviewCallback(PreviewCallback);\n```\n**PreviewCallback**接口里面只有一个回调方法:\n`void onPreviewFrame(byte[] data, Camera camera);`\n\n其中的`byte[] data`就是`Preview`的图像数据，格式为`YuvImage`，而这个图像天生是横着的，一般的旋转操作是:\nYuvImage的byte[] --> Bitmap的byte[] --> 生成Bitmap --> 旋转Bitmap\n---\n<!--more-->\n**示例代码**\n\n```java\npublic void onPreviewFrame(byte[] data, Camera camera) {\n        final int width = camera.getParameters().getPreviewSize().width;\n        final int height = camera.getParameters().getPreviewSize().height;\n        // 通过YuvImage得到Bitmap格式的byte[]\n        YuvImage yuvImage = new YuvImage(data, ImageFormat.NV21, width, height, null);\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        yuvImage.compressToJpeg(new Rect(0, 0, width, height), 100, out);\n        byte[] dataBmp = out.toByteArray();\n        // 生成Bitmap\n        Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, dataBmp.length);\n        // 旋转\n        Matrix matrix = new Matrix();\n        matrix.setRotate(90);\n        Bitmap bmp = Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix, false);\n        // 保存到本地\n        File file = new File(\"/storage/emulated/0/\" + System.currentTimeMillis() + \".jpg\");\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            bmp.compress(Bitmap.CompressFormat.JPEG, 100, fos);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n## 原理\n---\n实际上，可以直接旋转YuvImage。Camera返回的数据格式默认是`NV21`，即YUV420的YV12，每4个Y共用一组UV分量。换句话说就是假设一张宽为`width`高为`height`的图像，共`sum = width * height`个像素点，那么Y分量一共`sum`个，U分量一共`sum/4`,V分量一共`sum/4`，YUV同RGB类似，都是用来表示图像属性，YUV各占1个byte，所以存储该图像的byte[] 的长度为YUV的数量之和，3/2*sum。\n例如，一张4像素x4像素的图片，存储格式为\n![](https://i.loli.net/2021/07/06/kEtbGrWgdw7qY14.png)\n**每个像素点都有YUV3个分量**，一个方格代表1byte，Y分量顺序排列，之后VU分量交叉排列，Y1、Y2、Y5、Y6共用V1U1分量，也就是说第1个像素点为[Y1 V1 U1]，第2个像素点为[Y2 V1 U1]，第5个像素点[Y5 V1 U1]，第6个像素点[Y6 V1 U1]，同理颜色相同都共用。有了上面的基础再来说旋转，图像旋转就是改变数组中YUV各个分量的位置，变换之后要保证共用关系不能变，即Y1、Y2、Y5、Y6还要共用V1、U1分量，顺时针旋转90度后如下\n![](https://i.loli.net/2021/07/06/v1AquyOJP5bhQfL.png)\n由图可以看出，**简单说就是Y分量部分和VU分量部分分别旋转**\n有了以上的基础，再来总结一下顺时针旋转90后角标对应关系：\n旋转前的图：srcWidth、srcHeight\n旋转后的图：dstWidth、dstHeight（旋转前后宽高对调，即sW=dH、sH=dW）\n先看Y分量，假设旋转后的图中第i行，第j列的一个像素，它的Y分量为(i, j)，它在旋转(顺时针旋转90度)前的位置为(srcHeight-1-j, i)；\n再看VU分量，因为`NV21`格式每组UV分量有4个Y分量共用，所以只要随着4个中的一个改变一次就可以了，我选择让VU分量跟着左上角的Y分量一起变换（例如，V1U1跟着旋转后的Y5变换）即，当(i, j)为左上角的Y时，这个时候它对应旋转前的4个分量中左下角的Y（后Y5和前Y5），前Y5的VU分量，放到后Y5VU分量的位置即可，当进行到旋转后的图4个Y分量中的其他3个分量时不再进行VU分量的操作；\nY分量与其对应的VU分量的行角标对应关系为：目标VU行角标 = Y行角标 + 图像的高。\n## 实践（上面不懂不重要，代码可以直接用~）\n---\n\n```java\n  public void onPreviewFrame(final byte[] data, Camera camera) {\n\t\t// 将系统回调的数组拷贝一份,操作拷贝的数据\n        byte[] dataCopy = new byte[data.length];\n        System.arraycopy(srcData, 0, dataCopy , 0, data.length);\n        Camera.Size size = camera.getParameters().getPreviewSize();\n        final int srcWidth = size.width;\n        final int srcHeight = size.height;\n        final int dstWidth = size.height;\n        final int dstHeight = size.width;\n        // 1.5倍的总数,多出来的部分装VU分量\n        byte[] buf = new byte[dstWidth * dstHeight * 3 / 2];\n\n        for (int i = 0; i < dstHeight; i++) {\n            for (int j = 0; j < dstWidth; j++) {\n                // 新数组中摆放Y值 旋转后(i,j) --> 旋转前(srcHeight-1-j, i)\n                buf[i * dstWidth + j] = dataCopy[(srcHeight - 1 - j) * srcWidth + i];\n                // 确认是左上角的点\n                if (i % 2 == 0 && j % 2 == 0) {\n                    // 摆放V值 目标行号= 行号/2 + 高\n                    buf[(i / 2 + srcWidth) * dstWidth + j] = dataCopy[((srcHeight - 1 - j) / 2 + srcHeight) * srcWidth + j];\n                    // 摆放U值\n                    buf[(i / 2 + srcWidth) * dstWidth + j + 1] = dataCopy[((srcHeight - 1 - j) / 2 + srcHeight) * srcWidth + j + 1];\n                }\n            }\n        }\n        \n        YuvImage yuvImage = new YuvImage(buf, ImageFormat.NV21, dstWidth, dstHeight, null);\n\n        File file = new File(\"/storage/emulated/0/\" + System.currentTimeMillis() + \".jpg\");\n        try {\n            FileOutputStream fos = new FileOutputStream(file);\n            yuvImage.compressToJpeg(new Rect(0, 0, dstWidth, dstHeight), 100, fos);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n}\n```","tags":["Android","Yuv"],"categories":["Android"]},{"title":"ScrollView在SlidingUpPanelLayout中下滑无效问题","url":"/2017/10/208c39b1bdad/","content":"\n当在`ScrollableView`(即, 可上下滑动的ViewGroup)中含有`ScrollView`时，向上滑动`ScrollableView`至其全部上移展示出来时，继续向上滑动时`ScrollView`会响应滑动事件向上滑动，但是此时抬起手后再向下滑动时，首先响应滑动事件的是`ScrollabldView`，这就导致`ScrollView`无法下滑，解决该问题一种简单有效的实践：\n<!--more--> \n```java\nSlidingUpPanelLayout.setScrollableView(ScrollView)\n```\n\n**用`ScrollView`替换整个滑动的ViewGroup**\n","tags":["Android","SlidingUpPanelLayout"],"categories":["Android"]},{"title":"手把手教你实现RecyclerView的下拉刷新和上拉加载更多","url":"/2017/10/a9bb97b2a678/","content":"---\n\n纵观多数App，下拉刷新和上拉加载更多是很常见的功能，但是谷歌官方只有一个SwipeRefreshLayout用来下拉刷新，上拉加载更多还要自己做。\n\n基于RecyclerView简单封装了这两个操作，下拉刷新支持LinearLayoutManager、GridLayoutManager和StaggeredGridLayoutManager;上拉加载更多只支持前两者。\n\n<!--more-->\n----------\n\n\n#### 话不多说先上效果图 数据来自[**干货集中营**](http://gank.io/api)\n\n![](https://i.loli.net/2021/07/03/O6JtWNRBz7n1udD.gif)\n(下拉刷新）\n\n![](https://i.loli.net/2021/07/03/Rygwk9KZPBGaNnv.gif)\n（上拉加载更多 -- LinearLayoutManager）\n\n![](https://i.loli.net/2021/07/03/j7mqzU3PDXOYFpE.gif)\n（上拉加载更多 -- GridLayoutManager）\n\n\n----------\n\n\n### (一) 使用方式，很简单 如下：\n\n* **1. 下拉刷新 3步走**\n\n**1.1 布局文件**\n\t\n```xml\n// 用SwipeRefreshLayout包裹RecyclerView\n<android.support.v4.widget.SwipeRefreshLayout\n\t        android:id=\"@+id/gank_swipe_refresh_layout\"\n\t        android:layout_width=\"match_parent\"\n\t        android:layout_height=\"match_parent\">\n\t\n<android.support.v7.widget.RecyclerView\n\t         android:id=\"@+id/gank_recycler_view\"\n\t            android:layout_width=\"match_parent\"\n\t            android:layout_height=\"match_parent\"\n\t            android:overScrollMode=\"never\"/>\n</android.support.v4.widget.SwipeRefreshLayout>\n```\n\t\n\n\n**1.2 给`SwipeRefreshLayout` 添加监听 增加触发刷新时的操作(比如重新请求数据)**\n\n```java\nSwipeRefreshLayout swipeRefreshLayout = findViewById();\nswipeRefreshLayout.setOnRefreshListener(new swipeRefreshLayout.OnRefreshListener() {\n            @Override\n            public void onRefresh() {\n\t            // do something, such as re-request from server or other\n            }\n        });\n```\n\n**1.3 刷新操作(重新请求数据)完成后要回调来停止隐藏刷新动画(中上方圆形悬浮进度条旋转动画)**\n\n```java\nswipeRefreshLayout.setRefreshing(false);\n```\n\t\n**至此下拉刷新完成**\n<br/>\n\n* **2.上拉加载3步走**\n\n**2.1 初始化`AdapterWrapper`和`SwipeToLoadHelper`**\n```java\n// adapter是你自己为RecyclerView写的Adapter\nRecyclerView.Adapter adapter = new YourOwnAdapter();\nAdapterWrapper adapterWrapper = new AdapterWrapper(adapter);\nRecyclerView recyclerView = findViewById();\n// 将RecyclerView和刚创建的adapterWrapper传入\nSwipeToLoadHelper helper = new SwipeToLoadHelper(recyclerView, adapterWrapper);\n```\n**2.2 设置加载动作触发后的监听**\n```java\nhelper.setLoadMoreListener(new SwipeToLoadHelper.LoadMoreListener() {\n            @Override\n            public void onLoad() {\n            // do something, such as request more data from server or other.\n            }\n        })\n```\n**2.3 加载更多内容完成后要回调方法停止动画**\n```java\nhelper.setLoadMoreFinish()\n```\n**至此上拉加载完成 (注意更新数据时要调用`AdapterWrapper.notifyDataSetChanged`)**\n\n---\n\n### (二) 简明扼要的实现思路(上拉加载操作)\n\n> `RecyclerView`的`itemView`的显示情况分为四种：\n> \n> 1. 第1个可见的（部分显示或者完全显示都算可见）\n> 2. 第1个可见的且是完整的（完全显示算作完整的）\n> 3. 最后1个可见的\n> 4. 最后1个可见的且是完整的\n\n* **1. 回弹效果**\n即手指抬起滑动停止，`上拉加载更多`部分显示时，将`上拉加载更多`滚动到不显示，使上面挨着它的`itemView`为最后1个可见且是最后1个完整可见。<br/>\n监听`RecyclerView`的滚动，当`RecyclerView`处于`SCROLL_STATE_IDLE` 状态时，获取最后1个完整可见的`itemView`：如果是倒数第2个`item`则计算该`item`的下边距到`RecyclerView`底部的距离`deltaY`，然后将`RecyclerView`向下滚动`deltaY`；如果是`上拉加载更多`则触发加载操作；其他情况不用处理。\n\n```java\n// 关键代码 rv : recyclerView\nint lcp = layoutManager.findLastCompletelyVisibleItemPosition();\nif (lcp == layoutManager.getItemCount() - 2) {\n\t// 倒数第2项\n\tint fcp = layoutManager.findFirstCompletelyVisibleItemPosition();\n    View child = layoutManager.findViewByPosition(lcp);\n    int deltaY = rv.getBottom() - rv.getPaddingBottom() - \n\t\t\t\t    child.getBottom();\n\t// fcp为0时说明列表滚动到了顶部, 不再滚动\n    if (deltaY > 0 && fcp != 0) {\n\t      rv.smoothScrollBy(0, -deltaY);\n    }\n} else if (lcp == layoutManager.getItemCount() - 1) {\n    // 最后一项完全显示, 触发操作, 执行加载更多操作\n    if (listener != null) {\n\t    listener.onLoad();\n    }\n}\n```\n<br/>\n\n* **2. 添加底部`加载更多`itemView**\n\n2.1 `AdapterWrapper`重写了`getItemCount`方法，保证得到`itemView`的数量包括`加载更多`。当是`LinearLayoutManager`类型时直接加1；当是`GridLayoutManager`类型时，如果需要则先将列表最后一行填满，再加1。比如：列表每行有3个`itemView`，最后一行只有1个，这时就需要先加2，再加1，来保证`加载更多`占据完整的一行。\n\n```java\n// 关键代码 其中的adapter为构造函数中传入的原生RecyclerView.Adapter\nif (adapterType == ADAPTER_TYPE_LINEAR) {\n\t// 线性布局\n\treturn adapter.getItemCount() + 1;\n} else {\n\t// 网格布局 spanCount为每行itemView的个数\n    int remain = adapter.getItemCount() % spanCount; // 余数\n    if (remain == 0) {\n\t    return adapter.getItemCount() + 1;\n    }\n    // 余数不为0时,先凑满再加1\n    return adapter.getItemCount() + 1 + (spanCount - remain);\n}\n```\n\n2.2 `AdapterWrapper`重写了`getItemViewType`方法，当是最后一个位置时返回`ITEM_TYPE_LOAD`\n\n```java\n// 关键代码\npublic int getItemViewType(int position) {\n    // 位置是最后一个时, wrapper进行拦截\n    if (osition == getItemCount() - 1) {\n        return ITEM_TYPE_LOAD;// 要避免和原生adapter返回值可能重复\n    }\n    // 其他情况交给原生adapter处理\n    return adapter.getItemViewType(position);\n}\n```\n\n2.3 `AdapterWrapper`重写了`onCreateViewHolder`方法，当类型为`ITEM_TYPE_LOAD`时返回`加载更多`的`ViewHolder`，其他情况交给原生的`adapter`处理。\n\n```java\n// 关键代码\npublic RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n    if (viewType == ITEM_TYPE_LOAD) {\n        return new LoadMoreHolder();\n    } else {\n        return adapter.onCreateViewHolder(parent, viewType);\n    }\n}\n```\n\n2.4 `AdapterWrapper`重写了`onBindViewHolder`，这里有三种可能的情况：1. 正常的数据项`itemView`，交给`adapter`处理；2. `GridView`的空白`itemView`，隐藏处理；3. 底部的`加载更多`，目前不需要做什么处理。\n\n```java\n// 关键代码\npublic void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n    if (position == getItemCount() - 1) {\n    } else if (position < adapter.getItemCount()){\n        adapter.onBindViewHolder(holder, position);\n    } else {\n        holder.itemView.setVisibility(View.INVISIBLE);\n    }\n }\n```\n----\n### (三) 额外的两个说明\n* `SwipeFreshLayout`有个`setEnable(boolean)`方法，设置为`false`的时候就下拉刷新功能就没有了，等同于普通的`RecyclerView`\n* 同样`SwipeToLoadHelper`有个`setSwipeToLoadEnabled(boolean)`方法，设置为`false`的时候上拉加载功能就没有了， 等同于普通的`RecyclerView`\n\n---\n#### **如有问题，欢迎指正~**\n\n附[项目仓库地址](https://github.com/oynix/wraprecyclerview)，如有需要请自取~\n","tags":["Android","RecyclerView","自定义控件"],"categories":["Android"]},{"title":"几分钟完成发布开源库到jCenter","url":"/2017/10/31c771f65733/","content":"---\n\n在AndroidStudio中导入开源库一般就是一句话的事：`compile 'xxx.xx.xx:xx'`。 实际上我们也可以通过这种方式来导入自己的开源库，方便自己的使用。AndroidStudio执行`compile 'xxx.xxx.xx:xx'` 会先到jCenter上查找该开源库，所以需要我们把自己的开源库库发布到jCenter上。无法直接在jCenter上发布开源库，要通过它的托管商--Bintray（Bintray托管着很多仓库，jCenter只是其中一个）来完成。\n\n把自己平时经常用到的一些代码写到一起上传到jCenter，以后不管做什么项目一句话就能导入，算来还是一个比较实用的功能。\n<!--more-->\n#### 总体步骤概览\n\n >  [1. 注册Bintray账号并创建仓库](#step1)\n    [2. 准备开源库](#step2)\n    [3. 修改gradle文件](#step3)\n    [4. 编译并上传至Bintray](#step4)\n    [5. linked to jCenter](#step5)\n\n\n----------\n<h3 id=\"step1\"> 1. 注册Bintray账号并创建仓库</h3>\n\n使用Bintray当然要先注册个账号，[注册地址](https://bintray.com/signup/oss)\n\n![注册界面](https://i.loli.net/2021/07/02/nDrYj29khgLP3HQ.png)\n我选的是`Sign up with Github`。\n注册登录之后应该是这个样子， 点击`Add New Repository`\n\n![](https://i.loli.net/2021/07/02/lSWt5zHh7qaBY1r.png)\n![](https://i.loli.net/2021/07/02/7gemVscRGIrH2MQ.png)\n\n* Name：仓库的名字，写了之后不能再改，记住该名字，后面上传时会用到；\n* Type：仓库类型，选择`Maven`；\n* License：开源协议，随便选一个就好；\n* Description：仓库描述，随便写；\n\n**点击`Create` 完成仓库创建，到此第一步完成。**\n\n\n----------\n<h3 id=\"step2\"> 2. 准备开源库</h3>\n\n备好你想要上传的开源库，有两种方式：\n1. AndroidStudio中new一个project，然后在project中new一个Module，类型选择`Android Library`.\n2. 直接修改当前Module的build.gradle（**注意区分project的build.gradle文件和Module的build.gradle文件，前者在project根目录下，后者在对应的Module目录下**）文件，将第一行的`apply plugin: 'com.android.application` 改为 `apply plugin: com.android.library` ，再把下面的`applicationId \"你的包名\"` 这一行删除(library是不允许有applicationId的).\n\n两种方式最终结果都是得到了一个`Android Library` 类型的Module，在Module里添加你想要上传的开源库代码（我随便弄了一个，里面有个我常用到的加载App Icon的方法）。\n\n**到此第二步准备开源库完成**\n\n\n----------\n<h3 id=\"step3\"> 3. 修改gradle文件</h3>\n\n**还是那句话，注意区分project的build.gradle文件和Module的build.gradle文件，前者在project根目录下，后者在对应的Module目录下**\n\n* 修改project的build.gradle文件，添加下面这两句话\n![](https://i.loli.net/2021/07/02/3xVtoCEBzNfD6KT.png)\n[*Maven Github地址*](https://github.com/dcendents/android-maven-gradle-plugin)：对应里面的说明选择使用的版本号\n[*Bintray Github地址*](https://github.com/bintray/gradle-bintray-plugin)：对应里面的说明选择使用的版本号\n\n* 修改Module的build.gradle文件（这步有点乱，认真看）\n需要配置3个信息：\n1. Bintray账号配置和Developer信息，告诉AndroidStudio传到哪及开发者介绍；\n2. Project信息，开源库的介绍；\n3. 上传配置，对以上3个信息的调用以及其他一些配置；\n\n为了看起来条理清晰，我把能独立的部分都独立到单独文件里了，便于阅读，以下分别说明。\n\n**1. Bintray账号信息和Developer信息**\n`AndroidStudio`创建项目时默认会在project根目录下创建`local.properties` 文件并添加到了`.gitignore` 文件中（如果没有请自行创建并添加至`.gitignore` 中），在其中添加以下内容：\n\n![](https://i.loli.net/2021/07/02/NevJYK8bCSkWUV5.png)\n\n * bintray.user：Bintray注册的用户名\n * bintray.apikey：Bintray的API key\n * developer.id：开源社区的昵称（一般指github，或是使用的其他开源社区）\n * developer.name：姓名\n * developer.email：邮箱地址\n\n*查看API key方法：*\n![](https://i.loli.net/2021/07/02/cPX6dYtHeijrZbl.png)\n![](https://i.loli.net/2021/07/02/78qtx2wumGjSy1d.png)\n\n\n**2. Project信息配置**\n\n在***开源库Module目录***下新建`project.properties`文件，添加以下内容：\n\n![](https://i.loli.net/2021/07/02/ho8iIzSP3tBxJK4.png)\n\n* project.name：开源库名字\n* project.groupId：项目组ID，写包名\n* project.artifaceId：项目ID，写Module名\n* project.packaging：打包方式，写aar\n* project.siteUrl：项目主页，没有就写github地址\n* project.gitUrl：项目仓库地址\n* javadoc.name：javadoc主页显示的名称，写项目名字就好\n\n**3. 上传配置**\n\n在***开源库Module目录***下新建`bintrayUpload.gradle`文件，添加以下内容：(内容较多，直接贴源码了，阅读可能不太美观）\n\n```groovy\napply plugin: 'com.github.dcendents.android-maven'\napply plugin: 'com.jfrog.bintray'\n\n// load properties\nProperties properties = new Properties()\n\nFile projectPropertiesFile = project.file(\"project.properties\")\nif(projectPropertiesFile.exists()){\n    properties.load(projectPropertiesFile.newDataInputStream())\n}\n\n// read properties\ndef projectName = properties.getProperty(\"project.name\")\ndef projectGroupId = properties.getProperty(\"project.groupId\")\ndef projectArtifactId = properties.getProperty(\"project.artifactId\")\ndef projectVersionName = android.defaultConfig.versionName\ndef projectPackaging = properties.getProperty(\"project.packaging\")\ndef projectSiteUrl = properties.getProperty(\"project.siteUrl\")\ndef projectGitUrl = properties.getProperty(\"project.gitUrl\")\ndef javadocName = properties.getProperty(\"javadoc.name\")\n\n\nFile localPropertiesFile = project.rootProject.file(\"local.properties\")\nif(localPropertiesFile.exists()){\n    properties.load(localPropertiesFile.newDataInputStream())\n}\ndef developerId = properties.getProperty(\"developer.id\")\ndef developerName = properties.getProperty(\"developer.name\")\ndef developerEmail = properties.getProperty(\"developer.email\")\n\ndef bintrayUser = properties.getProperty(\"bintray.user\")\ndef bintrayApikey = properties.getProperty(\"bintray.apikey\")\n\n\ngroup = projectGroupId\n\n// This generates POM.xml with proper parameters\ninstall {\n    repositories.mavenInstaller {\n        pom {\n            project {\n                name projectName\n                groupId projectGroupId\n                artifactId projectArtifactId\n                version projectVersionName\n                packaging projectPackaging\n                url projectSiteUrl\n                licenses {\n                    license {\n                        name 'The Apache Software License, Version 2.0'\n                        url 'http://www.apache.org/licenses/LICENSE-2.0.txt'\n                    }\n                }\n                developers {\n                    developer {\n                        id developerId\n                        name developerName\n                        email developerEmail\n                    }\n                }\n                scm {\n                    connection projectGitUrl\n                    developerConnection projectGitUrl\n                    url projectSiteUrl\n                }\n            }\n        }\n    }\n}\n\n// This generates sources.jar\ntask sourcesJar(type: Jar) {\n    from android.sourceSets.main.java.srcDirs\n    classifier = 'sources'\n}\n\ntask javadoc(type: Javadoc) {\n    source = android.sourceSets.main.java.srcDirs\n    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))\n}\n\n// This generates javadoc.jar\ntask javadocJar(type: Jar, dependsOn: javadoc) {\n    classifier = 'javadoc'\n    from javadoc.destinationDir\n}\n\nartifacts {\n    archives javadocJar\n    archives sourcesJar\n}\n\n// javadoc configuration\njavadoc {\n    options{\n        encoding \"UTF-8\"\n        charSet 'UTF-8'\n        author true\n        version projectVersionName\n        links \"http://docs.oracle.com/javase/7/docs/api\"\n        title javadocName\n    }\n}\n\n// bintray configuration\nbintray {\n    user = bintrayUser\n    key = bintrayApikey\n    configurations = ['archives']\n    pkg {\n        repo = \"maven\"\n        name = projectName\n        websiteUrl = projectSiteUrl\n        vcsUrl = projectGitUrl\n        licenses = [\"Apache-2.0\"]\n        publish = true\n    }\n}\n```\n\n上传开源库的配置基本都是这样，不用改动什么，值得注意的是`bintray` 节点的`repo` 指的是第一步中创建的Maven仓库的名字，这两个名字要一致；此外开源库的版本号默认取的是project的版本号`def projectVersionName = android.defaultConfig.versionName`，如果有需要也可把这两个属性抽取到`project.properties` 文件中，便于管理。\n\n最后一个操作，在***开源库Module***的`build.gradle` 文件末尾中添加如下代码`apply from: 'bintrayUpload.gradle'` 来调用配置文件。\n\n**至此第3步配置gradle文件完成。**\n\n\n----------\n<h3 id=\"step4\"> 4. 编译并上传至Bintray</h3>\n\n* 编译：打开AndroidStudio的Terminal窗口（一般在底部，没有的话点击`顶部工具栏`->`View`->`Tools Windows`-> `Terminal`），输入命令并回车：\n\n> gradlew install\n\n等待一段时间后提示`BUILD SUCCESSFUL`，表示成功。\n\n* 上传，同样在Terminal中输入以下命令并回车：\n\n> gradlew bintrayUpload\n\n\n等待一段时间后提示`BUILD SUCCESSFUL`，表示成功。\n\n**至此第4步编译并上传完成。**\n\n\n----------\n<h3 id=\"step5\"> 5. Linked to jCenter</h3>\n\n![](https://i.loli.net/2021/07/02/LZm2MYtP8XJ1RjU.png)\n\n![](https://i.loli.net/2021/07/02/HKzyexF9aZscOdW.png)\n\n![](https://i.loli.net/2021/07/02/CNPLzhVtXdxnRI8.png)\n\n![](https://i.loli.net/2021/07/02/Ed6kULb9QNpMDAa.png)\n\n**按照上面4步，发送include request之后等待Bintray团队审核，审核完成后会收到邮件和站内信。**\n\n![](https://i.loli.net/2021/07/02/bdaZXRcOkflTy96.png)\n\n**至此第5步Linked to jCenter完成。**\n\n\n----------\n\n### 如果遇到问题，请参考这两篇文章\n\n1. [Android 项目打包到 JCenter 的坑](http://www.jianshu.com/p/c721f9297b2f?utm_campaign=hugo&utm_medium=reader_share&utm_content=note)\n2. [Android 发布项目到 JCenter 遇到的各种坑](http://www.jianshu.com/p/c518a10fdaed)\n\n\n#### **如有问题，欢迎指正~**","tags":["Android","jCenter"],"categories":["Android"]},{"title":"Android Drawable 和 xml文件转化关系","url":"/2017/09/8b0716318a1c/","content":"---\nDrawable类既可以在代码中创建也可以在xml文件中设置，以下是各类型的对应关系。\n<!--more-->\n`<selector />`---------`StateListDrawable`  \n`<level-list />`---------`LevelListDrawable`  \n`<layer-list />`---------`LayerDrawable`  \n`<transition />`---------`TransitionDrawable`  \n`<color />`---------`ColorDrawable`  \n`<shape />`---------`GradientDrawable`  \n`<scale />`---------`ScaleDrawable`  \n`<clip />`---------`ClipDrawable`  \n`<rotate/>`---------`RotateDrawable`  \n`<animation-list />`---------`AnimationDrawable`  \n`<inset />`---------`InsetDrawable`  \n`<bitmap/>`---------`BitmapDrawable`  \n`<nine-patch />`---------`NinePatchDrawable`  \n`<stupid-tag />`---------`Resources.NotFoundException`  ","tags":["Android","Drawable"],"categories":["Android"]},{"title":"Android改变图片属性之饱和度","url":"/2017/09/992c82f9c39e/","content":"---\n简单实现改变图片饱和度\n<!--more-->\n```\n ImageView image = (ImageView) findViewById(R.id.image);\n ColorMatrix matrix = new ColorMatrix();\n matrix.setSaturation(0f);\n image.setColorFilter(new ColorMatrixColorFilter(matrix));\n```\n\n**通过设置Matrix的参数来实现.**","tags":["Android","图片饱和度"],"categories":["Android"]},{"title":"Android 自定义样式通知栏的坑RemoteServiceException","url":"/2017/07/373186e06a55/","content":"---\nAndroid 自定义样式通知栏的坑RemoteServiceException\n```\nAndroid.app.RemoteServiceException: Bad notification posted from packagecom.my.package:\n\n```\n\n是的，就是这个异常。\n\n<!--more-->\n----------\n没有使用系统提供的三个方法\n\n```\nsetContentText（）\nsetContentTitle（）\nsetSmallIcon（）\n```\n而用的是`RemoteViews`，然后就掉坑里了。\n\n**原因是这样的，请往下看~**\n\n1. 布局中的控件只有**7种**，除此之外，均会报错！\n```\nAnalogClock，Button，Chronometer，ImageButton，mageView，ProgressBar，TextView\n```\n\n2. 另外还有一个问题，就是控件长宽的设定，必须为`0dp`，`wrap_content`或者`match_parent`，除此之外，也均会报错！\n\n```\nif (layoutWidth != 0 && layoutWidth != ViewGroup.LayoutParams.MATCH_PARENT\n            && layoutWidth != ViewGroup.LayoutParams.WRAP_CONTENT) {\n        throw new IllegalArgumentException(\"Only supports 0, WRAP_CONTENT and MATCH_PARENT\");\n    }\n```\n**这就是原因，内部会检测。但不知为何，我接收到的都是文章开头提到的那个异常，让人苦恼。**\n","tags":["Android","RemoteServiceException"],"categories":["Android"]},{"title":"Android获取系统相册所有图片","url":"/2017/06/eccdf08dbb5b/","content":"---\n\n### 直接获取所有照片的信息，而不是打开照片选择页面\n<!--more-->\n```java\n  private ArrayList<CategoryFile> queryCategoryFilesSync(FileType type) {\n    ArrayList<CategoryFile> files = new ArrayList<>();\n    Uri uri = MediaStore.Images.Media.getContentUri(\"external\");\n    if (uri != null) {\n        String[] projection = new String[]{FileColumns._ID, // id\n                FileColumns.DATA, // 文件路径\n                FileColumns.SIZE, // 文件大小\n                FileColumns.DATE_MODIFIED}; // 修改日期\n        Cursor cursor = getContentResolver().query(uri, projection, null, null, null);\n        if (cursor != null) {\n            try {\n                if (cursor.moveToFirst()) {\n                    final int pathIdx = cursor\n                            .getColumnIndex(FileColumns.DATA);\n                    final int sizeIdx = cursor\n                            .getColumnIndex(FileColumns.SIZE);\n                    final int modifyIdx = cursor\n                            .getColumnIndex(FileColumns.DATE_MODIFIED);\n                    do {\n                        String path = cursor.getString(pathIdx);\n                        CategoryFile file = new CategoryFile();\n                        file.mType = type;\n                        file.mPath = path;\n                        file.mParent = FileUtil.getPathFromFilepath(file.mPath);\n                        file.mName = FileUtil.getNameFromFilepath(file.mPath);\n                        file.mSize = cursor.getLong(sizeIdx);\n                        file.mLastModifyTime = cursor.getLong(modifyIdx);\n                        files.add(file);\n                    } while (cursor.moveToNext());\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n    return files;\n }\n```\n\n其中`CategoryFile`为存储照片信息的Bean类\n### FileUtil类\n```java\npublic class FileUtil {\n\n    private static final char UNIX_SEPARATOR = '/';\n\n    public static String getPathFromFilepath(String filepath) {\n        if (!TextUtils.isEmpty(filepath)) {\n            int pos = filepath.lastIndexOf(UNIX_SEPARATOR);\n            if (pos != -1) {\n                return filepath.substring(0, pos);\n            }\n        }\n        return \"\";\n    }\n\n    public static String getNameFromFilepath(String filepath) {\n        if (!TextUtils.isEmpty(filepath)) {\n            int pos = filepath.lastIndexOf(UNIX_SEPARATOR);\n            if (pos != -1) {\n                return filepath.substring(pos + 1);\n            }\n        }\n        return \"\";\n    }\n}\n```","tags":["Android"],"categories":["Android"]},{"title":"正则表达式(Regular Expression)","url":"/2017/05/cbfcda6ce2f5/","content":"---\n\n***整理参考于** : http://www.runoob.com/regexp/regexp-tutorial.html*\n<!--more-->\n\n## **一. 简介**\n\n\n#### ^[0-9]+abc$\n - `^` 为匹配输入字符串的开始位置。\n - `[0-9]+` 匹配多个数字 `[0-9]` 匹配单个数字 `+` 匹配一个或者多个\n - `abc$`匹配字母 `abc` 并以 `abc` 结尾，`$` 为匹配输入字符串的结束位置。\n\n\n## **二. 语法**\n\n正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n例如：\n\n - runoo+b，可以匹配 runoob、runooob、runoooooob 等，**`+` 号代表前面的字符必须至少出现一次（1次或多次）**。\n - runoo*b，可以匹配 runob、runoob、runoooooob 等，**`*` 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）**。\n - colou?r 可以匹配 color 或者 colour，**`?` 问号代表前面的字符最多只可以出现一次（0次、或1次）**。\n\n\n## **三. 字符分类**\n\n### 1. 普通字符\n普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。\n\n\n### 2. 非打印字符\n非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：\n   字符 | 描述    \n  :: | \n\\cx\t|匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。\n\\f\t|匹配一个换页符。等价于 \\x0c 和 \\cL。\n\\n\t|匹配一个换行符。等价于 \\x0a 和 \\cJ。\n\\r\t|匹配一个回车符。等价于 \\x0d 和 \\cM。\n\\s\t|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。\n\\S\t|匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n\\t\t|匹配一个制表符。等价于 \\x09 和 \\cI。\n\\v\t|匹配一个垂直制表符。等价于 \\x0b 和 \\cK。\n\n\n### 3. 特殊字符\n所谓特殊字符，就是一些有特殊含义的字符，如上面说的 `runoo*b` 中的` *`，简单的说就是表示任何字符串的意思。如果要查找字符串中的` *` 符号，则需要对` *` 进行转义，即在其前加一个` \\: runo\\*ob` 匹配 `runo*ob`。\n许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符\"转义\"，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符：\n\n  特别字符 | 描述\n  :-----:|-----\n \\$ | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。\n( )\t|标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。\n\\*\t| 匹配前面的子表达式零次或多次。要匹配 `*` 字符，请使用 `\\*`。\n\\+\t|  匹配前面的子表达式一次或多次。要匹配 `+` 字符，请使用 `\\+`。\n\\.\t| 匹配除换行符 \\n 之外的任何单字符。要匹配 `.` ，请使用 `\\.` 。\n\\[\t| 标记一个中括号表达式的开始。要匹配 `[`，请使用 `\\[`。\n?\t| 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 `?` 字符，请使用 `\\?`。\n\\\t| 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， `'n'` 匹配字符 `'n'`。`'\\n'` 匹配换行符。序列 `'\\\\'` 匹配 `\"\\\"`，而 `'\\('` 则匹配 `\"(\"`。\n^\t| 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 `^` 字符本身，请使用 `\\^`。\n{\t| 标记限定符表达式的开始。要匹配 `{`，请使用 `\\{`。\n\\|\t| 指明两项之间的一个选择。要匹配 `|`，请使用 `\\|`。\n\n### 4. 限定符\n限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。\n正则表达式的限定符有：\n\n字符 | \t描述\n:-----:|-----\n\\*|\t匹配前面的子表达式零次或多次。例如，`zo*` 能匹配 `\"z\"` 以及 `\"zoo\"`。`*` 等价于`{0,}`。\n\\+|匹配前面的子表达式一次或多次。例如，`'zo+'` 能匹配 `\"zo\"` 以及 `\"zoo\"`，但不能匹配 `\"z\"`。`+` 等价于 `{1,}`。\n?|\t匹配前面的子表达式零次或一次。例如，`\"do(es)?\"` 可以匹配 `\"do\"` 或 `\"does\"` 中的`\"do\"` 。`?` 等价于 `{0,1}`。\n{n}\t|`n`是一个非负整数。匹配确定的 `n` 次。例如，`'o{2}'` 不能匹配 `\"Bob\"` 中的 `'o'`，但是能匹配 `\"food\"` 中的两个 `o`。\n{n,}|`n` 是一个非负整数。至少匹配`n` 次。例如，`'o{2,}'` 不能匹配 `\"Bob\"` 中的 `'o'`，但能匹配 `\"foooood\"` 中的所有 `o`。`'o{1,}'` 等价于 `'o+'`。`'o{0,}'` 则等价于 `'o*'`。\n{n,m}|`m` 和 `n` 均为非负整数，其中`n <= m`。最少匹配 `n` 次且最多匹配 `m` 次。例如，`\"o{1,3}\"` 将匹配 `\"fooooood\"` 中的前三个 `o`。`'o{0,1}'` 等价于 `'o?'`。请注意在逗号和两个数之间不能有空格。\n\n 由于章节编号在大的输入文档中会很可能超过九，所以您需要一种方式来处理两位或三位章节编号。限定符给您这种能力。下面的正则表达式匹配编号为任何位数的章节标题：\n`/Chapter [1-9][0-9]*/`\n\n请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。\n这里不使用 `+` 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用`？`字符，因为它将章节编号限制到只有两位数。您需要至少匹配 Chapter 和空格字符后面的一个数字。\n如果您知道章节编号被限制为只有 99 章，可以使用下面的表达式来至少指定一位但至多两位数字。\n`/Chapter [0-9]{1,2}/`\n\n上面的表达式的缺点是，大于 99 的章节编号仍只匹配开头两位数字。另一个缺点是 Chapter 0 也将匹配。只匹配两位数字的更好的表达式如下：\n`/Chapter [1-9][0-9]?/`\n\n或\n`/Chapter [1-9][0-9]{0,1}/`\n\n`*`、`+`和`?`限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。\n例如，您可能搜索 HTML 文档，以查找括在 H1 标记内的章节标题。该文本在您的文档中如下：\n>```<H1>Chapter 1 - 介绍正则表达式</H1>```\n\n**贪婪**：下面的表达式匹配从开始小于符号 (<) 到关闭 H1 标记的大于符号 (>) 之间的所有内容。\n`/<.*>/`\n\n**非贪婪**：如果您只需要匹配开始和介绍 H1 标记，下面的非贪婪表达式只匹配 `<H1>`。\n`/<.*?>/`\n\n如果只想匹配开始的 H1 标签，表达式则是：\n`/<\\w+?>/`\n\n通过在`*`、`+` 或 `?` 限定符之后放置 `?`，该表达式从\"贪心\"表达式转换为\"非贪心\"表达式或者最小匹配。\n\n### 5. 定位符\n定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。\n定位符用来描述字符串或单词的边界，`^` 和`$` 分别指字符串的开始与结束，`span class=\"marked\">\\b` 描述单词的前或后边界，`span class=\"marked\">\\B` 表示非单词边界。\n正则表达式的限定符有：\n\n字符 |\t描述\n:-----:|-----\n^\t|匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。\n\\$\t|匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。\n\\b\t|匹配一个字边界，即字与空格间的位置。\n\\B\t|非字边界匹配。\n\n**注意**：不能将限定符与定位点一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 `^*` 之类的表达式。\n若要匹配一行文本开始处的文本，请在正则表达式的开始使用 `^` 字符。不要将 `^` 的这种用法与中括号表达式内的用法混淆。\n若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 `$` 字符。\n若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：\n`/^Chapter [1-9][0-9]{0,1}/`\n\n真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。\n`/^Chapter [1-9][0-9]{0,1}$/`\n\n匹配字边界稍有不同，但向正则表达式添加了很重要的能力。字边界是单词和空格之间的位置。非字边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现字边界后面：\n`/\\bCha/`\n\n`\\b` 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在字边界的前面：\n`/ter\\b/`\n\n下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：\n`/\\Bapt/`\n\n字符串 apt 出现在单词 Chapter 中的非字边界处，但出现在单词 aptitude 中的字边界处。对于 \\B 非字边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。\n\n### 6. 选择\n用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。\n\n其中 `?:` 是非捕获元之一，还有两个非捕获元是 `?=` 和 `?!`，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。\n\n### 7. 反向引用\n对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 `\\n` 访问，其中 `n` 为一个标识特定缓冲区的一位或两位十进制数。\n可以使用非捕获元字符 `?:`、`?=` 或 `?!` 来重写捕获，忽略对相关匹配的保存。\n\n反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：\n`Is is the cost of of gasoline going up up?`\n\n上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。\n\n\n## **四. 元字符**\n\n下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：\n\n字符 |\t描述\n:-: | ----\n\\\t|将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 \"n\"。'\\n' 匹配一个换行符。序列 '\\\\' 匹配 \"\\\" 而 \"\\(\" 则匹配 \"(\"。\n^\t|配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。\n\\$\t|匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。\n\\*|匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。\n+|匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。\n?\t|匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 中的\"do\" 。? 等价于 {0,1}。\n{n}\t|n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。\n{n,}\t|n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。\n{n,m}\t|m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。\n?\t|当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \"oooo\"，'o+?' 将匹配单个 \"o\"，而 'o+' 将匹配所有 'o'。\n.\t|匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用像\"(.|\\n)\"的模式。\n(pattern)|匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\\(' 或 '\\)'。\n(?:pattern)|匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。\n(?=pattern)\t|正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 \"Windows 2000\" 中的 \"Windows\" ，但不能匹配 \"Windows 3.1\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。\n(?!pattern)\t|负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 \"Windows 3.1\" 中的 \"Windows\"，但不能匹配 \"Windows 2000\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。\nx\\|y|匹配 x 或 y。例如，'z|food' 能匹配 \"z\" 或 \"food\"。'(z|f)ood' 则匹配 \"zood\" 或 \"food\"。\n[xyz]\t|字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 \"plain\" 中的 'a'。\n[^xyz]\t|负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 \"plain\" 中的'p'、'l'、'i'、'n'。\n[a-z]\t|字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。\n[^a-z]\t|负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。\n\\b\t|匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。\n\\B\t|匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。\n\\cx\t|匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。\n\\d\t|匹配一个数字字符。等价于 [0-9]。\n\\D\t|匹配一个非数字字符。等价于 [^0-9]。\n\\f\t|匹配一个换页符。等价于 \\x0c 和 \\cL。\n\\n\t|匹配一个换行符。等价于 \\x0a 和 \\cJ。\n\\r\t|匹配一个回车符。等价于 \\x0d 和 \\cM。\n\\s\t|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。\n\\S\t|匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n\\t\t|匹配一个制表符。等价于 \\x09 和 \\cI。\n\\v\t|匹配一个垂直制表符。等价于 \\x0b 和 \\cK。\n\\w\t|匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。\n\\W\t|匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。\n\\xn\t|匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\\x41' 匹配 \"A\"。'\\x041' 则等价于 '\\x04' & \"1\"。正则表达式中可以使用 ASCII 编码。\n\\num|匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\\1' 匹配两个连续的相同字符。\n\\n\t|标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\n\\nm\t|标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。\n\\nml|如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。\n\\un\t|匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。\n\n## **五. 运算符优先级**\n\n正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。\n相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：\n\n运算符|\t描述\n:-| ---\n\\\t|转义符\n(), (?:), (?=), []\t|圆括号和方括号\n*, +, ?, {n}, {n,}, {n,m}\t|限定符\n^, $, \\任何元字符、任何字符\t|定位点和序列（即：位置和顺序）\n\\||替换，\"或\"操作字符具有高于替换运算符的优先级，使得\"m\\|food\"匹配\"m\"或\"food\"。若要匹配\"mood\"或\"food\"，请使用括号创建子表达式，从而产生\"(m\\|f)ood\"。\n\n\n## **六. 匹配规则**\n\n#### **1. 基本模式匹配**\n一切从最基本的开始。模式，是正规表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：\n`^once`\n\n这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串\"once upon a time\"匹配，与\"There once was a man from NewYork\"不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。\n`bucket$`\n\n这个模式与\"Who kept all of this cash in a bucket\"匹配，与\"buckets\"不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如：\n`^bucket$`\n\n只匹配字符串\"bucket\"。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式\n> once\n\n与字符串\n> There once was a man from NewYork\nWho kept all of his cash in a bucket.\n\n是匹配的。\n在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠(\\)打头。制表符的转义序列是：\\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：\n> ^\\t \n\n类似的，用\\n表示\"新行\"，\\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\\\\表示，句号.用\\.表示，以此类推。\n\n#### **2. 字符簇**\n字符簇\n在INTERNET的程序中，正规表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。\n所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：\n> [AaEeIiOoUu]\n\n这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：\n>[a-z] //匹配所有的小写字母 \n[A-Z] //匹配所有的大写字母 \n[a-zA-Z] //匹配所有的字母 \n[0-9] //匹配所有的数字 \n[0-9\\.\\-] //匹配所有的数字，句号和减号 \n[ \\f\\r\\t\\n] //匹配所有的白字符\n\n同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如\"z2\"、\"t6\"或\"g7\"，但不是\"ab2\"、\"r2d3\" 或\"b52\"的话，用这个模式：\n> ^[a-z][0-9]$\n\n尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。\n前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用^是，它表示\"非\"或\"排除\"的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：\n> ^[^0-9][0-9]$\n\n这个模式与\"&5\"、\"g7\"及\"-2\"是匹配的，但与\"12\"、\"66\"是不匹配的。下面是几个排除特定字符的例子：\n>[^a-z] //除了小写字母以外的所有字符 \n[^\\\\\\/\\^] //除了(\\)(/)(^)之外的所有字符 \n[^\\\"\\'] //除了双引号(\")和单引号(')之外的所有字符\n\n特殊字符\".\" (点，句号)在正则表达式中用来表示除了\"新行\"之外的所有字符。所以模式\"^.5$\"与任何两个字符的、以数字5结尾和以其他非\"新行\"字符开头的字符串匹配。模式\".\"可以匹配任何字符串，除了空串和只包括一个\"新行\"的字符串。\nPHP的正规表达式有一些内置的通用字符簇，列表如下：\n\n字符簇|\t描述\n-|-\n[[:alpha:]]\t|任何字母\n[[:digit:]]\t|任何数字\n[[:alnum:]]\t|任何字母和数字\n[[:space:]]\t|任何空白字符\n[[:upper:]]\t|任何大写字母\n[[:lower:]]\t|任何小写字母\n[[:punct:]]\t|任何标点符号\n[[:xdigit:]]\t|任何16进制的数字，相当于[0-9a-fA-F]\n\n#### **4. 确定重复出现**\n到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。\n\n字符簇\t|描述\n-|-\n^[a-zA-Z_]$\t|所有的字母和下划线\n^[[:alpha:]]{3}$|\t所有的3个字母的单词\n^a$\t|字母a\n^a{4}$|\taaaa\n^a{2,4}$\t|aa,aaa或aaaa\n^a{1,3}$\t|a,aa或aaa\n^a{2,}$\t|包含多于两个a的字符串\n^a{2,}\t|如：aardvark和aaab，但apple不行\na{2,}\t|如：baad和aaa，但Nantucket不行\n\\t{2}\t|两个制表符\n.{2}\t|所有的两个字符\n\n这些例子描述了花括号的三种不同的用法。一个数字 {x} 的意思**是前面的字符或字符簇只出现x次** ；一个数字加逗号** {x,}** 的意思是**前面的内容出现x或更多的次数** ；两个数字用逗号分隔的数字** {x,y}** 表示 **前面的内容至少出现x次，但不超过y次**。我们可以把模式扩展到更多的单词或数字：\n>^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母、数字或下划线的字符串 \n^[1-9][0-9]{0,}$        // 所有的正整数 \n^\\-{0,1}[0-9]{1,}$      // 所有的整数 \n^[-]?[0-9]+\\.?[0-9]+$   // 所有的浮点数\n\n最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 (**[-]?**) 开头 (^)、跟着1个或更多的数字(**[0-9]+**)、和一个小数点(\\.)再跟上1个或多个数字(**[0-9]+**)，并且后面没有其他任何东西(**$**)。下面你将知道能够使用的更为简单的方法。\n\n特殊字符** ?** 与 **{0,1}** 是相等的，它们都代表着： **0个或1个前面的内容** 或 **前面的内容是可选的** 。所以刚才的例子可以简化为：\n>^\\-?[0-9]{1,}\\.?[0-9]{1,}$\n\n特殊字符 ***** 与 **{0,}** 是相等的，它们都代表着 **0 个或多个前面的内容** 。最后，字符 **+** 与 **{1,}** 是相等的，表示 **1 个或多个前面的内容** ，所以上面的4个例子可以写成：\n>^[a-zA-Z0-9_]+\\$      // 所有包含一个以上的字母、数字或下划线的字符串 \n^[1-9][0-9]*\\$        // 所有的正整数 \n^\\-?[0-9]+\\$          // 所有的整数 \n^\\-?[0-9]+\\.?[0-9]*\\$ // 所有的浮点数\n\n当然这并不能从技术上降低正规表达式的复杂性，但可以使它们更容易阅读。\n\n## **七. 示例**\n\n#### **1. 简单表达式**\n正则表达式的最简单形式是在搜索字符串中匹配其本身的单个普通字符。例如，单字符模式，如 A，不论出现在搜索字符串中的何处，它总是匹配字母 A。下面是一些单字符正则表达式模式的示例：\n>/a/\n/7/\n/M/\n\n可以将许多单字符组合起来以形成大的表达式。例如，以下正则表达式组合了单字符表达式：a、7 和 M。\n> /a7M/\n\n请注意，没有串联运算符。只须在一个字符后面键入另一个字符。\n\n#### **2. 字符匹配**\n\n句点 (.) 匹配字符串中的各种打印或非打印字符，只有一个字符例外。这个例外就是换行符 (\\n)。下面的正则表达式匹配 aac、abc、acc、adc 等等，以及 a1c、a2c、a-c 和 a#c：\n> /a.c/\n\n若要匹配包含文件名的字符串，而句点 (.) 是输入字符串的组成部分，请在正则表达式中的句点前面加反斜扛 (\\) 字符。举例来说明，下面的正则表达式匹配 filename.ext：\n> /filename\\.ext/\n\n这些表达式只让您匹配\"任何\"单个字符。可能需要匹配列表中的特定字符组。例如，可能需要查找用数字表示的章节标题（Chapter 1、Chapter 2 等等）。\n\n#### **3. 中括号表达式**\n\n若要创建匹配字符组的一个列表，请在方括号（[ 和 ]）内放置一个或更多单个字符。当字符括在中括号内时，该列表称为\"中括号表达式\"。与在任何别的位置一样，普通字符在中括号内表示其本身，即，它在输入文本中匹配一次其本身。大多数特殊字符在中括号表达式内出现时失去它们的意义。不过也有一些例外，如：\n\n - 如果 ] 字符不是第一项，它结束一个列表。若要匹配列表中的 ] 字符，请将它放在第一位，紧跟在开始 [ 后面。\n - \\ 字符继续作为转义符。若要匹配 \\ 字符，请使用 \\\\\\。\n\n括在中括号表达式中的字符只匹配处于正则表达式中该位置的单个字符。以下正则表达式匹配 Chapter 1、Chapter 2、Chapter 3、Chapter 4 和 Chapter 5：\n>/Chapter [12345]/\n\n请注意，单词 Chapter 和后面的空格的位置相对于中括号内的字符是固定的。中括号表达式指定的只是匹配紧跟在单词 Chapter 和空格后面的单个字符位置的字符集。这是第九个字符位置。\n若要使用范围代替字符本身来表示匹配字符组，请使用连字符 (-) 将范围中的开始字符和结束字符分开。单个字符的字符值确定范围内的相对顺序。下面的正则表达式包含范围表达式，该范围表达式等效于上面显示的中括号中的列表。\n> /Chapter [1-5]/\n\n当以这种方式指定范围时，开始值和结束值两者都包括在范围内。注意，还有一点很重要，按 Unicode 排序顺序，开始值必须在结束值的前面。\n若要在中括号表达式中包括连字符，请采用下列方法之一：\n\n - 用反斜扛将它转义：\n>[\\-]\n \n - 将连字符放在中括号列表的开始或结尾。下面的表达式匹配所有小写字母和连字符：\n>[-a-z]\n[a-z-]\n \n - 创建一个范围，在该范围中，开始字符值小于连字符，而结束字符值等于或大于连字符。下面的两个正则表达式都满足这一要求：\n>[!--]\n[!-~]\n\n若要查找不在列表或范围内的所有字符，请将插入符号 (^) 放在列表的开头。如果插入字符出现在列表中的其他任何位置，则它匹配其本身。下面的正则表达式匹配1、2、3、4 或 5 之外的任何数字和字符：\n\n> /Chapter [^12345]/\n\n在上面的示例中，表达式在第九个位置匹配 1、2、3、4 或 5 之外的任何数字和字符。这样，例如，Chapter 7 就是一个匹配项，Chapter 9 也是一个匹配项。\n上面的表达式可以使用连字符 (-) 来表示：\n> /Chapter [^1-5]/\n\n中括号表达式的典型用途是指定任何大写或小写字母或任何数字的匹配。下面的表达式指定这样的匹配：\n> /[A-Za-z0-9]/\n\n#### **4. 替换和分组**\n\n替换使用 | 字符来允许在两个或多个替换选项之间进行选择。例如，可以扩展章节标题正则表达式，以返回比章标题范围更广的匹配项。但是，这并不象您可能认为的那样简单。替换匹配 | 字符任一侧最大的表达式。\n您可能认为，下面的表达式匹配出现在行首和行尾、后面跟一个或两个数字的 Chapter 或 Section：\n> /^Chapter|Section [1-9][0-9]{0,1}$/\n\n很遗憾，上面的正则表达式要么匹配行首的单词 Chapter，要么匹配行尾的单词 Section 及跟在其后的任何数字。如果输入字符串是 Chapter 22，那么上面的表达式只匹配单词 Chapter。如果输入字符串是 Section 22，那么该表达式匹配 Section 22。\n若要使正则表达式更易于控制，可以使用括号来限制替换的范围，即，确保它只应用于两个单词 Chapter 和 Section。但是，括号也用于创建子表达式，并可能捕获它们以供以后使用，这一点在有关反向引用的那一节讲述。通过在上面的正则表达式的适当位置添加括号，就可以使该正则表达式匹配 Chapter 1 或 Section 3。\n下面的正则表达式使用括号来组合 Chapter 和 Section，以便表达式正确地起作用：\n> /^(Chapter|Section) [1-9][0-9]{0,1}$/\n\n尽管这些表达式正常工作，但 Chapter|Section 周围的括号还将捕获两个匹配字中的任一个供以后使用。由于在上面的表达式中只有一组括号，因此，只有一个被捕获的\"子匹配项\"。\n\n在上面的示例中，您只需要使用括号来组合单词 Chapter 和 Section 之间的选择。若要防止匹配被保存以备将来使用，请在括号内正则表达式模式之前放置 ?:。下面的修改提供相同的能力而不保存子匹配项：\n> /^(?:Chapter|Section) [1-9][0-9]{0,1}$/\n\n除 ?: 元字符外，两个其他非捕获元字符创建被称为\"预测先行\"匹配的某些内容。正向预测先行使用 ?= 指定，它匹配处于括号中匹配正则表达式模式的起始点的搜索字符串。反向预测先行使用 ?! 指定，它匹配处于与正则表达式模式不匹配的字符串的起始点的搜索字符串。\n<br>\n例如，假设您有一个文档，该文档包含指向 Windows 3.1、Windows 95、Windows 98 和 Windows NT 的引用。再进一步假设，您需要更新该文档，将指向 Windows 95、Windows 98 和 Windows NT 的所有引用更改为 Windows 2000。下面的正则表达式（这是一个正向预测先行的示例）匹配 Windows 95、Windows 98 和 Windows NT：\n> /Windows(?=95 |98 |NT )/\n\n找到一处匹配后，紧接着就在匹配的文本（不包括预测先行中的字符）之后搜索下一处匹配。例如，如果上面的表达式匹配 Windows 98，将在 Windows 之后而不是在 98 之后继续搜索。\n\n#### **5. 其他示例**\n\n下面列出一些正则表达式示例：\n\n正则表达式\t|描述\n-| -\n/\\b([a-z]+) \\1\\b/gi\t|一个单词连续出现的位置。\n/(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/\t|将一个URL解析为协议、域、端口及相对路径。\n/^(?:Chapter\\|Section) [1-9][0-9]{0,1}\\$/\t|定位章节的位置。\n/[-a-z]/\t|a至z共26个字母再加一个-号。\n/ter\\b/\t|可匹配chapter，而不能匹配terminal。\n/\\Bapt/\t|可匹配chapter，而不能匹配aptitude。\n/Windows(?=95 \\|98 \\|NT )/\t|可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。\n/^\\s*$/\t|匹配空行。\n/\\d{2}-\\d{5}/\t|验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。\n/<\\s*(\\S+)(\\s[^>]*)?>[\\s\\S]*<\\s*\\/\\1\\s*>/\t|匹配 HTML 标记。","tags":["正则表达式"],"categories":["正则"]}]